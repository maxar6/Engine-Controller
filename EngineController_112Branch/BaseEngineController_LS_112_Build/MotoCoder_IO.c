
/* MotoCoder_IO.c */
/* Generated by MotoCoder */
/* Version: 0.12.4 */
/* At: 2022-11-22 13:57:05 */
/* Copyright: 2022 Woodward. */


#include <MotoCoder_IO.h>
#include <EncoderSupport_API.h>
#include <MuxVRDGInWithOverride_API.h>
#include <MC33800.h>
#include <MC33800Output_DD_API.h>
#include <Module.h>
#include <Processor.h>
#include <Processor_Generic.h>
#include <DeviceDrivers_Generic.h>

void SPI_B_Create(void);

void VISTA_1_Create(void);

extern const S_BasicOut_Defn_DiscreteOut CNKPullup;
	

void CNK_Encoder_Create(void);
static void CNK_Encoder_OnError_Callback(S_MuxVRDGInOverride_Defn_Encoder const* const device, E_PrimaryEncoderError eError);
static void CNK_Encoder_OnStateChanged_Callback(S_MuxVRDGInOverride_Defn_Encoder const* const device, E_PrimaryEncoderStatus eStatus);

void ESTOPPin_DigitalInput_Create(void);

void SPI_C_Create(void);

extern const S_BasicOut_Defn_DiscreteOut ODRC;
	

void S_SHRC_3_Create(void);

void DOut10176p0004_DiscreteOutput_Create(void);
void DOut10176p0004_DiscreteOutput_Stop(void);

void MC33800_LSO2_DiscreteOutput_Create(void);

extern const S_BasicOut_Defn_DiscreteOut DOut11001p0004;
	

void MC33800_MPRD_DiscreteOutput_Create(void);

extern const S_BasicOut_Defn_DiscreteOut DOut11529p0004;
	

void RS485_SerialLink_Create(void);

void ContinuousScan_eQADCQueue_Create(void);

extern const S_AnalogQueueDefn ContinuousScan_eQADCQueue;
	

void MAPSensorPin_Create(void);

void DRVP_Create(void);

void XDRP_Create(void);

void AN12_Create(void);

void AN13_Create(void);

extern const S_BasicOut_Defn_DiscreteOut SPD1Pullup;
	

void SPD1_FrequencyInput_Create(void);

void SPD2_FrequencyInput_Create(void);

void SPD3_FrequencyInput_Create(void);

void S_SHRC_4_Create(void);

void MC33800_LSO9_DiscreteOutput_Create(void);

void LSO9_PWMOutput_PWMOutput_Stop(void);

void MC33800_LSO10_DiscreteOutput_Create(void);

void LSO10_PWMOutput_PWMOutput_Stop(void);

void H1p_PWMOutput_Stop(void);

void H1m_PWMOutput_Stop(void);

void H1_InhibitA_PWMOutput_Stop(void);

void H1_InhibitB_PWMOutput_Stop(void);

void H1p_H1m_PWMOutput_Create(void);
void H1p_H1m_PWMOutput_Enable_Set(boolean_T in_bEnable);
void H1p_H1m_PWMOutput_Stop(void);

void H2p_PWMOutput_Stop(void);

extern const S_BasicOut_Defn_DiscreteOut H2_InhibitA;
	

void H2p_PWMOutput_PWMOutput_Stop(void);

void H2m_PWMOutput_Stop(void);

extern const S_BasicOut_Defn_DiscreteOut H2_InhibitB;
	

void H2m_PWMOutput_PWMOutput_Stop(void);

void MC33800_LSO8_DiscreteOutput_Create(void);

void LSO8_PWMOutput_PWMOutput_Stop(void);

extern const S_BasicOut_Defn_DiscreteOut CAMPullup;
	

void CAM_Encoder_Create(void);

void ESTDiagnostics_eQADCQueue_Create(void);

extern const S_AnalogQueueDefn ESTDiagnostics_eQADCQueue;
	

void EST1_PSPOutput_Stop(void);

void EST1_PSPOutput_Create(void);

void EST2_PSPOutput_Stop(void);

void EST2_PSPOutput_Create(void);

void EST3_PSPOutput_Stop(void);

void EST3_PSPOutput_Create(void);

void EST4_PSPOutput_Stop(void);

void EST4_PSPOutput_Create(void);

void EST5_PSPOutput_Stop(void);

void EST5_PSPOutput_Create(void);

void EST6_PSPOutput_Stop(void);

void EST6_PSPOutput_Create(void);

void EST7_PSPOutput_Stop(void);

void EST7_PSPOutput_Create(void);

void EST8_PSPOutput_Stop(void);

void EST8_PSPOutput_Create(void);

void MC33800_INJ1_DiscreteOutput_Create(void);

void INJ1_PSPOutput_TransientBehavior_OnEndOfPulse(uint8_T uPulse);
static void INJ1_PSPOutput_OnPulseEnd_Callback(struct S_BasicOut_Defn_PSP const* const pThisPSP, S_PSPEndOfEventReport* const pReport);
void INJ1_PSPOutput_Stop(void);

void INJ1_PSPOutput_Create(void);

void MC33800_INJ2_DiscreteOutput_Create(void);

void INJ2_PSPOutput_TransientBehavior_OnEndOfPulse(uint8_T uPulse);
static void INJ2_PSPOutput_OnPulseEnd_Callback(struct S_BasicOut_Defn_PSP const* const pThisPSP, S_PSPEndOfEventReport* const pReport);
void INJ2_PSPOutput_Stop(void);

void INJ2_PSPOutput_Create(void);

void MC33800_INJ3_DiscreteOutput_Create(void);

void INJ3_PSPOutput_TransientBehavior_OnEndOfPulse(uint8_T uPulse);
static void INJ3_PSPOutput_OnPulseEnd_Callback(struct S_BasicOut_Defn_PSP const* const pThisPSP, S_PSPEndOfEventReport* const pReport);
void INJ3_PSPOutput_Stop(void);

void INJ3_PSPOutput_Create(void);

void MC33800_INJ4_DiscreteOutput_Create(void);

void INJ4_PSPOutput_TransientBehavior_OnEndOfPulse(uint8_T uPulse);
static void INJ4_PSPOutput_OnPulseEnd_Callback(struct S_BasicOut_Defn_PSP const* const pThisPSP, S_PSPEndOfEventReport* const pReport);
void INJ4_PSPOutput_Stop(void);

void INJ4_PSPOutput_Create(void);

void MC33800_INJ5_DiscreteOutput_Create(void);

void INJ5_PSPOutput_TransientBehavior_OnEndOfPulse(uint8_T uPulse);
static void INJ5_PSPOutput_OnPulseEnd_Callback(struct S_BasicOut_Defn_PSP const* const pThisPSP, S_PSPEndOfEventReport* const pReport);
void INJ5_PSPOutput_Stop(void);

void INJ5_PSPOutput_Create(void);

void MC33800_INJ6_DiscreteOutput_Create(void);

void INJ6_PSPOutput_TransientBehavior_OnEndOfPulse(uint8_T uPulse);
static void INJ6_PSPOutput_OnPulseEnd_Callback(struct S_BasicOut_Defn_PSP const* const pThisPSP, S_PSPEndOfEventReport* const pReport);
void INJ6_PSPOutput_Stop(void);

void INJ6_PSPOutput_Create(void);

void MC33800_INJ7_DiscreteOutput_Create(void);

void INJ7_PSPOutput_TransientBehavior_OnEndOfPulse(uint8_T uPulse);
static void INJ7_PSPOutput_OnPulseEnd_Callback(struct S_BasicOut_Defn_PSP const* const pThisPSP, S_PSPEndOfEventReport* const pReport);
void INJ7_PSPOutput_Stop(void);

void INJ7_PSPOutput_Create(void);

void MC33800_INJ8_DiscreteOutput_Create(void);

void INJ8_PSPOutput_TransientBehavior_OnEndOfPulse(uint8_T uPulse);
static void INJ8_PSPOutput_OnPulseEnd_Callback(struct S_BasicOut_Defn_PSP const* const pThisPSP, S_PSPEndOfEventReport* const pReport);
void INJ8_PSPOutput_Stop(void);

void INJ8_PSPOutput_Create(void);

void SPI_D_Create(void);

void EEPROM_1_Create(void);

void MotoCoder_DiscreteOutput_UpdateOnChange_Create(S_BasicOut_Defn_DiscreteOut const* const in_pDefn, E_ResourceState* const in_peState, E_ResourceState in_eInitialState);
void MotoCoder_DiscreteOutput_UpdateOnChange_Set(S_BasicOut_Defn_DiscreteOut const* const in_pDefn, E_ResourceState* const in_peState, boolean_T value);
void MotoCoder_DiscreteOutput_UpdateOnChange_Stop(S_BasicOut_Defn_DiscreteOut const* const in_pDefn, E_ResourceState* const in_peState);
void DOut11001p0004_DiscreteOutput_Create(void);
void DOut11001p0004_DiscreteOutput_Stop(void);
void DOut11529p0004_DiscreteOutput_Create(void);
void DOut11529p0004_DiscreteOutput_Stop(void);
void H2_InhibitA_DiscreteOutput_Create(void);
void H2_InhibitA_DiscreteOutput_Stop(void);
void H2_InhibitB_DiscreteOutput_Create(void);
void H2_InhibitB_DiscreteOutput_Stop(void);
void MotoCoder_DiscreteOutput_UpdateAlways_Create(S_BasicOut_Defn_DiscreteOut const* const in_pDefn, E_ResourceState in_eInitialState);
void CNKPullup_DiscreteOutput_Create(void);
void ODRC_DiscreteOutput_Create(void);
void SPD1Pullup_DiscreteOutput_Create(void);
void CAMPullup_DiscreteOutput_Create(void);

INSTANTIATE_SPI_MODULE_DEFN(
		SPI_B,
		DSPI_B,
        1);
void SPI_B_Create(void)
{
	INSTANTIATE_SPI_MODULE_ATTRIBUTES(SPI_B_,
		DSPI_B,
		1,
		0,
		USE_SPI_CS0);

	SPI_B.pMethods->pfnCreate(&SPI_B, &SPI_B_Attrib);
}

/* --- VISTA SPI configuration ----------------------------------------------------------------------------*/

#ifndef FREQ_1MHZ
    #define FREQ_1MHz 1000000UL
#endif

/* in_uInputPeriodMult_Tcsc setting definition and verification 
   PCS-to-SCK input period multiplier
   VISTA: 1 ns minimum
   TARGET: 2 ns */
#define VISTA_PCS_TO_SCK_DELAY_FREQ        (500 * FREQ_1MHz)
/* Conversion rounds up always to ensure that the minimum multipler is sufficiently large enough to ensure that the
   timing will always meet the minimum target*/
#define VISTA_INPUT_PCS_TO_SCK_PERIOD_MULT ((__SYSTEM_CLOCK_FREQ_IN_HZ / VISTA_PCS_TO_SCK_DELAY_FREQ) + 1)
#define VISTA_INPUT_PCS_TO_SCK_PERIOD_MULT_UNLOCKPLL VISTA_INPUT_PCS_TO_SCK_PERIOD_MULT

/* in_uInputPeriodMult_Tasc setting definition and verification 
   After SCK delay input period multiplier
   VISTA: 1 ns minimum
   TARGET: 2 ns */
#define VISTA_AFTER_SCK_DELAY_FREQ         (500 * FREQ_1MHz)

/* in_uInputPeriodMult_Tasc setting definition and verification 
   After SCK delay input period multiplier
   VISTA: 2555 ns minimum */
#define VISTA_AFTER_SCK_DELAY_FREQ_UNLOCKPLL (391000)

/* Conversion rounds up always to ensure that the minimum multipler is sufficiently large enough to ensure that the
   timing will always meet the minimum target*/
#define VISTA_INPUT_AFTER_SCK_PERIOD_MULT  ((__SYSTEM_CLOCK_FREQ_IN_HZ / VISTA_AFTER_SCK_DELAY_FREQ) + 1)
#define VISTA_INPUT_AFTER_SCK_PERIOD_MULT_UNLOCKPLL ((__SYSTEM_CLOCK_FREQ_IN_HZ / VISTA_AFTER_SCK_DELAY_FREQ_UNLOCKPLL) + 1)

/* in_uInputPeriodMult_Tdt setting definition and verification 
   After transfer delay input period multiplier
   VISTA: 2 ns minimum
   IMPLEMENTED: 2 ns */
#define VISTA_AFTER_XFER_DELAY_FREQ        (500 * FREQ_1MHz)
#define VISTA_INPUT_AFTER_XFER_PERIOD_MULT ((__SYSTEM_CLOCK_FREQ_IN_HZ / VISTA_AFTER_XFER_DELAY_FREQ) + 1)
#define VISTA_INPUT_AFTER_XFER_PERIOD_MULT_UNLOCKPLL  VISTA_INPUT_AFTER_XFER_PERIOD_MULT

INSTANTIATE_VISTA_HW_DEFN(VISTA_1,
                          SPI_B,
                          USE_SPI_CS0,
                          NULL,
                          0,
                          1,
                          1,
                          VISTA_INPUT_PCS_TO_SCK_PERIOD_MULT,
                          VISTA_INPUT_AFTER_SCK_PERIOD_MULT,
                          VISTA_INPUT_AFTER_XFER_PERIOD_MULT,
                          VISTA_INPUT_PCS_TO_SCK_PERIOD_MULT_UNLOCKPLL,
                          VISTA_INPUT_AFTER_SCK_PERIOD_MULT_UNLOCKPLL,
                          VISTA_INPUT_AFTER_XFER_PERIOD_MULT_UNLOCKPLL,
                          8000000,
                          1);
void VISTA_1_Create(void)
{
    INSTANTIATE_VISTA_HW_ATTRIBUTES(CreateObj,                             /* Name */ 
                                                                                
/* in_eOscFreqBiasCurrent */                     SU1_OSCFRQ_188uA,                      
/* in_KDIV    */                                 VISTA_KDIV_4MHZ_INPUT_SOURCE,
/* in_NMUL    */                                 VISTA_NMUL_4MHZ_INPUT_SOURCE,
/* in_PDIV    */                                 VISTA_PDIV_4MHZ_INPUT_SOURCE,
/* in_eVS_D1  VRS 1 is CNKDG and VRS 4 
     (the diff channel) is CAM */                SU2_VS_D_SINGLE_ENDED_MODE,
/* in_eVS_D2  VRS 2 is connected to SPD2 VR +/- 
    (HACK: Single-Ended due to VISTA bug) */     SU2_VS_D_SINGLE_ENDED_MODE,
/* in_eVS_D3  VRS 3 is connected to SPD1 DG */   SU2_VS_D_SINGLE_ENDED_MODE,
/* in_eV_H1   VRS 1 is connected to CNK DG */    SU2_V_H_HALL_SENSOR,
/* in_eV_H2   VRS 2 is connected to SPD2 DG */   SU2_V_H_HALL_SENSOR,
/* in_eV_H3   VRS 3 is connected to SPD1 DG */   SU2_V_H_HALL_SENSOR,
/* in_eV_H4   VRS 4 is connected to CAM DG */    SU2_V_H_HALL_SENSOR,
/* in_eV_H5   VRS 5 is connected to SPD3 */      SU2_V_H_HALL_SENSOR,
/* in_eV_H6   VRS 6 is unused */                 SU2_V_H_HALL_SENSOR,
/* in_eTPT1   Trip point settings on VRS 
    signals will eventually come from the */     SU2_TPT_SYMMETRICAL_THRESHOLDS,
/* in_eTPT2   mask of the respective block.  
     Just use defaults for now */                SU2_TPT_SYMMETRICAL_THRESHOLDS,
/* in_eTPT3   */                                 SU2_TPT_SYMMETRICAL_THRESHOLDS,
/* in_eTPT4   */                                 SU2_TPT_SYMMETRICAL_THRESHOLDS,
/* in_eTPT5   */                                 SU2_TPT_SYMMETRICAL_THRESHOLDS,        
/* in_eTPT6   */                                 SU2_TPT_SYMMETRICAL_THRESHOLDS,
/* in_eSCTL   SPI output drive strength/slew 
     rate.  Use defaults for now */              SU3_SCTL_STRONG_DRIVER_FAST_EDGE,      


/* in_eA_MAF  MAFI/AD17 and MAFMI/AD18 pins 
     not connected. Use defaults. */             VISTA_SELECT_ADC_RESOURCE,            
/* in_eA_KP2  Select knock sensor input */       VISTA_SELECT_ADC_ALTERNATE,
/* in_eA_H3   Select HEGO3 */                    VISTA_SELECT_ADC_ALTERNATE,
/* in_eA_H4   Select HEGO4 */                    VISTA_SELECT_ADC_ALTERNATE,
/* in_eA_H5   Select HEGO5 */                    VISTA_SELECT_ADC_ALTERNATE,
/* in_eA_H6   Select HEGO6 */                    VISTA_SELECT_ADC_ALTERNATE,
/* in_eA_V4   Select VRS4 */                     VISTA_SELECT_ADC_ALTERNATE,
/* in_eA_V5   Select VRS5 */                     VISTA_SELECT_ADC_ALTERNATE,            
/* in_eA_V6   Select VRS6 */                     VISTA_SELECT_ADC_ALTERNATE,
/* in_eKSD    Select differential mode */        SU3_KSD_DIFFERENTIAL_MODE,
/* in_ePADPDM SPI output drive strength/slew 
    rate.  Use defaults for now */               SU3_SCTL_STRONG_DRIVER_FAST_EDGE,
                                    
/* in_eMAFD   */                                 SU4_MAFD_USE_DEFAULT_COEF_VALUES,
/* in_eKNKD   Assigns the coeffs for use by 
    knock subsystem (note this prevents use by 
	HEGO)*/                                      SU4_KNKD_USE_COEF_REG,                 
/* in_eHEG1D  */                                 SU4_HEGD_3_6_USE_DEFAULT_COEF_VALUES,
/* in_eHEG2D  */                                 SU4_HEGD_3_6_USE_DEFAULT_COEF_VALUES,
/* in_eHEG3D  */                                 SU4_HEGD_3_6_USE_DEFAULT_COEF_VALUES,
/* in_eHEG4D  */                                 SU4_HEGD_3_6_USE_DEFAULT_COEF_VALUES,
/* in_eHEG5D  */                                 SU4_HEGD_3_6_USE_DEFAULT_COEF_VALUES,
/* in_eHEG6D  */                                 SU4_HEGD_3_6_USE_DEFAULT_COEF_VALUES,
/* in_eHEG1V  */                                 SU4_HEGV_160HZ_SP_LOWPASS,
/* in_eHEG2V  */                                 SU4_HEGV_160HZ_SP_LOWPASS);            
                                    

    VISTA_HW_Create(&VISTA_1, &CreateObj);

}           



/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: VISTA_1_Register_Write
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
NativeError_S VISTA_1_Register_Write(NativeVar_U eReg, void const* pData, NativeVar_U uNumRegs)
{
    return(VISTA_Register_WriteBlock(&VISTA_1, (E_VISTA_Registers)eReg, pData, uNumRegs)); 
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: VISTA_1_Register_Read
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
NativeError_S VISTA_1_Register_Read(NativeVar_U eReg, void* out_pBuffer, NativeVar_U uNumRegs)
{
    return(VISTA_Register_ReadBlock(&VISTA_1, (E_VISTA_Registers)eReg, out_pBuffer, uNumRegs)); 
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: VISTA_1_Knock_IIR_Coefficient_Convert_FixedPtToReal
::
:: Converts the fixed point representation of a knock coefficient into a real
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
real32_T VISTA_1_Knock_IIR_Coefficient_Convert_FixedPtToReal(uint16_T u16Coeff)
{
    uint16_T u16Positive;
    real32_T r32Coeff;

    /* Drop the MSBit, which is the sign */
    u16Positive = u16Coeff & 0x7FFF;

    r32Coeff = (real32_T)u16Positive / 8192.0;
    if (u16Positive == u16Coeff)
    {
        /* Positive is the same as the passed in value so the passed in value is positive */
    }
    else
    {   /* Positive is different to the passed in value. Passed in is -ve */
        r32Coeff = r32Coeff * -1.0;
    }
    return(r32Coeff);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: VISTA_1_Knock_IIR_Coefficient_Convert_RealToFixedPt
::
:: Converts the real number representation of a knock coefficient into a Fixed point value
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
uint16_T VISTA_1_Knock_IIR_Coefficient_Convert_RealToFixedPt(real32_T r32Coeff)
{
    uint16_T u16Output;
    uint32_T uFixedPtValue;

    if (r32Coeff < 0)
    {   /* Is -ve so capture the sign and make the real positive */
        r32Coeff = -1*r32Coeff;
        u16Output = 0x8000;
    }
    else
    {
        u16Output = 0;
    }

    r32Coeff = r32Coeff * 8192.0;
    uFixedPtValue = (uint32_T)r32Coeff;
    if (uFixedPtValue > 0x7FFF)
    {   /* Clip the value to the maximum */
        uFixedPtValue = 0x7FFF;
    }
    u16Output = (u16Output) | (uFixedPtValue);
    return(u16Output);
}

/* FGNDTask - 45_135_225_315_405_495_585_675 */
static void OnAngle_FGNDTask_45_135_225_315_405_495_585_675(void)
{

    {extern void Trigger_FGND_MID_TDC_EVENT_9721p0004(void);
        Trigger_FGND_MID_TDC_EVENT_9721p0004();
    }
    {extern void Trigger_FGND_MID_TDC_EVENT_12066p0004(void);
        Trigger_FGND_MID_TDC_EVENT_12066p0004();
    }
}

/* FGNDTask - 0 */
static void OnAngle_FGNDTask_0(void)
{

    {extern void Trigger_FGND_TDC1_EVENT_869p0001(void);
        Trigger_FGND_TDC1_EVENT_869p0001();
    }
}

/* FGNDTask - 0_15_30_45_60_75_90_105_120_135_150_165_180_195_210_225_240_255_270_285_300_315_330_345_360_375_390_405_420_435_450_465_480_495_510_525_540_555_570_585_600_615_630_645_660_675_690_705 */
static void OnAngle_FGNDTask_0_15_30_45_60_75_90_105_120_135_150_165_180_195_210_225_240_255_270_285_300_315_330_345_360_375_390_405_420_435_450_465_480_495_510_525_540_555_570_585_600_615_630_645_660_675_690_705(void)
{

    {extern void Trigger_FGND_HIRES_6521p0004(void);
        Trigger_FGND_HIRES_6521p0004();
    }
}

/* FGNDTask - 0_90_180_270_360_450_540_630 */
static void OnAngle_FGNDTask_0_90_180_270_360_450_540_630(void)
{

    {extern void Trigger_FGND_TDC_EVENT_8437p0004(void);
        Trigger_FGND_TDC_EVENT_8437p0004();
    }
    {extern void Trigger_FGND_TDC_EVENT_10780p0004(void);
        Trigger_FGND_TDC_EVENT_10780p0004();
    }
}

    


typedef void (*PFNENCODERTOOTHDISPATCH)(void);


void CNK_EncoderOnPeriodicTooth_Tooth_0(void)
{
    
        {
            {
    extern void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void));
	extern void OnAngle_FGNDTask_0(void);
	extern const S_MessageBoxDefn g_FGNDTask_MailBox;
	MotoCoder_TaskEvent_Post(&g_FGNDTask_MailBox, OnAngle_FGNDTask_0);
}{
    extern void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void));
	extern void OnAngle_FGNDTask_0_15_30_45_60_75_90_105_120_135_150_165_180_195_210_225_240_255_270_285_300_315_330_345_360_375_390_405_420_435_450_465_480_495_510_525_540_555_570_585_600_615_630_645_660_675_690_705(void);
	extern const S_MessageBoxDefn g_FGNDTask_MailBox;
	MotoCoder_TaskEvent_Post(&g_FGNDTask_MailBox, OnAngle_FGNDTask_0_15_30_45_60_75_90_105_120_135_150_165_180_195_210_225_240_255_270_285_300_315_330_345_360_375_390_405_420_435_450_465_480_495_510_525_540_555_570_585_600_615_630_645_660_675_690_705);
}{
    extern void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void));
	extern void OnAngle_FGNDTask_0_90_180_270_360_450_540_630(void);
	extern const S_MessageBoxDefn g_FGNDTask_MailBox;
	MotoCoder_TaskEvent_Post(&g_FGNDTask_MailBox, OnAngle_FGNDTask_0_90_180_270_360_450_540_630);
}
        }
                
}

void CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47(void)
{
    
        {
            {
    extern void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void));
	extern void OnAngle_FGNDTask_0_15_30_45_60_75_90_105_120_135_150_165_180_195_210_225_240_255_270_285_300_315_330_345_360_375_390_405_420_435_450_465_480_495_510_525_540_555_570_585_600_615_630_645_660_675_690_705(void);
	extern const S_MessageBoxDefn g_FGNDTask_MailBox;
	MotoCoder_TaskEvent_Post(&g_FGNDTask_MailBox, OnAngle_FGNDTask_0_15_30_45_60_75_90_105_120_135_150_165_180_195_210_225_240_255_270_285_300_315_330_345_360_375_390_405_420_435_450_465_480_495_510_525_540_555_570_585_600_615_630_645_660_675_690_705);
}
        }
                
}

void CNK_EncoderOnPeriodicTooth_Tooth_3_9_15_21_27_33_39_45(void)
{
    
        {
            {
    extern void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void));
	extern void OnAngle_FGNDTask_45_135_225_315_405_495_585_675(void);
	extern const S_MessageBoxDefn g_FGNDTask_MailBox;
	MotoCoder_TaskEvent_Post(&g_FGNDTask_MailBox, OnAngle_FGNDTask_45_135_225_315_405_495_585_675);
}{
    extern void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void));
	extern void OnAngle_FGNDTask_0_15_30_45_60_75_90_105_120_135_150_165_180_195_210_225_240_255_270_285_300_315_330_345_360_375_390_405_420_435_450_465_480_495_510_525_540_555_570_585_600_615_630_645_660_675_690_705(void);
	extern const S_MessageBoxDefn g_FGNDTask_MailBox;
	MotoCoder_TaskEvent_Post(&g_FGNDTask_MailBox, OnAngle_FGNDTask_0_15_30_45_60_75_90_105_120_135_150_165_180_195_210_225_240_255_270_285_300_315_330_345_360_375_390_405_420_435_450_465_480_495_510_525_540_555_570_585_600_615_630_645_660_675_690_705);
}
        }
                
}

void CNK_EncoderOnPeriodicTooth_Tooth_6_12_18_24_30_36_42(void)
{
    
        {
            {
    extern void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void));
	extern void OnAngle_FGNDTask_0_15_30_45_60_75_90_105_120_135_150_165_180_195_210_225_240_255_270_285_300_315_330_345_360_375_390_405_420_435_450_465_480_495_510_525_540_555_570_585_600_615_630_645_660_675_690_705(void);
	extern const S_MessageBoxDefn g_FGNDTask_MailBox;
	MotoCoder_TaskEvent_Post(&g_FGNDTask_MailBox, OnAngle_FGNDTask_0_15_30_45_60_75_90_105_120_135_150_165_180_195_210_225_240_255_270_285_300_315_330_345_360_375_390_405_420_435_450_465_480_495_510_525_540_555_570_585_600_615_630_645_660_675_690_705);
}{
    extern void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void));
	extern void OnAngle_FGNDTask_0_90_180_270_360_450_540_630(void);
	extern const S_MessageBoxDefn g_FGNDTask_MailBox;
	MotoCoder_TaskEvent_Post(&g_FGNDTask_MailBox, OnAngle_FGNDTask_0_90_180_270_360_450_540_630);
}
        }
                
}

    

void CNK_EncoderOnPeriodicTooth(S_PrimaryEncoderDefn_CPU const* encoder, uint16_T uTooth)
{
    
    static const PFNENCODERTOOTHDISPATCH s_pfnMotoCoder_EncoderToothDispatchArr[] = 
    {
        /* Tooth 0 */ CNK_EncoderOnPeriodicTooth_Tooth_0,
        /* Tooth 1 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 2 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 3 */ CNK_EncoderOnPeriodicTooth_Tooth_3_9_15_21_27_33_39_45,
        /* Tooth 4 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 5 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 6 */ CNK_EncoderOnPeriodicTooth_Tooth_6_12_18_24_30_36_42,
        /* Tooth 7 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 8 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 9 */ CNK_EncoderOnPeriodicTooth_Tooth_3_9_15_21_27_33_39_45,
        /* Tooth 10 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 11 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 12 */ CNK_EncoderOnPeriodicTooth_Tooth_6_12_18_24_30_36_42,
        /* Tooth 13 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 14 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 15 */ CNK_EncoderOnPeriodicTooth_Tooth_3_9_15_21_27_33_39_45,
        /* Tooth 16 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 17 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 18 */ CNK_EncoderOnPeriodicTooth_Tooth_6_12_18_24_30_36_42,
        /* Tooth 19 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 20 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 21 */ CNK_EncoderOnPeriodicTooth_Tooth_3_9_15_21_27_33_39_45,
        /* Tooth 22 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 23 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 24 */ CNK_EncoderOnPeriodicTooth_Tooth_6_12_18_24_30_36_42,
        /* Tooth 25 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 26 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 27 */ CNK_EncoderOnPeriodicTooth_Tooth_3_9_15_21_27_33_39_45,
        /* Tooth 28 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 29 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 30 */ CNK_EncoderOnPeriodicTooth_Tooth_6_12_18_24_30_36_42,
        /* Tooth 31 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 32 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 33 */ CNK_EncoderOnPeriodicTooth_Tooth_3_9_15_21_27_33_39_45,
        /* Tooth 34 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 35 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 36 */ CNK_EncoderOnPeriodicTooth_Tooth_6_12_18_24_30_36_42,
        /* Tooth 37 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 38 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 39 */ CNK_EncoderOnPeriodicTooth_Tooth_3_9_15_21_27_33_39_45,
        /* Tooth 40 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 41 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 42 */ CNK_EncoderOnPeriodicTooth_Tooth_6_12_18_24_30_36_42,
        /* Tooth 43 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 44 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 45 */ CNK_EncoderOnPeriodicTooth_Tooth_3_9_15_21_27_33_39_45,
        /* Tooth 46 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,
        /* Tooth 47 */ CNK_EncoderOnPeriodicTooth_Tooth_1_2_4_5_7_8_10_11_13_14_16_17_19_20_22_23_25_26_28_29_31_32_34_35_37_38_40_41_43_44_46_47,

    };
    
    PFNENCODERTOOTHDISPATCH pfnTooth = s_pfnMotoCoder_EncoderToothDispatchArr[uTooth];
    
    if(pfnTooth != NULL)
    {
        pfnTooth();
    }
    
}

/* A PSP Angle Dispatcher is not required */




#include <Pragma_Section_Start_SDA.h>
uint8_T                s_CNK_bIsPulseSchedulingPossible;
E_PrimaryEncoderStatus s_eCNKEncoderState;
E_PrimaryEncoderError  s_eCNKEncoderError;
#include <Pragma_Section_End_SDA.h>


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: CNK_Encoder_OnPeriodic_CircuitSpecific
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
static void CNK_Encoder_OnPeriodic_CircuitSpecific(S_MuxVRDGInOverride_Defn_Encoder const* const pThis, uint16_T uTooth)
{
    CNK_EncoderOnPeriodicTooth(pThis->pEncoderCPUPinDefn, uTooth);
}

#define CNK_PATTERN_SPECIFIC_DATA_PTR NULL
			

#define CNK_uNUM_TEETH_IN_REV ( 24 ) 
INSTANTIATE_MuxVRDGInOverride_Encoder(
    
    
    /* Name                   */ CNK,
    /* uNumTeethInCycle       */ 48, 
    /* uNumTeethInRev         */ CNK_uNUM_TEETH_IN_REV,
    /* uNumDegreesInCycle     */ 720,                         
     
    /* uNumDegreesPerTooth    */ 15, 
    /* eStyle                 */ ENCODER_STYLE_GM24XE,
    /* uNumRevsPerCycle       */ 2,
    /* eHasCam                */ PRIMARY_ENCODER_HAS_CAM,
    /* uNumMissing            */ 0,
    /* pPatternSpecific       */ CNK_PATTERN_SPECIFIC_DATA_PTR,
                                 CPUCore_0,
    /* eOutPin_Processor      */ CPU,
    /* eOutPin                */ ETPU_TCRCLKA_N4,
    /* eOutPin_Type           */ ETPU,
    /* CamDeviceName          */ CAM,
    /* SpecifiedEventArr      */ NULL,
    /* uNumSpecifiedEvents    */ 0,
    /* eHandlerPriority       */ INTCPRIORITY_14,
    /* uPeriodicTeeth         */ 1,
    /* eHasRPMVector          */ ENCODER_RPM_VECTOR_UNUSED,
    /* uNumVectors            */ 0,
    /* pfnOnRPMVectorReady    */ NULL,
    /* pfnOnStateChange       */ CNK_Encoder_OnStateChanged_Callback,
    /* pfnOnError             */ CNK_Encoder_OnError_Callback,
    /* pfnOnPeriodic          */ CNK_Encoder_OnPeriodic_CircuitSpecific,
    /* pfnOnSpecifiedEvent    */ NULL,
    /* pfnOnPerCycleEvent     */ NULL,

    /* eVRMuxChan             */ 0,
    /* eDGMuxChan             */ 1,
    /* eOverrideMuxChan       */ 2,
    /* MUX Selector Configuration */
    /* Selector0_Processor, Selector0_Processor, Selector0_CPUPin, Selector0_Type, eSelect0AssertState, eSelect0OutputStage */
    VISTA_1, VISTA, GPO_VISTA_PWM4_GPIO4, GPIO,
    RES_POL_ACTIVE_HIGH, OUTPUT_IS_NON_INVERTING,
    /* Selector1_Processor, Selector1_Processor, Selector1_CPUPin, Selector1_Type, eSelect1AssertState, eSelect1OutputStage */
    VISTA_1, VISTA, GPO_VISTA_PWM5_GPIO5, GPIO,
    RES_POL_ACTIVE_HIGH, OUTPUT_IS_NON_INVERTING,
    /* Override_ProcName, eOverride_Processor, eOverride_CPUPin, eOverride_Type */
    CPUCore_0, CPU, ETPU_A26_F3, ETPU,
    /* eVRZeroCrossingEdge   */ RES_EDGE_DETECT_FALL,
    /* eDGInputStage         */ INPUT_IS_NON_INVERTING
		);
void CNK_Encoder_Create(void)
{

	S_MuxVRDGInOverride_Create_Encoder CreateObj;
	
	CreateObj.EncoderCreateAttribs_CPU.uValidAttributesMask = USE_ENCODER_DEFAULTS | USE_ENCODER_IGNORE_DELAY;
	CreateObj.EncoderCreateAttribs_CPU.eSyncEdge = RES_EDGE_DETECT_RISE;



	CreateObj.EncoderCreateAttribs_CPU.sCamDelay = CAMDelay_DataStore();

	
    CreateObj.EncoderCreateAttribs_CPU.uIgnoreDelay_us = TimeBeforeSyncAllowed_DataStore() * 1000U;

		
    {
        uint16_T uTeethTillActive;

		
				
        uTeethTillActive = 0;
			
        /* The TeethTillActive attribute is only applicable when the uIgnoreDelay_us is zero */
        if (CreateObj.EncoderCreateAttribs_CPU.uIgnoreDelay_us == 0)
        {
            uTeethTillActive += TeethBeforeSyncAllowed_DataStore();
            if (uTeethTillActive > 255)
            {
                uTeethTillActive = 255;
            }
        }
        CreateObj.EncoderCreateAttribs_CPU.uTeethTillActive = uTeethTillActive;
    }
		

	CreateObj.EncoderCreateAttribs_CPU.uValidAttributesMask |= USE_ENCODER_SPEEDZERO;
	CreateObj.EncoderCreateAttribs_CPU.uZeroSpeedTimeout_us = 83333;
	CreateObj.EncoderCreateAttribs_CPU.uNumTeethInAvgRPMSample = 6; 
	CreateObj.CircuitCreate.uValidAttributesMask = MUXVRDGINOVERRIDECT_USE_DEFAULTS | MUXVRDGINOVERRIDECT_USE_CHANNEL;
	
	CreateObj.CircuitCreate.eChan = MUX_CHAN_1;

	MuxVRDGInOverride_Encoder_Create(&CNK,&CreateObj);
	
}
void CNK_Encoder_SecondarySensingOffset_Set(int16_T sensingOffset_x16Deg)
{
    /* Secondary encoders are unsupported */
    UNUSED(sensingOffset_x16Deg);
}
void CNK_Encoder_SensingOffset_Set(int16_T sensingOffset_x16Deg)
{

    MuxVRDGInOverride_Encoder_SensingOfs_Set(&CNK, sensingOffset_x16Deg);
	
}
uint16_T CNK_Encoder_InstantRPM_Get(void)
{
	uint16_T result;

    MuxVRDGInOverride_Encoder_InstantRPM_Get(&CNK, &result);
	
	return result;
}
uint16_T CNK_Encoder_AverageRPM_Get(void)
{
	uint16_T result;

    MuxVRDGInOverride_Encoder_AverageRPM_Get(&CNK, &result);
	
	return result;
}
void CNK_Encoder_PseudoRPM_Set(uint16_T rpm)
{

    MuxVRDGInOverride_Encoder_InstantRPM_Set(&CNK, rpm);
	
}
void CNK_Encoder_EncoderPhase_Change(NativeBool in_bChangePhase)
{
    
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: CNK_Encoder_DegreesInCycle_Get
::
:: Returns the number of degrees in the encoder cycle
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
int16_T CNK_Encoder_DegreesInCycle_Get(void)
{
    return(11520);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: CNK_Encoder_PulseScheduling_IsPossible
::
:: Will return whether MotoCoder thinks that pulse scheduling can be reliably performed based upon the current
:: state of the encoder
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
NativeBool CNK_Encoder_PulseScheduling_IsPossible(void)
{
    return(s_CNK_bIsPulseSchedulingPossible);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: CNK_Encoder_IsEvent1FirstToOccur
::
:: Determines which of two possible timings will be the first to occur
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
NativeBool CNK_Encoder_IsEvent1FirstToOccur(int16_T sBfTDC1Event1, int16_T sBfTDC1Event2)
{
    int32_T sCurrentPosn;
    int32_T sEffectiveAngle1;
    int32_T sTestAngle1;
    int32_T sEffectiveAngle2;
    int32_T sTestAngle2;

    /* Sensing offset compensated BfTDC Angle */
    sCurrentPosn = CNK.pEncoderCPUPinDefn->pMethods->pfnGetCurrentAngle(CNK.pEncoderCPUPinDefn);

    /* The EffectiveAngle equates to the timing minus some retard to account for the fact that this
       calculation takes a finite amount of time to complete */
    sEffectiveAngle1 = sBfTDC1Event1 - 5*16;
    /* The TestAngle is the sEffectiveAngle (BfTDC#1) minus Current Position (BfTDC#1) */
    sTestAngle1 = sEffectiveAngle1 - sCurrentPosn;

    /* The Test needs to place the resultant angle within the cycle window and we want 0 to round to
       the max cycle value */
    while(sTestAngle1 <= 0)
        sTestAngle1 = sTestAngle1 + 720*16;
    while(sTestAngle1 > 720*16)
        sTestAngle1 = sTestAngle1 - 720*16;

    /* Repeat for the 2nd pulse */
    sEffectiveAngle2 = sBfTDC1Event2 - 5*16;
    /* The TestAngle is the sEffectiveAngle (BfTDC#1) minus Current Position (BfTDC#1) */
    sTestAngle2 = sEffectiveAngle2 - sCurrentPosn;

    /* The Test needs to place the resultant angle within the cycle window and we want 0 to round to
       the max cycle value */
    while(sTestAngle2 <= 0)
        sTestAngle2 = sTestAngle2 + 720*16;
    while(sTestAngle2 > 720*16)
        sTestAngle2 = sTestAngle2 - 720*16;

    /* The first event is the larger of the two angles */
    return(sTestAngle1 > sTestAngle2);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: CNK_Encoder_GetNextArrEventToOccur
::
:: Determines what event should be the next to occur. This version accepts an array of After sensing offsets
:: and an array timing. Other versions of this function exist that accept different parameters to allow the
:: construction of the effective angle
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
NativeVar_U CNK_Encoder_GetNextArrEventToOccur(int16_T const* psBfTDCEventArr, int16_T const* pAfTDCOffsetArr, NativeVar_U uNumEvents)
{
    int32_T sCurrentPosn;
    int32_T sEffectiveAngle;
    int32_T sTestAngle;
    NativeVar_U i;
    NativeVar_U uClosest;
    int32_T sLargestValue;

    /* Sensing offset compensated BfTDC Angle */
    sCurrentPosn = CNK.pEncoderCPUPinDefn->pMethods->pfnGetCurrentAngle(CNK.pEncoderCPUPinDefn);
    /* Initialize the sLargestValue */
    sLargestValue = uClosest = 0;
    for (i = 0; i < uNumEvents; i++, pAfTDCOffsetArr++, psBfTDCEventArr++)
    {
        /* The EffectiveAngle equates to the timing minus the AfTDCOffset plus some advance to account
           for the fact that this calculation takes a finite amount of time to complete */
        sEffectiveAngle = psBfTDCEventArr[0] - pAfTDCOffsetArr[0] + 5*16;
        /* The TestAngle is the sEffectiveAngle (BfTDC#1) minus Current Position (BfTDC#1) */
        sTestAngle = sEffectiveAngle - sCurrentPosn;

        /* The Test needs to place the resultant angle within the cycle window and we want 0 to round to
           the max cycle value */
        while(sTestAngle <= 0)
            sTestAngle = sTestAngle + 720*16;
        while(sTestAngle > 720*16)
            sTestAngle = sTestAngle - 720*16;

        /* The closest will have the largest resultant value */
        if (sTestAngle >= sLargestValue)
        {
            uClosest = i;
            sLargestValue = sTestAngle;
        }
    }
    return(uClosest);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: CNK_Encoder_IsAngleBetween
::
:: Returns a boolean that indicates whether an angle falls inbetween two other angles. sAngle1 is treated
:: as the first angle to occur
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
NativeBool CNK_Encoder_IsAngleBetween(int32_T sAngle1, int32_T sAngle2, int32_T sAngleToTestForInBetween)
{
    int32_T const sNumDegreeInCycle = 720*16;

    while (sAngle1 < 0)
        sAngle1 = sAngle1 + sNumDegreeInCycle;
    while (sAngle1 >= sNumDegreeInCycle)
        sAngle1 = sAngle1 - sNumDegreeInCycle;
    while (sAngle2 < 0)
        sAngle2 = sAngle2 + sNumDegreeInCycle;
    while (sAngle2 >= sNumDegreeInCycle)
        sAngle2 = sAngle2 - sNumDegreeInCycle;
    while (sAngleToTestForInBetween < 0)
        sAngleToTestForInBetween = sAngle2 + sNumDegreeInCycle;
    while (sAngleToTestForInBetween >= sNumDegreeInCycle)
        sAngleToTestForInBetween = sAngleToTestForInBetween - sNumDegreeInCycle;
/*  
   Example 1: A1 = 60, A2 = 20, TA = 10 (Is Not Inbetween), A1 > A2, A1 > TA, but A2 > TA so FALSE
   Example 2: A1 = 60, A2 = 20, TA = 40 (Is Inbetween), A1 > A2, A1 > TA and A2 < TA so TRUE
   Example 3: A1 = 60, A2 = 20, TA = 100 (Is Not Inbetween), A1 > A2, A1 < TA so FALSE
   Example 4: A1 = 60, A2 = 710, TA = 715 (Is Inbetween), A1 < A2, A1 < TA, but A2 < TA so TRUE
   Example 5: A1 = 60, A2 = 710, TA = 700 (Is Not Inbetween), A1 < A2, A1 < TA, and A2 > TA so FALSE
   Example 6: A1 = 60, A2 = 710, TA = 20 (Is Inbetween), A1 < A2, A1 > TA so TRUE
   Example 7: A1 = 60, A2 = 60, TA = 20 (Is Not Inbetween), A1 == A2, A1 > TA, but A2 > TA so FALSE
   Example 8: A1 = 710, A2 = 60, TA = 80 (Is Inbetween), A1 > A2, A1 > TA, A2 < TA so TRUE
*/
    if (sAngle1 >= sAngle2)
    {   /* Normal case where there is no wrap */
        if ((sAngle1 > sAngleToTestForInBetween) && (sAngle2 < sAngleToTestForInBetween))
        {
            return(TRUE);
        }
        else
        {
            return(FALSE);
        }
    }
    else
    {   /* There is a wrap about the 0 point */
        if (sAngle1 > sAngleToTestForInBetween)
        {
            return(TRUE);
        }
        else if (sAngle2 < sAngleToTestForInBetween)
        {
            return(TRUE);
        }
        else
        {
            return(FALSE);
        }
    }
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: CNK_Encoder_GetNextEventToOccur
::
:: Determines what event should be the next to occur. This version accepts an array of After sensing offsets
:: and a fixed timing. Other versions of this function exist that accept different parameters to allow the
:: construction of the effective angle
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
NativeVar_U CNK_Encoder_GetNextEventToOccur(int16_T sBfTDCEvent, int16_T const* pAfTDCOffsetArr, NativeVar_U uNumEvents)
{
    int32_T sCurrentPosn;
    int32_T sEffectiveAngle;
    int32_T sTestAngle;
    NativeVar_U i;
    NativeVar_U uClosest;
    int32_T sLargestValue;

    /* Sensing offset compensated BfTDC Angle */
    sCurrentPosn = CNK.pEncoderCPUPinDefn->pMethods->pfnGetCurrentAngle(CNK.pEncoderCPUPinDefn);
    /* Initialize the sLargestValue */
    sLargestValue = uClosest = 0;
    for (i = 0; i < uNumEvents; i++, pAfTDCOffsetArr++)
    {
        /* The EffectiveAngle equates to the timing minus the AfTDCOffset plus some advance to account
           for the fact that this calculation takes a finite amount of time to complete */
        sEffectiveAngle = sBfTDCEvent - pAfTDCOffsetArr[0] + 5*16;
        /* The TestAngle is the sEffectiveAngle (BfTDC#1) minus Current Position (BfTDC#1) */
        sTestAngle = sEffectiveAngle - sCurrentPosn;

        /* The Test needs to place the resultant angle within the cycle window and we want 0 to round to
           the max cycle value */
        while(sTestAngle <= 0)
            sTestAngle = sTestAngle + 720*16;
        while(sTestAngle > 720*16)
            sTestAngle = sTestAngle - 720*16;

        /* The closest will have the largest resultant value */
        if (sTestAngle >= sLargestValue)
        {
            uClosest = i;
            sLargestValue = sTestAngle;
        }
    }
    return(uClosest);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: CNK_Encoder_NumDegreesPerCycle_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
int16_T CNK_Encoder_NumDegreesPerCycle_Get(void)
{
    return(CNK_Encoder_DegreesInCycle_Get());
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: CNK_Encoder_NearnessProtectedStopAngle_Get
::
:: A stop angle must not be placed too close to the start angle of the next pulse (or to its own start when
:: there is only a single pulse). How close is defined by the implementation.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
int16_T CNK_Encoder_NearnessProtectedStopAngle_Get(int16_T startAnglePulse, int16_T stopAnglePreviousPulse, int16_T sMinDisplacementForPulseScheduling)
{
    /* There is no point executing a Nearness check if the supplied MinDisplacementForPulseScheduling is zero */
    if (sMinDisplacementForPulseScheduling == 0)
    {
        return(stopAnglePreviousPulse);
    }
    else
    {
        int16_T const sNumDegreeInCycle = 720*16;
        int16_T sResultAngle;

        /* The angles all need to be in the same cycle before they can be compared */
        while (startAnglePulse < 0)
            startAnglePulse = startAnglePulse + sNumDegreeInCycle;
        while (startAnglePulse >= sNumDegreeInCycle)
            startAnglePulse = startAnglePulse - sNumDegreeInCycle;

        while (stopAnglePreviousPulse < 0)
            stopAnglePreviousPulse = stopAnglePreviousPulse + sNumDegreeInCycle;
        while (stopAnglePreviousPulse >= sNumDegreeInCycle)
            stopAnglePreviousPulse = stopAnglePreviousPulse - sNumDegreeInCycle;

        /* Assume that the angle to be returned will be the supplied stopAngle */
        sResultAngle = stopAnglePreviousPulse;
        if (startAnglePulse <= stopAnglePreviousPulse)
        {    /* Start is smaller than the previous Stop timing and this is BEFORE TDC timings.
                Interpret this to mean that the start timing is occurring after the stop timings (600degBfTDC occurs after 710degBfTDC).
                Therefore the start timing, when added to the minimum allowed displacement, should still be smaller than the stop timing
                If the timing is not smaller than the stop timing is too close to the start and needs to be adjusted */
            int16_T sAngle;

            sAngle = startAnglePulse + sMinDisplacementForPulseScheduling;
            if (sAngle > stopAnglePreviousPulse)
            {
                /* The modified angle is now larger than the stop angle - so the stop angle is too close to the start */
                sResultAngle = sAngle;
            }
        }
        else
        {   /* Start Angle is larger than the previous Stop Angle and this is BEFORE TDC timings
               Interpret this as the start is just after TDC whilst the stop is just before TDC (710degBfTDC occurs after 10degBfTDC) */
            
            if ((startAnglePulse - stopAnglePreviousPulse) > (sNumDegreeInCycle - sMinDisplacementForPulseScheduling))
            {
                sResultAngle = (startAnglePulse + sMinDisplacementForPulseScheduling);
            }
        }
        return(sResultAngle);
    }
}
int16_T CNK_Encoder_Angle_Get(void)
{
	return CNK.pEncoderCPUPinDefn->pMethods->pfnGetCurrentAngle(CNK.pEncoderCPUPinDefn);
}
static void CNK_Encoder_OnError_Callback(S_MuxVRDGInOverride_Defn_Encoder const* const device, E_PrimaryEncoderError eError)
{
    s_eCNKEncoderError = eError;

	{
    extern void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void));
	extern void EncoderDiagnosticsCallback(void);
	extern const S_MessageBoxDefn g_ApplicationInterruptTask_MailBox;
	MotoCoder_TaskEvent_Post(&g_ApplicationInterruptTask_MailBox, EncoderDiagnosticsCallback);
}
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: CNK_Encoder_OnStateChanged_Callback
::
:: Executes each time the state of the encoder changes
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
static void CNK_Encoder_OnStateChanged_Callback(S_MuxVRDGInOverride_Defn_Encoder const* const device, E_PrimaryEncoderStatus eStatus)
{
    s_eCNKEncoderState = eStatus;
    
    {   /* Determine whether pulse scheduling is possible given the current Encoder state */
        if (eStatus >= ENCODER_STATUS_PARTIAL_SYNC)
        {   /* MotoCoder considers pulse scheduling viable once we have detected some form of synchronization */
            s_CNK_bIsPulseSchedulingPossible = TRUE;
        }
        else
        {
            s_CNK_bIsPulseSchedulingPossible = FALSE;
        }
    }

	

	

    {   /* Call any triggers */
    
     {
    extern void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void));
	extern void EncoderStateCallback(void);
	extern const S_MessageBoxDefn g_ApplicationInterruptTask_MailBox;
	MotoCoder_TaskEvent_Post(&g_ApplicationInterruptTask_MailBox, EncoderStateCallback);
}    
    
    }
}
uint8_T CNK_Encoder_EncoderState_Get(void)
{
    return (uint8_T)s_eCNKEncoderState;
}
uint8_T CNK_Encoder_EncoderError_Get(void)
{
    return (uint8_T)s_eCNKEncoderError;
}

INSTANTIATE_DGIn_DigitalIn(ESTOPPin,
    CPUCore_0, CPU, GPIO_180_AE15, GPIO,
    INPUT_IS_INVERTING);
void ESTOPPin_DigitalInput_Create(void)
{
    S_DGIn_Create_DigitalIn CreateObj;
    
    CreateObj.DGIn_Create.uValidAttributesMask = DGIN_USE_DEFAULTS;
    DGIn_DigitalInput_Create(&ESTOPPin, &CreateObj);
}
boolean_T ESTOPPin_DigitalInput_Get(void)
{
    S_DigitalInputRuntimedata RuntimeObj;
    DGIn_DigitalInput_GetAttributes(&ESTOPPin, &RuntimeObj);
    return (RuntimeObj.eState == RES_PINSTATE_HIGH);
}

INSTANTIATE_SPI_MODULE_DEFN(
		SPI_C,
		DSPI_C,
        1);
void SPI_C_Create(void)
{
	INSTANTIATE_SPI_MODULE_ATTRIBUTES(SPI_C_,
		DSPI_C,
		1,
		0,
		USE_SPI_CS0 | USE_SPI_CS1 | USE_SPI_CS2);

	SPI_C.pMethods->pfnCreate(&SPI_C, &SPI_C_Attrib);
}

INSTANTIATE_MC33800_Hardware(
		S_SHRC_3,
		SPI_C,
		USE_SPI_CS0,
        NULL,
		0,
		20000,
		1000000,
        1);
void S_SHRC_3_Create(void)
{
	S_MC33800CreateAttributes CreateObj;
	CreateObj.uValidAttributesMask = USE_MC33800_DEFAULTS;
	MC33800_Hardware_Create(&S_SHRC_3, &CreateObj);
}

INSTANTIATE_MC33800Output_DiscreteOut(DOut10176p0004,
	MC33800_CCD1,
	CCD,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_3);



#include <Pragma_Section_Start_SDA.h>
E_ResourceState DOut10176p0004_State;
#include <Pragma_Section_End_SDA.h>
void DOut10176p0004_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;

    /* Cache state because UseUpdateOnlyOnChange was true */
    DOut10176p0004_State = CreateObj.DiscreteOutCreateAttribs.eInitialState;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_DEFAULTS;
	
	MC33800_DiscreteOut_Create(&DOut10176p0004, &CreateObj);
}
void DOut10176p0004_DiscreteOutput_Set(boolean_T value)
{
    E_ResourceState eState;

    eState = value ? RES_ON : RES_OFF;

    Interrupt_DisableApp();
    if ((DOut10176p0004_State & 0x80) == 0)
    {   /* Object is not currently undergoing modification */
        if (DOut10176p0004_State != eState)
        {
            DOut10176p0004_State = eState | 0x80;
            Interrupt_EnableApp();
            MC33800_DiscreteOut_State_Set(&DOut10176p0004, eState);
            Interrupt_DisableApp();
            DOut10176p0004_State = DOut10176p0004_State & 0x7F;
        }
    }
    else
    {
        /* Another thread is already modifying this object so ignore this request */
    }
    Interrupt_EnableApp();

}
void DOut10176p0004_DiscreteOutput_Stop(void)
{

    /* IO Stop is called on shutdown. It should override the state being set by another thread.
       The expectation is that normal operation shall not resume without effectively restarting the code */
    DOut10176p0004_State = RES_OFF;

	MC33800_DiscreteOut_State_Set(&DOut10176p0004, RES_OFF);
}

INSTANTIATE_MC33800Output_DiscreteOut(MC33800_LSO2,
	MC33800_OUT3,
	OSS,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_3);
void MC33800_LSO2_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_INPUT | USE_MC33800OUTPUT_PARALLEL_OUTPUT;
	
	MC33800_DiscreteOut_Create(&MC33800_LSO2, &CreateObj);
}

INSTANTIATE_MC33800Output_DiscreteOut(MC33800_MPRD,
	MC33800_OUT7,
	OSS,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_3);
void MC33800_MPRD_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_INPUT | USE_MC33800OUTPUT_PARALLEL_OUTPUT;
	
	MC33800_DiscreteOut_Create(&MC33800_MPRD, &CreateObj);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: RS485_SerialLink_Notify_OnIdle
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void RS485_SerialLink_Notify_OnIdle(void)
{

    {extern void KeySuiteSupport_RS485_OnIdleNotify(void);
        KeySuiteSupport_RS485_OnIdleNotify();
    }
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: RS485_SerialLink_Notify_OnError
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void RS485_SerialLink_Notify_OnError(E_SCIError in_eSCIError)
{

    {extern void KeySuiteSupport_RS485_OnErrorNotify(void);
        KeySuiteSupport_RS485_OnErrorNotify();
    }
}

INSTANTIATE_SCI_RX_OBJ(RS485_RxObj, /* Name */
                       8); /* uQueueSize */

INSTANTIATE_SCI_TX_OBJ(RS485_TxObj, /* Name */
                       8,  /* uQueueSize            */
                       1,  /* uMaxNumPendingEntries */
                       8); /* uNumDataBits */

INSTANTIATE_SCI_MODULE_DEFN(RS485, /* Name */
                            RS485_MODULE_NUMBER_SCI_A, /* uModule */
                            &RS485_RxObj, /* in_pRxObj */
                            &RS485_TxObj, /* in_pTxObj */
                            RS485_SerialLink_Notify_OnError, /* in_pfErrorNotify */
                            RS485_SerialLink_Notify_OnIdle, /* in_pfIdleNotify */
                            NULL, /* in_pfTxCompleteNotify */
                            NULL, /* in_pfCharacterReceiptNotify */
                            NULL, /* in_pfTxQueueEmptiedNotify */
                            TRUE, /* in_bEnableTX */
                            TRUE, /* in_bEnableRX */
                            TRUE); /* in_bIgnoreHardwareEcho */
void RS485_SerialLink_Create(void)
{

    #define RS485_DESIRED_SCI_PARITY SCI_PARITY_DISABLED
    INSTANTIATE_SCI_CREATE_MODULE_ATTRIB(Attrib, /* Name */
                                         SCI_USE_DEFAULTS, /* uAttributesMask */
                                         9600, /* uBaud_bps */
                                         8, /* in_uNumDataBits */
                                         RS485_DESIRED_SCI_PARITY, /* in_eParity */
                                         7,  /* in_eSCIRxCompleteISRPriority */
                                         7); /* in_SCICombinedISRPriority    */
    
    RS485.pMethods->pfnCreate(&RS485, &Attrib);
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: RS485_SerialLink_MaxAllowedBaud_Get
::
:: Recovers the maximum baud rate that this device can handle reliably.
::
:: This value is based upon the capabilities of the serial link.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
uint32_T RS485_SerialLink_MaxAllowedBaud_Get(void)
{
    return(115200);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: RS485_SerialLink_BaudRate_Change
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
NativeError_S RS485_SerialLink_BaudRate_Change(uint32_T u32BaudRate)
{
    return (RS485.pMethods->pfnSetBaudRate(&RS485, u32BaudRate));
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: RS485_SerialLink_BaudRate_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
uint32_T RS485_SerialLink_BaudRate_Get(void)
{
    return(RS485.pMethods->pfnGetBaudRate(&RS485));
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: RS485_SerialLink_ReadSync
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
NativeError_S RS485_SerialLink_ReadSync(void* in_pBuffer, NativeVar_U in_uCharactersToRead, int32_T in_sTimeOutInMillisecs)
{
    INSTANTIATE_SCI_READ_SYNC_ATTRIB(Attrib,                       /* Name                       */
                                     in_pBuffer,                   /* in_pBuffer                 */
                                     in_uCharactersToRead,         /* in_uNumPacketsToRead       */
                                     in_sTimeOutInMillisecs,       /* in_sReadTimeOutInMicrosecs */
                                     SCI_USE_DEFAULTS);            /* in_uMask                   */

    return (RS485.pMethods->pfnReadSync(&RS485, &Attrib));
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: RS485_SerialLink_Transmit_WithCallbackOnComplete
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
NativeError_S RS485_SerialLink_Transmit_WithCallbackOnComplete(void* in_pBuffer,
                          NativeVar_U in_uNumCharacters,
                          void (*in_pfnCback)(NativePtrSizedInt_U),
                          NativePtrSizedInt_U uUserData)
{
    INSTANTIATE_SCI_TRANSMIT_ATTRIB(Message,             /* Name                    */
                                    SCI_USE_DEFAULTS,    /* in_uFlags               */
                                    in_pBuffer,          /* in_pDataToSend          */
                                    in_uNumCharacters,   /* in_uNumCharactersToSend */
                                    in_pfnCback,         /* in_pfnTxCBack           */
                                    uUserData);          /* in_uUserData            */

    return (RS485.pMethods->pfnTransmit(&RS485, &Message));
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: RS485_SerialLink_Transmit
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
NativeError_S RS485_SerialLink_Transmit(void* in_pBuffer, NativeVar_U in_uNumCharacters)
{
    return(RS485_SerialLink_Transmit_WithCallbackOnComplete(in_pBuffer, in_uNumCharacters, NULL, 0));
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: RS485_SerialLink_TxQueue_Purge
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
NativeError_S RS485_SerialLink_TxQueue_Purge(void)
{
    return (RS485.pMethods->pfnPurgeTxQueue(&RS485));
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: RS485_SerialLink_RxQueue_Purge
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
NativeError_S RS485_SerialLink_RxQueue_Purge(void)
{
    return (RS485.pMethods->pfnPurgeRxQueue(&RS485));
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: RS485_SerialLink_RxQueueDepth_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
NativeVar_U RS485_SerialLink_RxQueueDepth_Get(void)
{
    return (RS485.pMethods->pfnGetRxQueueDepth(&RS485));
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: RS485_SerialLink_TxQueueDepth_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
NativeVar_U RS485_SerialLink_TxQueueDepth_Get(void)
{
    return (RS485.pMethods->pfnGetTxQueueDepth(&RS485));
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: RS485_SerialLink_ModuleId_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
NativeVar_U RS485_SerialLink_ModuleId_Get(void)
{
    return(RS485_MODULE_NUMBER_SCI_A);
}

static void eQADC_A_B_eQADCModule_Create(void)
{
    S_eQADCCreate ADCCreateObj;
    NativeError_S CreateResult;

    
    ADCCreateObj.uValidAttributesMask = USE_ANALOG_DEFAULTS | USE_ANALOG_TIME_STAMP;
        
    ADCCreateObj.eConversionTimePreScalar = ADC_CR_CLK_PS_12;
    ADCCreateObj.TimeStampPreScalar = ADC_TB_CLK_PS_1;
    ADCCreateObj.eBuffer = eQADC_BN_ADC1;
    CreateResult = eQADC_Create(&ADCCreateObj);
    
    if (SUCCESS(CreateResult))
    {
        
        ADCCreateObj.uValidAttributesMask = USE_ANALOG_DEFAULTS | USE_ANALOG_TIME_STAMP;
            
        ADCCreateObj.eBuffer = eQADC_BN_ADC0;
        eQADC_Create(&ADCCreateObj);
    }
}

uint32_T const g_eQADCCommandQueueBuffer5[] =
{ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN36_B3, RFIFO_5, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_AN2 */
ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN11_A4, RFIFO_5, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_AN3 */
ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN19_B5, RFIFO_5, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_AN4 */
ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN24_D11, RFIFO_5, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_AN5 */
ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN28_A12, RFIFO_5, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_AN6 */
ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN16_A6, RFIFO_5, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_AN15 */
ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN31_B12, RFIFO_5, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_AN7 */
ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN15_A15, RFIFO_5, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_AN8 */
ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN29_D12, RFIFO_5, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_AN9 */
ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN35_A13, RFIFO_5, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_AN10 */
ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN32_B13, RFIFO_5, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_AN11 */
ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN39_B4, RFIFO_5, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_AN14 */
ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN5_A8, RFIFO_5, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_ECUP */
ADD_ANALOG_RESOURCE_TO_END_OF_QUEUE(ADC_AN3_C8, RFIFO_5, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* H1_Imon */

};



uint16_T g_eQADCResultQueueBuffer5[14];


INSTANTIATEMETHOD_QADC_QUEUE(ContinuousScan_eQADCQueue_QueueMethod,
        /*        CPUType */ CPU,
        /*     Queue Type */ SW_TRIG_CONT_SCAN,
        /*   Result Style */ STANDARD_RESULT);

INSTANTIATE_QADC_QUEUE(ContinuousScan_eQADCQueue,
  /*    Processor Name */ CPUCore_0,
  /*    Main Processor */ CPU,
  /* Queue Method Name */ ContinuousScan_eQADCQueue_QueueMethod,
  /*        Queue Type */ SW_TRIG_CONT_SCAN,
  /*       Queue Index */ eQADC_QUEUE_5,
  /*  Ptr to Command Q */ g_eQADCCommandQueueBuffer5,
  /*   Ptr to Result Q */ g_eQADCResultQueueBuffer5,
  /*   Command Q Depth */ 14,
  /*    Result Q Depth */ 14,
  /*      ISR Priority */ INTCPRIORITY_NONE,
  /*  Snooper Func Ptr */ NULL,
  /*       This Device */ ContinuousScan_eQADCQueue,
  /* Depth of the Trigger Request Queue */
0,
 /* Desired Queue Conversion Resolution */
10 

);
void ContinuousScan_eQADCQueue_Create(void)
{
    S_AnalogQueueAttributes Attributes;

    /*============================================================================*/
    /* The buffer should have been created by an earlier dependancy               */
    /*============================================================================*/

    /*========================================================================*/
    /* Now we can create the Queue.                                           */
    /*========================================================================*/
    /* eQADCQueue ContinuousScan_eQADCQueue */
    
    Attributes.uValidAttributesMask = USE_ANALOG_DEFAULTS;
    
    {

        ContinuousScan_eQADCQueue.pMethods->pfnCreate(&ContinuousScan_eQADCQueue, &Attributes);
    }
}
uint16_T  AN2_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 10; /* Result representation in number of bits */

	ContinuousScan_eQADCQueue.pMethods->pfnGetScaledResult(&ContinuousScan_eQADCQueue, /* Queue Oject */
	0,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  AN3_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 10; /* Result representation in number of bits */

	ContinuousScan_eQADCQueue.pMethods->pfnGetScaledResult(&ContinuousScan_eQADCQueue, /* Queue Oject */
	1,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  AN4_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 10; /* Result representation in number of bits */

	ContinuousScan_eQADCQueue.pMethods->pfnGetScaledResult(&ContinuousScan_eQADCQueue, /* Queue Oject */
	2,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  AN5_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 10; /* Result representation in number of bits */

	ContinuousScan_eQADCQueue.pMethods->pfnGetScaledResult(&ContinuousScan_eQADCQueue, /* Queue Oject */
	3,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  AN6_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 10; /* Result representation in number of bits */

	ContinuousScan_eQADCQueue.pMethods->pfnGetScaledResult(&ContinuousScan_eQADCQueue, /* Queue Oject */
	4,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  AN15_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 10; /* Result representation in number of bits */

	ContinuousScan_eQADCQueue.pMethods->pfnGetScaledResult(&ContinuousScan_eQADCQueue, /* Queue Oject */
	5,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  AN7_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 10; /* Result representation in number of bits */

	ContinuousScan_eQADCQueue.pMethods->pfnGetScaledResult(&ContinuousScan_eQADCQueue, /* Queue Oject */
	6,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  AN8_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 10; /* Result representation in number of bits */

	ContinuousScan_eQADCQueue.pMethods->pfnGetScaledResult(&ContinuousScan_eQADCQueue, /* Queue Oject */
	7,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  AN9_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 10; /* Result representation in number of bits */

	ContinuousScan_eQADCQueue.pMethods->pfnGetScaledResult(&ContinuousScan_eQADCQueue, /* Queue Oject */
	8,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  AN10_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 10; /* Result representation in number of bits */

	ContinuousScan_eQADCQueue.pMethods->pfnGetScaledResult(&ContinuousScan_eQADCQueue, /* Queue Oject */
	9,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  AN11_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 10; /* Result representation in number of bits */

	ContinuousScan_eQADCQueue.pMethods->pfnGetScaledResult(&ContinuousScan_eQADCQueue, /* Queue Oject */
	10,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  AN14_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 10; /* Result representation in number of bits */

	ContinuousScan_eQADCQueue.pMethods->pfnGetScaledResult(&ContinuousScan_eQADCQueue, /* Queue Oject */
	11,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  ECUP_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 10; /* Result representation in number of bits */

	ContinuousScan_eQADCQueue.pMethods->pfnGetScaledResult(&ContinuousScan_eQADCQueue, /* Queue Oject */
	12,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  H1_Imon_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 10; /* Result representation in number of bits */

	ContinuousScan_eQADCQueue.pMethods->pfnGetScaledResult(&ContinuousScan_eQADCQueue, /* Queue Oject */
	13,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}

INSTANTIATE_VISTA_ADC(AnalogInput_VISTA_1_AD4, ADC_VISTA_AD4I_GPI4);


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: MAPSensorPin_Create
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void MAPSensorPin_Create(void)
{
    S_VISTA_ADC_CreateAttrib CreateObj;
    CreateObj.uFlags = VISTA_ADC_USE_ROUND_ROBIN;
    VISTA_ADC_Create(&VISTA_1, &AnalogInput_VISTA_1_AD4, &CreateObj);
}



/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: MAPSensorPin_AnalogInput_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
uint16_T  MAPSensorPin_AnalogInput_Get(void)
{
    S_VISTA_ADC_ConversionAttrib DynamicObj;
    uint16_T Result;
    int16_T  Reading;
    
    DynamicObj.uFlags = VISTA_ADC_USE_ROUND_ROBIN;
    VISTA_ADC_GetConversion(&VISTA_1, &AnalogInput_VISTA_1_AD4, &DynamicObj);
    Reading = DynamicObj.s16ADCValue;


    if (Reading > 0)
    {
        /* Effectively an 11-bit native resolution */
        Result = (uint16_T)(Reading & 0x07FF) >> 1;
        return (uint16_T)Result;
    }
    else
    {
        return (uint16_T)0;
    }
    
}

INSTANTIATE_VISTA_ADC(AnalogInput_VISTA_1_AD0, ADC_VISTA_AD0I_GPI0);


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: DRVP_Create
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void DRVP_Create(void)
{
    S_VISTA_ADC_CreateAttrib CreateObj;
    CreateObj.uFlags = VISTA_ADC_USE_ROUND_ROBIN;
    VISTA_ADC_Create(&VISTA_1, &AnalogInput_VISTA_1_AD0, &CreateObj);
}



/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: DRVP_AnalogInput_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
uint16_T  DRVP_AnalogInput_Get(void)
{
    S_VISTA_ADC_ConversionAttrib DynamicObj;
    uint16_T Result;
    int16_T  Reading;
    
    DynamicObj.uFlags = VISTA_ADC_USE_ROUND_ROBIN;
    VISTA_ADC_GetConversion(&VISTA_1, &AnalogInput_VISTA_1_AD0, &DynamicObj);
    Reading = DynamicObj.s16ADCValue;


    if (Reading > 0)
    {
        /* Effectively an 11-bit native resolution */
        Result = (uint16_T)(Reading & 0x07FF) >> 1;
        return (uint16_T)Result;
    }
    else
    {
        return (uint16_T)0;
    }
    
}

INSTANTIATE_VISTA_ADC(AnalogInput_VISTA_1_AD1, ADC_VISTA_AD1I_GPI1);


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: XDRP_Create
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void XDRP_Create(void)
{
    S_VISTA_ADC_CreateAttrib CreateObj;
    CreateObj.uFlags = VISTA_ADC_USE_ROUND_ROBIN;
    VISTA_ADC_Create(&VISTA_1, &AnalogInput_VISTA_1_AD1, &CreateObj);
}



/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: XDRP_AnalogInput_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
uint16_T  XDRP_AnalogInput_Get(void)
{
    S_VISTA_ADC_ConversionAttrib DynamicObj;
    uint16_T Result;
    int16_T  Reading;
    
    DynamicObj.uFlags = VISTA_ADC_USE_ROUND_ROBIN;
    VISTA_ADC_GetConversion(&VISTA_1, &AnalogInput_VISTA_1_AD1, &DynamicObj);
    Reading = DynamicObj.s16ADCValue;


    if (Reading > 0)
    {
        /* Effectively an 11-bit native resolution */
        Result = (uint16_T)(Reading & 0x07FF) >> 1;
        return (uint16_T)Result;
    }
    else
    {
        return (uint16_T)0;
    }
    
}

INSTANTIATE_VISTA_ADC(AnalogInput_VISTA_1_AD6, ADC_VISTA_AD6I_GPI6);


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: AN12_Create
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void AN12_Create(void)
{
    S_VISTA_ADC_CreateAttrib CreateObj;
    CreateObj.uFlags = VISTA_ADC_USE_ROUND_ROBIN;
    VISTA_ADC_Create(&VISTA_1, &AnalogInput_VISTA_1_AD6, &CreateObj);
}



/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: AN12_AnalogInput_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
uint16_T  AN12_AnalogInput_Get(void)
{
    S_VISTA_ADC_ConversionAttrib DynamicObj;
    uint16_T Result;
    int16_T  Reading;
    
    DynamicObj.uFlags = VISTA_ADC_USE_ROUND_ROBIN;
    VISTA_ADC_GetConversion(&VISTA_1, &AnalogInput_VISTA_1_AD6, &DynamicObj);
    Reading = DynamicObj.s16ADCValue;


    if (Reading > 0)
    {
        /* Effectively an 11-bit native resolution */
        Result = (uint16_T)(Reading & 0x07FF) >> 1;
        return (uint16_T)Result;
    }
    else
    {
        return (uint16_T)0;
    }
    
}

INSTANTIATE_VISTA_ADC(AnalogInput_VISTA_1_AD7, ADC_VISTA_AD7I_GPI7);


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: AN13_Create
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void AN13_Create(void)
{
    S_VISTA_ADC_CreateAttrib CreateObj;
    CreateObj.uFlags = VISTA_ADC_USE_ROUND_ROBIN;
    VISTA_ADC_Create(&VISTA_1, &AnalogInput_VISTA_1_AD7, &CreateObj);
}



/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: AN13_AnalogInput_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
uint16_T  AN13_AnalogInput_Get(void)
{
    S_VISTA_ADC_ConversionAttrib DynamicObj;
    uint16_T Result;
    int16_T  Reading;
    
    DynamicObj.uFlags = VISTA_ADC_USE_ROUND_ROBIN;
    VISTA_ADC_GetConversion(&VISTA_1, &AnalogInput_VISTA_1_AD7, &DynamicObj);
    Reading = DynamicObj.s16ADCValue;


    if (Reading > 0)
    {
        /* Effectively an 11-bit native resolution */
        Result = (uint16_T)(Reading & 0x07FF) >> 1;
        return (uint16_T)Result;
    }
    else
    {
        return (uint16_T)0;
    }
    
}

#include <Pragma_Section_Start_CoreIndependent_data.h>

INSTANTIATE_DGIn_FreqIn(SPD1,
    CPUCore_0, CPU, ETPU_A14_J3, ETPU,
    NULL,
    INPUT_IS_NON_INVERTING,
    1);

#include <Pragma_Section_End_data.h>


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: SPD1_FrequencyInput_Create
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void SPD1_FrequencyInput_Create(void)
{
    S_DGIn_Create_FreqIn CreateObj;
        
    CreateObj.DGIn_Create.uValidAttributesMask = DGIN_USE_DEFAULTS;
    CreateObj.FreqInCreateAttribs_CPU.uValidAttributesMask = USE_FREQIN_DEFAULTS;
    
    CreateObj.FreqInCreateAttribs_CPU.uValidAttributesMask |= USE_FREQIN_PULSEWIDTH;
    
    CreateObj.FreqInCreateAttribs_CPU.eSyncEdge = RES_EDGE_DETECT_FALL;
    CreateObj.FreqInCreateAttribs_CPU.uMaxExpectedPeriod_us = 100000;

    
    

    DGIn_FreqIn_Create(&SPD1,&CreateObj);
}

 

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: SPD1_FrequencyInput_TriggerOnPulseCnt_Set
::
:: This is potentially a multi-threaded function call.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void SPD1_FrequencyInput_TriggerOnPulseCnt_Set(uint8_T uDesiredPulseCnt)
{


    UNUSED(uDesiredPulseCnt);
	
}
    
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: SPD1_FrequencyInput_AverageFrequency_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
uint32_T SPD1_FrequencyInput_AverageFrequency_Get(void)
{
    S_FreqInAverageFreq RuntimeObj;
    DGIn_FreqIn_GetAverage(&SPD1, &RuntimeObj);
    return RuntimeObj.uAvgFrequency;
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: SPD1_FrequencyInput_InstantFrequency_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
uint32_T SPD1_FrequencyInput_InstantFrequency_Get(void)
{
    S_FreqInInstantFreq RuntimeObj;
    DGIn_FreqIn_GetInstant(&SPD1, &RuntimeObj);
    return RuntimeObj.uInstantFrequency;
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: SPD1_FrequencyInput_InstantFrequencyWithDutyCycle_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void SPD1_FrequencyInput_InstantFrequencyWithDutyCycle_Get(uint32_T* const out_pu32Frequency, int16_T* const out_ps16Duty)
{
    S_FreqInInstantFreq RuntimeObj;
    DGIn_FreqIn_GetInstant(&SPD1, &RuntimeObj);

    if (out_pu32Frequency != NULL)
    {
        *out_pu32Frequency = RuntimeObj.uInstantFrequency;
    }

    if (out_ps16Duty != NULL)
    {
        *out_ps16Duty = RuntimeObj.sDutyCycle;
    }
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: SPD1_FrequencyInput_Period_Raw_Get32Bit
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void SPD1_FrequencyInput_Period_Raw_Get32Bit(uint32_T* const out_pu32PeriodCnts, uint32_T* const out_pu32DutyCycleCnts)
{
    DGIn_FreqIn_Period_Raw_Get32Bit(&SPD1, out_pu32PeriodCnts, out_pu32DutyCycleCnts);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: SPD1_FrequencyInput_Period_Raw_Get16Bit
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void SPD1_FrequencyInput_Period_Raw_Get16Bit(uint16_T* const out_pu16PeriodCnts, uint16_T* const out_pu16DutyCycleCnts)
{
    DGIn_FreqIn_Period_Raw_Get16Bit(&SPD1, out_pu16PeriodCnts, out_pu16DutyCycleCnts);
}

#include <Pragma_Section_Start_CoreIndependent_data.h>

INSTANTIATE_DGIn_FreqIn(SPD2,
    CPUCore_0, CPU, ETPU_A1_M4, ETPU,
    NULL,
    INPUT_IS_NON_INVERTING,
    1);

#include <Pragma_Section_End_data.h>


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: SPD2_FrequencyInput_Create
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void SPD2_FrequencyInput_Create(void)
{
    S_DGIn_Create_FreqIn CreateObj;
        
    CreateObj.DGIn_Create.uValidAttributesMask = DGIN_USE_DEFAULTS;
    CreateObj.FreqInCreateAttribs_CPU.uValidAttributesMask = USE_FREQIN_DEFAULTS;
    
    CreateObj.FreqInCreateAttribs_CPU.uValidAttributesMask |= USE_FREQIN_PULSEWIDTH;
    
    CreateObj.FreqInCreateAttribs_CPU.eSyncEdge = RES_EDGE_DETECT_FALL;
    CreateObj.FreqInCreateAttribs_CPU.uMaxExpectedPeriod_us = 100000;

    
    

    DGIn_FreqIn_Create(&SPD2,&CreateObj);
}

 

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: SPD2_FrequencyInput_TriggerOnPulseCnt_Set
::
:: This is potentially a multi-threaded function call.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void SPD2_FrequencyInput_TriggerOnPulseCnt_Set(uint8_T uDesiredPulseCnt)
{


    UNUSED(uDesiredPulseCnt);
	
}
    
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: SPD2_FrequencyInput_AverageFrequency_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
uint32_T SPD2_FrequencyInput_AverageFrequency_Get(void)
{
    S_FreqInAverageFreq RuntimeObj;
    DGIn_FreqIn_GetAverage(&SPD2, &RuntimeObj);
    return RuntimeObj.uAvgFrequency;
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: SPD2_FrequencyInput_InstantFrequency_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
uint32_T SPD2_FrequencyInput_InstantFrequency_Get(void)
{
    S_FreqInInstantFreq RuntimeObj;
    DGIn_FreqIn_GetInstant(&SPD2, &RuntimeObj);
    return RuntimeObj.uInstantFrequency;
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: SPD2_FrequencyInput_InstantFrequencyWithDutyCycle_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void SPD2_FrequencyInput_InstantFrequencyWithDutyCycle_Get(uint32_T* const out_pu32Frequency, int16_T* const out_ps16Duty)
{
    S_FreqInInstantFreq RuntimeObj;
    DGIn_FreqIn_GetInstant(&SPD2, &RuntimeObj);

    if (out_pu32Frequency != NULL)
    {
        *out_pu32Frequency = RuntimeObj.uInstantFrequency;
    }

    if (out_ps16Duty != NULL)
    {
        *out_ps16Duty = RuntimeObj.sDutyCycle;
    }
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: SPD2_FrequencyInput_Period_Raw_Get32Bit
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void SPD2_FrequencyInput_Period_Raw_Get32Bit(uint32_T* const out_pu32PeriodCnts, uint32_T* const out_pu32DutyCycleCnts)
{
    DGIn_FreqIn_Period_Raw_Get32Bit(&SPD2, out_pu32PeriodCnts, out_pu32DutyCycleCnts);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: SPD2_FrequencyInput_Period_Raw_Get16Bit
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void SPD2_FrequencyInput_Period_Raw_Get16Bit(uint16_T* const out_pu16PeriodCnts, uint16_T* const out_pu16DutyCycleCnts)
{
    DGIn_FreqIn_Period_Raw_Get16Bit(&SPD2, out_pu16PeriodCnts, out_pu16DutyCycleCnts);
}

#include <Pragma_Section_Start_CoreIndependent_data.h>

INSTANTIATE_DGIn_FreqIn(SPD3,
    CPUCore_0, CPU, ETPU_A13_J4, ETPU,
    NULL,
    INPUT_IS_NON_INVERTING,
    1);

#include <Pragma_Section_End_data.h>


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: SPD3_FrequencyInput_Create
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void SPD3_FrequencyInput_Create(void)
{
    S_DGIn_Create_FreqIn CreateObj;
        
    CreateObj.DGIn_Create.uValidAttributesMask = DGIN_USE_DEFAULTS;
    CreateObj.FreqInCreateAttribs_CPU.uValidAttributesMask = USE_FREQIN_DEFAULTS;
    
    CreateObj.FreqInCreateAttribs_CPU.eSyncEdge = RES_EDGE_DETECT_RISE;
    CreateObj.FreqInCreateAttribs_CPU.uMaxExpectedPeriod_us = 100000;

    
    

    DGIn_FreqIn_Create(&SPD3,&CreateObj);
}

 

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: SPD3_FrequencyInput_TriggerOnPulseCnt_Set
::
:: This is potentially a multi-threaded function call.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void SPD3_FrequencyInput_TriggerOnPulseCnt_Set(uint8_T uDesiredPulseCnt)
{


    UNUSED(uDesiredPulseCnt);
	
}
    
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: SPD3_FrequencyInput_AverageFrequency_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
uint32_T SPD3_FrequencyInput_AverageFrequency_Get(void)
{
    S_FreqInAverageFreq RuntimeObj;
    DGIn_FreqIn_GetAverage(&SPD3, &RuntimeObj);
    return RuntimeObj.uAvgFrequency;
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: SPD3_FrequencyInput_InstantFrequency_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
uint32_T SPD3_FrequencyInput_InstantFrequency_Get(void)
{
    S_FreqInInstantFreq RuntimeObj;
    DGIn_FreqIn_GetInstant(&SPD3, &RuntimeObj);
    return RuntimeObj.uInstantFrequency;
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: SPD3_FrequencyInput_InstantFrequencyWithDutyCycle_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void SPD3_FrequencyInput_InstantFrequencyWithDutyCycle_Get(uint32_T* const out_pu32Frequency, int16_T* const out_ps16Duty)
{
    S_FreqInInstantFreq RuntimeObj;
    DGIn_FreqIn_GetInstant(&SPD3, &RuntimeObj);

    if (out_pu32Frequency != NULL)
    {
        *out_pu32Frequency = RuntimeObj.uInstantFrequency;
    }

    if (out_ps16Duty != NULL)
    {
        *out_ps16Duty = RuntimeObj.sDutyCycle;
    }
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: SPD3_FrequencyInput_Period_Raw_Get32Bit
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void SPD3_FrequencyInput_Period_Raw_Get32Bit(uint32_T* const out_pu32PeriodCnts, uint32_T* const out_pu32DutyCycleCnts)
{
    DGIn_FreqIn_Period_Raw_Get32Bit(&SPD3, out_pu32PeriodCnts, out_pu32DutyCycleCnts);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: SPD3_FrequencyInput_Period_Raw_Get16Bit
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void SPD3_FrequencyInput_Period_Raw_Get16Bit(uint16_T* const out_pu16PeriodCnts, uint16_T* const out_pu16DutyCycleCnts)
{
    DGIn_FreqIn_Period_Raw_Get16Bit(&SPD3, out_pu16PeriodCnts, out_pu16DutyCycleCnts);
}

INSTANTIATE_MC33800_Hardware(
		S_SHRC_4,
		SPI_C,
		USE_SPI_CS1,
        NULL,
		1,
		20000,
		1000000,
        1);
void S_SHRC_4_Create(void)
{
	S_MC33800CreateAttributes CreateObj;
	CreateObj.uValidAttributesMask = USE_MC33800_DEFAULTS;
	MC33800_Hardware_Create(&S_SHRC_4, &CreateObj);
}

INSTANTIATE_MC33800Output_DiscreteOut(MC33800_LSO9,
	MC33800_OUT5,
	OSS,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_4);
void MC33800_LSO9_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_INPUT | USE_MC33800OUTPUT_PARALLEL_OUTPUT;
	
	MC33800_DiscreteOut_Create(&MC33800_LSO9, &CreateObj);
}

INSTANTIATEMETHOD_CPU_PWM_ETPU(LSO9_PWMOutput_Methods);
	
	
    INSTANTIATE_CPU_PWM_ETPU(LSO9_PWMOutput,
        /* Method */ LSO9_PWMOutput_Methods,
      /* ProcName */ CPUCore_0,
     /* CPUOutPin */ ETPU_B12_J24,
  /* MyDeviceName */ LSO9_PWMOutput);
void LSO9_PWMOutput_PWMOutput_Create(void)
{
    S_PWMCreateAttribs CreateObj;



    CreateObj.uValidAttributesMask = USE_PWM_DEFAULTS;
    CreateObj.eJustification = PWM_LEFT_JUSTIFIED;

    CreateObj.uValidAttributesMask |= USE_PWM_MIN_EXPECTED_FREQ;
    CreateObj.uMinExpectedFrequency = GET_FIXEDPT_PWM_FREQUENCY(2.00);    

    PWM_GenAPI_Create(&LSO9_PWMOutput, &CreateObj);
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: LSO9_PWMOutput_PWMOutput_Set
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
boolean_T LSO9_PWMOutput_PWMOutput_Set(uint32_T frequency, int16_T dutyCycle, boolean_T brake, boolean_T enable)
{
    if (enable)
	{
	    return(SUCCESS(PWM_GenAPI_FrequencyDutyCycle_Set(&LSO9_PWMOutput, frequency, dutyCycle)));
    }
	else
	{
	    return(SUCCESS(PWM_GenAPI_FrequencyDutyCycle_Set(&LSO9_PWMOutput, 0, 0)));
    }
}
void LSO9_PWMOutput_PWMOutput_Stop(void)
{
	PWM_GenAPI_FrequencyDutyCycle_Set(&LSO9_PWMOutput, 0, 0);
}

INSTANTIATE_MC33800Output_DiscreteOut(MC33800_LSO10,
	MC33800_OUT7,
	OSS,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_4);
void MC33800_LSO10_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_INPUT | USE_MC33800OUTPUT_PARALLEL_OUTPUT;
	
	MC33800_DiscreteOut_Create(&MC33800_LSO10, &CreateObj);
}

INSTANTIATEMETHOD_CPU_PWM_ETPU(LSO10_PWMOutput_Methods);
	
	
    INSTANTIATE_CPU_PWM_ETPU(LSO10_PWMOutput,
        /* Method */ LSO10_PWMOutput_Methods,
      /* ProcName */ CPUCore_0,
     /* CPUOutPin */ ETPU_B11_J25,
  /* MyDeviceName */ LSO10_PWMOutput);
void LSO10_PWMOutput_PWMOutput_Create(void)
{
    S_PWMCreateAttribs CreateObj;



    CreateObj.uValidAttributesMask = USE_PWM_DEFAULTS;
    CreateObj.eJustification = PWM_LEFT_JUSTIFIED;

    CreateObj.uValidAttributesMask |= USE_PWM_MIN_EXPECTED_FREQ;
    CreateObj.uMinExpectedFrequency = GET_FIXEDPT_PWM_FREQUENCY(2.00);    

    PWM_GenAPI_Create(&LSO10_PWMOutput, &CreateObj);
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: LSO10_PWMOutput_PWMOutput_Set
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
boolean_T LSO10_PWMOutput_PWMOutput_Set(uint32_T frequency, int16_T dutyCycle, boolean_T brake, boolean_T enable)
{
    if (enable)
	{
	    return(SUCCESS(PWM_GenAPI_FrequencyDutyCycle_Set(&LSO10_PWMOutput, frequency, dutyCycle)));
    }
	else
	{
	    return(SUCCESS(PWM_GenAPI_FrequencyDutyCycle_Set(&LSO10_PWMOutput, 0, 0)));
    }
}
void LSO10_PWMOutput_PWMOutput_Stop(void)
{
	PWM_GenAPI_FrequencyDutyCycle_Set(&LSO10_PWMOutput, 0, 0);
}

INSTANTIATEMETHOD_CPU_PWM_ETPU(H1p_Methods);
	
	
    INSTANTIATE_CPU_PWM_ETPU(H1p,
        /* Method */ H1p_Methods,
      /* ProcName */ CPUCore_0,
     /* CPUOutPin */ ETPU_B9_J26,
  /* MyDeviceName */ H1p);
void H1p_PWMOutput_Create(void)
{
    S_PWMCreateAttribs CreateObj;



    CreateObj.uValidAttributesMask = USE_PWM_DEFAULTS;
    CreateObj.eJustification = PWM_LEFT_JUSTIFIED;

    CreateObj.uValidAttributesMask |= USE_PWM_MIN_EXPECTED_FREQ;
    CreateObj.uMinExpectedFrequency = GET_FIXEDPT_PWM_FREQUENCY(64.00);    

    PWM_GenAPI_Create(&H1p, &CreateObj);
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: H1p_PWMOutput_Set
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
boolean_T H1p_PWMOutput_Set(uint32_T frequency, int16_T dutyCycle, boolean_T brake, boolean_T enable)
{
    if (enable)
	{
	    return(SUCCESS(PWM_GenAPI_FrequencyDutyCycle_Set(&H1p, frequency, dutyCycle)));
    }
	else
	{
	    return(SUCCESS(PWM_GenAPI_FrequencyDutyCycle_Set(&H1p, 0, 0)));
    }
}
void H1p_PWMOutput_Stop(void)
{
	PWM_GenAPI_FrequencyDutyCycle_Set(&H1p, 0, 0);
}

INSTANTIATEMETHOD_CPU_PWM_ETPU(H1m_Methods);
	
	
    INSTANTIATE_CPU_PWM_ETPU(H1m,
        /* Method */ H1m_Methods,
      /* ProcName */ CPUCore_0,
     /* CPUOutPin */ ETPU_B10_K23,
  /* MyDeviceName */ H1m);
void H1m_PWMOutput_Create(void)
{
    S_PWMCreateAttribs CreateObj;



    CreateObj.uValidAttributesMask = USE_PWM_DEFAULTS;
    CreateObj.eJustification = PWM_LEFT_JUSTIFIED;

    CreateObj.uValidAttributesMask |= USE_PWM_MIN_EXPECTED_FREQ;
    CreateObj.uMinExpectedFrequency = GET_FIXEDPT_PWM_FREQUENCY(64.00);    

    PWM_GenAPI_Create(&H1m, &CreateObj);
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: H1m_PWMOutput_Set
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
boolean_T H1m_PWMOutput_Set(uint32_T frequency, int16_T dutyCycle, boolean_T brake, boolean_T enable)
{
    if (enable)
	{
	    return(SUCCESS(PWM_GenAPI_FrequencyDutyCycle_Set(&H1m, frequency, dutyCycle)));
    }
	else
	{
	    return(SUCCESS(PWM_GenAPI_FrequencyDutyCycle_Set(&H1m, 0, 0)));
    }
}
void H1m_PWMOutput_Stop(void)
{
	PWM_GenAPI_FrequencyDutyCycle_Set(&H1m, 0, 0);
}

INSTANTIATEMETHOD_CPU_PWM_ETPU(H1_InhibitA_Methods);
	
	
    INSTANTIATE_CPU_PWM_ETPU(H1_InhibitA,
        /* Method */ H1_InhibitA_Methods,
      /* ProcName */ CPUCore_0,
     /* CPUOutPin */ ETPU_B16_D16,
  /* MyDeviceName */ H1_InhibitA);
void H1_InhibitA_PWMOutput_Create(void)
{
    S_PWMCreateAttribs CreateObj;



    CreateObj.uValidAttributesMask = USE_PWM_DEFAULTS;
    CreateObj.eJustification = PWM_LEFT_JUSTIFIED;

    CreateObj.uValidAttributesMask |= USE_PWM_MIN_EXPECTED_FREQ;
    CreateObj.uMinExpectedFrequency = GET_FIXEDPT_PWM_FREQUENCY(64.00);    

    PWM_GenAPI_Create(&H1_InhibitA, &CreateObj);
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: H1_InhibitA_PWMOutput_Set
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
boolean_T H1_InhibitA_PWMOutput_Set(uint32_T frequency, int16_T dutyCycle, boolean_T brake, boolean_T enable)
{
    if (enable)
	{
	    return(SUCCESS(PWM_GenAPI_FrequencyDutyCycle_Set(&H1_InhibitA, frequency, dutyCycle)));
    }
	else
	{
	    return(SUCCESS(PWM_GenAPI_FrequencyDutyCycle_Set(&H1_InhibitA, 0, 0)));
    }
}
void H1_InhibitA_PWMOutput_Stop(void)
{
	PWM_GenAPI_FrequencyDutyCycle_Set(&H1_InhibitA, 0, 0);
}

INSTANTIATEMETHOD_CPU_PWM_ETPU(H1_InhibitB_Methods);
	
	
    INSTANTIATE_CPU_PWM_ETPU(H1_InhibitB,
        /* Method */ H1_InhibitB_Methods,
      /* ProcName */ CPUCore_0,
     /* CPUOutPin */ ETPU_B17_D17,
  /* MyDeviceName */ H1_InhibitB);
void H1_InhibitB_PWMOutput_Create(void)
{
    S_PWMCreateAttribs CreateObj;



    CreateObj.uValidAttributesMask = USE_PWM_DEFAULTS;
    CreateObj.eJustification = PWM_LEFT_JUSTIFIED;

    CreateObj.uValidAttributesMask |= USE_PWM_MIN_EXPECTED_FREQ;
    CreateObj.uMinExpectedFrequency = GET_FIXEDPT_PWM_FREQUENCY(64.00);    

    PWM_GenAPI_Create(&H1_InhibitB, &CreateObj);
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: H1_InhibitB_PWMOutput_Set
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
boolean_T H1_InhibitB_PWMOutput_Set(uint32_T frequency, int16_T dutyCycle, boolean_T brake, boolean_T enable)
{
    if (enable)
	{
	    return(SUCCESS(PWM_GenAPI_FrequencyDutyCycle_Set(&H1_InhibitB, frequency, dutyCycle)));
    }
	else
	{
	    return(SUCCESS(PWM_GenAPI_FrequencyDutyCycle_Set(&H1_InhibitB, 0, 0)));
    }
}
void H1_InhibitB_PWMOutput_Stop(void)
{
	PWM_GenAPI_FrequencyDutyCycle_Set(&H1_InhibitB, 0, 0);
}

void H1p_H1m_PWMOutput_Create(void)
{
    
    
}
void H1p_H1m_PWMOutput_Enable_Set(boolean_T in_bEnable)
{

    H1_InhibitA_PWMOutput_Set(100000,in_bEnable*GET_FIXEDPT_PWM_DUTYCYCLE(100),FALSE, TRUE);
		
    H1_InhibitB_PWMOutput_Set(100000,in_bEnable*GET_FIXEDPT_PWM_DUTYCYCLE(100),FALSE, TRUE);
		
}

/*
 H-Bridge truth table - 'PWM_PWM' Control Mode
 InputA == H1p, ETPU_B9_J26
 InputB == H1m, ETPU_B10_K23
 'ON' == 100% PWM (when applicable)
 'OFF' == 0% PWM (when applicable)

 =======================================================================================
 | Action |     InputA      |     Input B     | Mode
 =======================================================================================
 |  FWD   |      PWM        |     0% PWM      | 
 |  REV   |     0% PWM      |      PWM        | PWM_PWM
 |  Brake |       ON       |       ON       |
 =======================================================================================
*/    
#define H1p_GenericDualInputHBridge_FWD_Set(frequency, dutyCycle, brake, enable) H1p_PWMOutput_Set(frequency, dutyCycle, brake, enable)
#define H1m_GenericDualInputHBridge_FWD_Set(frequency, dutyCycle, brake, enable) H1m_PWMOutput_Set(frequency, 0, brake, enable)
#define H1p_GenericDualInputHBridge_REV_Set(frequency, dutyCycle, brake, enable) H1p_PWMOutput_Set(frequency, 0, brake, enable)
#define H1m_GenericDualInputHBridge_REV_Set(frequency, dutyCycle, brake, enable) H1m_PWMOutput_Set(frequency, dutyCycle, brake, enable)

#define H1p_GenericDualInputHBridge_Brake() H1p_PWMOutput_Set(frequency, GET_FIXEDPT_PWM_DUTYCYCLE(100), brake, enable)
#define H1m_GenericDualInputHBridge_Brake() H1m_PWMOutput_Set(frequency, GET_FIXEDPT_PWM_DUTYCYCLE(100), brake, enable)
void H1p_H1m_PWMOutput_PWMOutput_Set(uint32_T frequency, int16_T dutyCycle, boolean_T brake, boolean_T enable)
{
    if (enable)
    {
        /* We are about to change the state of the h-bridge (multiple) control lines. Do so coherently. */
        Interrupt_Disable();
        {


            if(brake)
            {
                /* need to ensure that both pins are changed without interruption */
                H1p_GenericDualInputHBridge_Brake();
                H1m_GenericDualInputHBridge_Brake();
            }
            else
        
            {
                if (dutyCycle >= 0)
                {
                    H1p_GenericDualInputHBridge_FWD_Set(frequency, dutyCycle, brake, enable);
                    H1m_GenericDualInputHBridge_FWD_Set(frequency, dutyCycle, brake, enable);
                }
                else
                {
                    H1p_GenericDualInputHBridge_REV_Set(frequency, dutyCycle, brake, enable);
                    H1m_GenericDualInputHBridge_REV_Set(frequency, dutyCycle, brake, enable);
                }
            }
        


            /* Assert the enable lines. They may have been previously de-asserted */
            H1p_H1m_PWMOutput_Enable_Set(TRUE);            
  
        
        }
        Interrupt_Enable();                      
    }
    else
    {
        H1p_H1m_PWMOutput_Stop();
    }
}
void H1p_H1m_PWMOutput_Stop(void)
{

    /* Disable interrupts so that all lines may be set coherently */
    Interrupt_Disable();
    /* De-assert the enable lines */
    H1p_H1m_PWMOutput_Enable_Set(FALSE);            
    
    /* Set a zero duty cycle. We don't want to drive the inputs if the output is disabled. */
    H1p_GenericDualInputHBridge_FWD_Set(0, 0, FALSE, FALSE);
    H1m_GenericDualInputHBridge_FWD_Set(0, 0, FALSE, FALSE);
    
    Interrupt_Enable();        
	
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: H1p_H1m_PWMOutput_CM_CurrentMeasurement_mA_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
int16_T H1p_H1m_PWMOutput_CM_CurrentMeasurement_mA_Get(void)
{
    
    int32_T Result = H1_Imon_AnalogInput_Get();
		
    Result *= 30L;
            

    if (Result > MAX_SINT16_T)
	{
	    Result = MAX_SINT16_T;
	}
	else if (Result < MIN_SINT16_T)
	{
	    Result = MIN_SINT16_T;
	}
    return ((int16_T)Result);
}

INSTANTIATEMETHOD_CPU_PWM_ETPU(H2p_Methods);
	
	
    INSTANTIATE_CPU_PWM_ETPU(H2p,
        /* Method */ H2p_Methods,
      /* ProcName */ CPUCore_0,
     /* CPUOutPin */ ETPU_B4_L24,
  /* MyDeviceName */ H2p);
void H2p_PWMOutput_Create(void)
{
    S_PWMCreateAttribs CreateObj;



    CreateObj.uValidAttributesMask = USE_PWM_DEFAULTS;
    CreateObj.eJustification = PWM_LEFT_JUSTIFIED;

    CreateObj.uValidAttributesMask |= USE_PWM_MIN_EXPECTED_FREQ;
    CreateObj.uMinExpectedFrequency = GET_FIXEDPT_PWM_FREQUENCY(2.00);    

    PWM_GenAPI_Create(&H2p, &CreateObj);
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: H2p_PWMOutput_Set
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
boolean_T H2p_PWMOutput_Set(uint32_T frequency, int16_T dutyCycle, boolean_T brake, boolean_T enable)
{
    if (enable)
	{
	    return(SUCCESS(PWM_GenAPI_FrequencyDutyCycle_Set(&H2p, frequency, dutyCycle)));
    }
	else
	{
	    return(SUCCESS(PWM_GenAPI_FrequencyDutyCycle_Set(&H2p, 0, 0)));
    }
}
void H2p_PWMOutput_Stop(void)
{
	PWM_GenAPI_FrequencyDutyCycle_Set(&H2p, 0, 0);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
            :: H2p_PWMOutput_PWMOutput_Set
            :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
boolean_T H2p_PWMOutput_PWMOutput_Set(uint32_T frequency, int16_T dutyCycle, boolean_T brake, boolean_T enable)
{

                if (enable)
                {
                    H2_InhibitA_DiscreteOutput_Set(enable);
                    return(SUCCESS(H2p_PWMOutput_Set(frequency, dutyCycle, brake, enable)));
                }
                else
                {
                    H2p_PWMOutput_PWMOutput_Stop();
                }
            }
void H2p_PWMOutput_PWMOutput_Stop(void)
{
            H2_InhibitA_DiscreteOutput_Set(0);
            H2p_PWMOutput_Set(0, 0, 0, 0);
        }

INSTANTIATEMETHOD_CPU_PWM_ETPU(H2m_Methods);
	
	
    INSTANTIATE_CPU_PWM_ETPU(H2m,
        /* Method */ H2m_Methods,
      /* ProcName */ CPUCore_0,
     /* CPUOutPin */ ETPU_B5_K26,
  /* MyDeviceName */ H2m);
void H2m_PWMOutput_Create(void)
{
    S_PWMCreateAttribs CreateObj;



    CreateObj.uValidAttributesMask = USE_PWM_DEFAULTS;
    CreateObj.eJustification = PWM_LEFT_JUSTIFIED;

    CreateObj.uValidAttributesMask |= USE_PWM_MIN_EXPECTED_FREQ;
    CreateObj.uMinExpectedFrequency = GET_FIXEDPT_PWM_FREQUENCY(2.00);    

    PWM_GenAPI_Create(&H2m, &CreateObj);
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: H2m_PWMOutput_Set
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
boolean_T H2m_PWMOutput_Set(uint32_T frequency, int16_T dutyCycle, boolean_T brake, boolean_T enable)
{
    if (enable)
	{
	    return(SUCCESS(PWM_GenAPI_FrequencyDutyCycle_Set(&H2m, frequency, dutyCycle)));
    }
	else
	{
	    return(SUCCESS(PWM_GenAPI_FrequencyDutyCycle_Set(&H2m, 0, 0)));
    }
}
void H2m_PWMOutput_Stop(void)
{
	PWM_GenAPI_FrequencyDutyCycle_Set(&H2m, 0, 0);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
            :: H2m_PWMOutput_PWMOutput_Set
            :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
boolean_T H2m_PWMOutput_PWMOutput_Set(uint32_T frequency, int16_T dutyCycle, boolean_T brake, boolean_T enable)
{

                if (enable)
                {
                    H2_InhibitB_DiscreteOutput_Set(enable);
                    return(SUCCESS(H2m_PWMOutput_Set(frequency, dutyCycle, brake, enable)));
                }
                else
                {
                    H2m_PWMOutput_PWMOutput_Stop();
                }
            }
void H2m_PWMOutput_PWMOutput_Stop(void)
{
            H2_InhibitB_DiscreteOutput_Set(0);
            H2m_PWMOutput_Set(0, 0, 0, 0);
        }

INSTANTIATE_MC33800Output_DiscreteOut(MC33800_LSO8,
	MC33800_OUT3,
	OSS,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_4);
void MC33800_LSO8_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_INPUT | USE_MC33800OUTPUT_PARALLEL_OUTPUT;
	
	MC33800_DiscreteOut_Create(&MC33800_LSO8, &CreateObj);
}

INSTANTIATEMETHOD_CPU_PWM_EMIOS(LSO8_PWMOutput_Methods);
	
	
    INSTANTIATE_CPU_PWM_EMIOS(LSO8_PWMOutput,
        /* Method */ LSO8_PWMOutput_Methods,
      /* ProcName */ CPUCore_0,
     /* CPUOutPin */ EMIOS_23_AE21,
  /* MyDeviceName */ LSO8_PWMOutput);
void LSO8_PWMOutput_PWMOutput_Create(void)
{
    S_PWMCreateAttribs CreateObj;



    CreateObj.uValidAttributesMask = USE_PWM_DEFAULTS;
    CreateObj.eJustification = PWM_LEFT_JUSTIFIED;

    CreateObj.uValidAttributesMask |= USE_PWM_MIN_EXPECTED_FREQ;
    CreateObj.uMinExpectedFrequency = GET_FIXEDPT_PWM_FREQUENCY(2.00);    

    PWM_GenAPI_Create(&LSO8_PWMOutput, &CreateObj);
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: LSO8_PWMOutput_PWMOutput_Set
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
boolean_T LSO8_PWMOutput_PWMOutput_Set(uint32_T frequency, int16_T dutyCycle, boolean_T brake, boolean_T enable)
{
    if (enable)
	{
	    return(SUCCESS(PWM_GenAPI_FrequencyDutyCycle_Set(&LSO8_PWMOutput, frequency, dutyCycle)));
    }
	else
	{
	    return(SUCCESS(PWM_GenAPI_FrequencyDutyCycle_Set(&LSO8_PWMOutput, 0, 0)));
    }
}
void LSO8_PWMOutput_PWMOutput_Stop(void)
{
	PWM_GenAPI_FrequencyDutyCycle_Set(&LSO8_PWMOutput, 0, 0);
}

INSTANTIATE_DGIn_CamEncoder(CAM,    /* Name                        */
		CPUCore_0,                     /* eCamCPUPin_ProcName         */
		CPU,                     /* eCamCPUPin_Processor,       */
		ETPU_A15_J2,                 /* eCamCPUPin,                 */
		ETPU,                  /* eCamCPUPinType,             */
		CNK,           /* PrimaryEncoderDeviceName,   */
		
        CAMENCODER_STYLE_1X_HALFMOON,    /* eStyle,                     */
			INPUT_IS_NON_INVERTING);       /* eDGInputStage)         */
void CAM_Encoder_Create(void)
{
	S_DGIn_Create_CamEncoder CreateObj;
	
	CreateObj.DGIn_Create.uValidAttributesMask = DGIN_USE_DEFAULTS;
	CreateObj.CamEncoderCreateAttribs_CPU.uValidAttributesMask = USE_CAM_DEFAULTS;

	CreateObj.CamEncoderCreateAttribs_CPU.uValidAttributesMask |= USE_CAM_IS_ZEROSPEED_SENSOR;

	CreateObj.CamEncoderCreateAttribs_CPU.eSyncEdge = RES_EDGE_DETECT_RISE;


	
	DGIn_CamEncoder_Create(&CAM, &CreateObj);
}

uint32_T const g_eQADCCommandQueueBuffer1[] =
{ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN23_A10, RFIFO_1, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_EST1 */
ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN22_B10, RFIFO_1, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_EST2 */
ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN25_C11, RFIFO_1, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_EST3 */
ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN26_B11, RFIFO_1, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_EST4 */
ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN27_A11, RFIFO_1, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_EST5 */
ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN6_D10, RFIFO_1, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_EST6 */
ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN2_D9, RFIFO_1, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_EST7 */
ADD_ANALOG_RESOURCE_TO_END_OF_QUEUE(ADC_AN7_C9, RFIFO_1, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_EST8 */

};



uint16_T g_eQADCResultQueueBuffer1[8];


INSTANTIATEMETHOD_QADC_QUEUE(ESTDiagnostics_eQADCQueue_QueueMethod,
        /*        CPUType */ CPU,
        /*     Queue Type */ SW_TRIG_SINGLE_SCAN_WITH_NOTIFY,
        /*   Result Style */ STANDARD_RESULT);

INSTANTIATE_QADC_QUEUE(ESTDiagnostics_eQADCQueue,
  /*    Processor Name */ CPUCore_0,
  /*    Main Processor */ CPU,
  /* Queue Method Name */ ESTDiagnostics_eQADCQueue_QueueMethod,
  /*        Queue Type */ SW_TRIG_SINGLE_SCAN_WITH_NOTIFY,
  /*       Queue Index */ eQADC_QUEUE_1,
  /*  Ptr to Command Q */ g_eQADCCommandQueueBuffer1,
  /*   Ptr to Result Q */ g_eQADCResultQueueBuffer1,
  /*   Command Q Depth */ 8,
  /*    Result Q Depth */ 8,
  /*      ISR Priority */ INTCPRIORITY_10,
  /*  Snooper Func Ptr */ NULL,
  /*       This Device */ ESTDiagnostics_eQADCQueue,
  /* Depth of the Trigger Request Queue */
10,
 /* Desired Queue Conversion Resolution */
10 

);
void ESTDiagnostics_eQADCQueue_Create(void)
{
    S_AnalogQueueAttributes Attributes;

    /*============================================================================*/
    /* The buffer should have been created by an earlier dependancy               */
    /*============================================================================*/

    /*========================================================================*/
    /* Now we can create the Queue.                                           */
    /*========================================================================*/
    /* eQADCQueue ESTDiagnostics_eQADCQueue */
    
    Attributes.uValidAttributesMask = USE_ANALOG_DEFAULTS;
    
    {

        ESTDiagnostics_eQADCQueue.pMethods->pfnCreate(&ESTDiagnostics_eQADCQueue, &Attributes);
    }
}
uint16_T  QADC_EST1_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 10; /* Result representation in number of bits */

	ESTDiagnostics_eQADCQueue.pMethods->pfnGetScaledResult(&ESTDiagnostics_eQADCQueue, /* Queue Oject */
	0,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  QADC_EST2_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 10; /* Result representation in number of bits */

	ESTDiagnostics_eQADCQueue.pMethods->pfnGetScaledResult(&ESTDiagnostics_eQADCQueue, /* Queue Oject */
	1,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  QADC_EST3_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 10; /* Result representation in number of bits */

	ESTDiagnostics_eQADCQueue.pMethods->pfnGetScaledResult(&ESTDiagnostics_eQADCQueue, /* Queue Oject */
	2,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  QADC_EST4_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 10; /* Result representation in number of bits */

	ESTDiagnostics_eQADCQueue.pMethods->pfnGetScaledResult(&ESTDiagnostics_eQADCQueue, /* Queue Oject */
	3,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  QADC_EST5_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 10; /* Result representation in number of bits */

	ESTDiagnostics_eQADCQueue.pMethods->pfnGetScaledResult(&ESTDiagnostics_eQADCQueue, /* Queue Oject */
	4,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  QADC_EST6_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 10; /* Result representation in number of bits */

	ESTDiagnostics_eQADCQueue.pMethods->pfnGetScaledResult(&ESTDiagnostics_eQADCQueue, /* Queue Oject */
	5,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  QADC_EST7_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 10; /* Result representation in number of bits */

	ESTDiagnostics_eQADCQueue.pMethods->pfnGetScaledResult(&ESTDiagnostics_eQADCQueue, /* Queue Oject */
	6,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  QADC_EST8_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 10; /* Result representation in number of bits */

	ESTDiagnostics_eQADCQueue.pMethods->pfnGetScaledResult(&ESTDiagnostics_eQADCQueue, /* Queue Oject */
	7,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}

extern S_PrimaryEncoderDefn_CPU const CNK_CPUEncoder;



INSTANTIATE_PushPullWithAnalogDiagnostics_PSP(EST1,                                                          
	/* Ctrl Signal Definition. A BasicOut_PSP Object */                                                
	CPUCore_0, CPU, ETPU_A11_K2, ETPU,
	RES_POL_ACTIVE_HIGH,
    &CNK_CPUEncoder, /* pCPUEncoderPinDefn */
    NULL, /* pEncoderSystemDefn */
	1, 1,
	0, /* End of event ISR */
	OUTPUT_IS_NON_INVERTING,
		
	/* Disable Signal Definition. A BasicOut_DiscreteOut Object */
	CPUCore_0, CPU, GPIO_191_AC18, GPIO,
	RES_POL_ACTIVE_HIGH,
	OUTPUT_IS_NON_INVERTING,

	/* Analog Feedback Definition */                                            
	NULL,                                        /* Diagnostics ISR   */                                            
	&GET_NAME_QADC_QUEUE_CPUISR_OBJ(ESTDiagnostics_eQADCQueue),    /* QADC Queue Object */                                            
	0);                                                       /* Where in the queue the result can be found. */
void EST1_PSPOutput_Create(void)
{
	S_PushPull_Create_PSP PushPullCreate;

	/* Configure the circuit First */
	PushPullCreate.CircuitCreate.uValidAttributesMask = PUSHPULL_USE_DEFAULTS;

	/* Configure the BasicOut PSP Object */
	PushPullCreate.CtrlCreateAttribs.CircuitCreate.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	PushPullCreate.CtrlCreateAttribs.BehaviorCreateAttribs.uValidAttributesMask = USE_PSP_DEFAULTS;
	

	/* Configure the BasicOut Discrete Object */
	PushPullCreate.DisableCreateAttributes.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	PushPullCreate.DisableCreateAttributes.Create.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	PushPullCreate.DisableCreateAttributes.DiscreteOutCreateAttribs.eInitialState = RES_OFF;

	PushPull_PSP_Create(&EST1, &PushPullCreate);
	
	/* Trigger an initial Scan */
	PushPull_PSP_Diagnostics_Data_Update(&EST1);
}
void EST1_Diagnostic_Trigger(void)
{
    PushPull_PSP_Diagnostics_Data_Update(&EST1);
}
uint16_T EST1_Diagnostic_Data_ADCValue_Get(void)
{
    S_PushPullDiagnosticsReport Report;

    PushPull_PSP_Diagnostics_Data_Get(&EST1, &Report);

    return ((uint16_T)Report.uADCValue);
}

extern S_PrimaryEncoderDefn_CPU const CNK_CPUEncoder;



INSTANTIATE_PushPullWithAnalogDiagnostics_PSP(EST2,                                                          
	/* Ctrl Signal Definition. A BasicOut_PSP Object */                                                
	CPUCore_0, CPU, ETPU_A4_M1, ETPU,
	RES_POL_ACTIVE_HIGH,
    &CNK_CPUEncoder, /* pCPUEncoderPinDefn */
    NULL, /* pEncoderSystemDefn */
	1, 1,
	0, /* End of event ISR */
	OUTPUT_IS_NON_INVERTING,
		
	/* Disable Signal Definition. A BasicOut_DiscreteOut Object */
	CPUCore_0, CPU, GPIO_194_AD18, GPIO,
	RES_POL_ACTIVE_HIGH,
	OUTPUT_IS_NON_INVERTING,

	/* Analog Feedback Definition */                                            
	NULL,                                        /* Diagnostics ISR   */                                            
	&GET_NAME_QADC_QUEUE_CPUISR_OBJ(ESTDiagnostics_eQADCQueue),    /* QADC Queue Object */                                            
	1);                                                       /* Where in the queue the result can be found. */
void EST2_PSPOutput_Create(void)
{
	S_PushPull_Create_PSP PushPullCreate;

	/* Configure the circuit First */
	PushPullCreate.CircuitCreate.uValidAttributesMask = PUSHPULL_USE_DEFAULTS;

	/* Configure the BasicOut PSP Object */
	PushPullCreate.CtrlCreateAttribs.CircuitCreate.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	PushPullCreate.CtrlCreateAttribs.BehaviorCreateAttribs.uValidAttributesMask = USE_PSP_DEFAULTS;
	

	/* Configure the BasicOut Discrete Object */
	PushPullCreate.DisableCreateAttributes.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	PushPullCreate.DisableCreateAttributes.Create.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	PushPullCreate.DisableCreateAttributes.DiscreteOutCreateAttribs.eInitialState = RES_OFF;

	PushPull_PSP_Create(&EST2, &PushPullCreate);
	
	/* Trigger an initial Scan */
	PushPull_PSP_Diagnostics_Data_Update(&EST2);
}
void EST2_Diagnostic_Trigger(void)
{
    PushPull_PSP_Diagnostics_Data_Update(&EST2);
}
uint16_T EST2_Diagnostic_Data_ADCValue_Get(void)
{
    S_PushPullDiagnosticsReport Report;

    PushPull_PSP_Diagnostics_Data_Get(&EST2, &Report);

    return ((uint16_T)Report.uADCValue);
}

extern S_PrimaryEncoderDefn_CPU const CNK_CPUEncoder;



INSTANTIATE_PushPullWithAnalogDiagnostics_PSP(EST3,                                                          
	/* Ctrl Signal Definition. A BasicOut_PSP Object */                                                
	CPUCore_0, CPU, ETPU_A5_L4, ETPU,
	RES_POL_ACTIVE_HIGH,
    &CNK_CPUEncoder, /* pCPUEncoderPinDefn */
    NULL, /* pEncoderSystemDefn */
	1, 1,
	0, /* End of event ISR */
	OUTPUT_IS_NON_INVERTING,
		
	/* Disable Signal Definition. A BasicOut_DiscreteOut Object */
	CPUCore_0, CPU, GPIO_192_AE18, GPIO,
	RES_POL_ACTIVE_HIGH,
	OUTPUT_IS_NON_INVERTING,

	/* Analog Feedback Definition */                                            
	NULL,                                        /* Diagnostics ISR   */                                            
	&GET_NAME_QADC_QUEUE_CPUISR_OBJ(ESTDiagnostics_eQADCQueue),    /* QADC Queue Object */                                            
	2);                                                       /* Where in the queue the result can be found. */
void EST3_PSPOutput_Create(void)
{
	S_PushPull_Create_PSP PushPullCreate;

	/* Configure the circuit First */
	PushPullCreate.CircuitCreate.uValidAttributesMask = PUSHPULL_USE_DEFAULTS;

	/* Configure the BasicOut PSP Object */
	PushPullCreate.CtrlCreateAttribs.CircuitCreate.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	PushPullCreate.CtrlCreateAttribs.BehaviorCreateAttribs.uValidAttributesMask = USE_PSP_DEFAULTS;
	

	/* Configure the BasicOut Discrete Object */
	PushPullCreate.DisableCreateAttributes.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	PushPullCreate.DisableCreateAttributes.Create.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	PushPullCreate.DisableCreateAttributes.DiscreteOutCreateAttribs.eInitialState = RES_OFF;

	PushPull_PSP_Create(&EST3, &PushPullCreate);
	
	/* Trigger an initial Scan */
	PushPull_PSP_Diagnostics_Data_Update(&EST3);
}
void EST3_Diagnostic_Trigger(void)
{
    PushPull_PSP_Diagnostics_Data_Update(&EST3);
}
uint16_T EST3_Diagnostic_Data_ADCValue_Get(void)
{
    S_PushPullDiagnosticsReport Report;

    PushPull_PSP_Diagnostics_Data_Get(&EST3, &Report);

    return ((uint16_T)Report.uADCValue);
}

extern S_PrimaryEncoderDefn_CPU const CNK_CPUEncoder;



INSTANTIATE_PushPullWithAnalogDiagnostics_PSP(EST4,                                                          
	/* Ctrl Signal Definition. A BasicOut_PSP Object */                                                
	CPUCore_0, CPU, ETPU_A6_L3, ETPU,
	RES_POL_ACTIVE_HIGH,
    &CNK_CPUEncoder, /* pCPUEncoderPinDefn */
    NULL, /* pEncoderSystemDefn */
	1, 1,
	0, /* End of event ISR */
	OUTPUT_IS_NON_INVERTING,
		
	/* Disable Signal Definition. A BasicOut_DiscreteOut Object */
	CPUCore_0, CPU, GPIO_190_AF18, GPIO,
	RES_POL_ACTIVE_HIGH,
	OUTPUT_IS_NON_INVERTING,

	/* Analog Feedback Definition */                                            
	NULL,                                        /* Diagnostics ISR   */                                            
	&GET_NAME_QADC_QUEUE_CPUISR_OBJ(ESTDiagnostics_eQADCQueue),    /* QADC Queue Object */                                            
	3);                                                       /* Where in the queue the result can be found. */
void EST4_PSPOutput_Create(void)
{
	S_PushPull_Create_PSP PushPullCreate;

	/* Configure the circuit First */
	PushPullCreate.CircuitCreate.uValidAttributesMask = PUSHPULL_USE_DEFAULTS;

	/* Configure the BasicOut PSP Object */
	PushPullCreate.CtrlCreateAttribs.CircuitCreate.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	PushPullCreate.CtrlCreateAttribs.BehaviorCreateAttribs.uValidAttributesMask = USE_PSP_DEFAULTS;
	

	/* Configure the BasicOut Discrete Object */
	PushPullCreate.DisableCreateAttributes.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	PushPullCreate.DisableCreateAttributes.Create.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	PushPullCreate.DisableCreateAttributes.DiscreteOutCreateAttribs.eInitialState = RES_OFF;

	PushPull_PSP_Create(&EST4, &PushPullCreate);
	
	/* Trigger an initial Scan */
	PushPull_PSP_Diagnostics_Data_Update(&EST4);
}
void EST4_Diagnostic_Trigger(void)
{
    PushPull_PSP_Diagnostics_Data_Update(&EST4);
}
uint16_T EST4_Diagnostic_Data_ADCValue_Get(void)
{
    S_PushPullDiagnosticsReport Report;

    PushPull_PSP_Diagnostics_Data_Get(&EST4, &Report);

    return ((uint16_T)Report.uADCValue);
}

extern S_PrimaryEncoderDefn_CPU const CNK_CPUEncoder;



INSTANTIATE_PushPullWithAnalogDiagnostics_PSP(EST5,                                                          
	/* Ctrl Signal Definition. A BasicOut_PSP Object */                                                
	CPUCore_0, CPU, ETPU_A7_L2, ETPU,
	RES_POL_ACTIVE_HIGH,
    &CNK_CPUEncoder, /* pCPUEncoderPinDefn */
    NULL, /* pEncoderSystemDefn */
	1, 1,
	0, /* End of event ISR */
	OUTPUT_IS_NON_INVERTING,
		
	/* Disable Signal Definition. A BasicOut_DiscreteOut Object */
	CPUCore_0, CPU, GPIO_200_AC19, GPIO,
	RES_POL_ACTIVE_HIGH,
	OUTPUT_IS_NON_INVERTING,

	/* Analog Feedback Definition */                                            
	NULL,                                        /* Diagnostics ISR   */                                            
	&GET_NAME_QADC_QUEUE_CPUISR_OBJ(ESTDiagnostics_eQADCQueue),    /* QADC Queue Object */                                            
	4);                                                       /* Where in the queue the result can be found. */
void EST5_PSPOutput_Create(void)
{
	S_PushPull_Create_PSP PushPullCreate;

	/* Configure the circuit First */
	PushPullCreate.CircuitCreate.uValidAttributesMask = PUSHPULL_USE_DEFAULTS;

	/* Configure the BasicOut PSP Object */
	PushPullCreate.CtrlCreateAttribs.CircuitCreate.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	PushPullCreate.CtrlCreateAttribs.BehaviorCreateAttribs.uValidAttributesMask = USE_PSP_DEFAULTS;
	

	/* Configure the BasicOut Discrete Object */
	PushPullCreate.DisableCreateAttributes.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	PushPullCreate.DisableCreateAttributes.Create.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	PushPullCreate.DisableCreateAttributes.DiscreteOutCreateAttribs.eInitialState = RES_OFF;

	PushPull_PSP_Create(&EST5, &PushPullCreate);
	
	/* Trigger an initial Scan */
	PushPull_PSP_Diagnostics_Data_Update(&EST5);
}
void EST5_Diagnostic_Trigger(void)
{
    PushPull_PSP_Diagnostics_Data_Update(&EST5);
}
uint16_T EST5_Diagnostic_Data_ADCValue_Get(void)
{
    S_PushPullDiagnosticsReport Report;

    PushPull_PSP_Diagnostics_Data_Get(&EST5, &Report);

    return ((uint16_T)Report.uADCValue);
}

extern S_PrimaryEncoderDefn_CPU const CNK_CPUEncoder;



INSTANTIATE_PushPullWithAnalogDiagnostics_PSP(EST6,                                                          
	/* Ctrl Signal Definition. A BasicOut_PSP Object */                                                
	CPUCore_0, CPU, ETPU_A8_L1, ETPU,
	RES_POL_ACTIVE_HIGH,
    &CNK_CPUEncoder, /* pCPUEncoderPinDefn */
    NULL, /* pEncoderSystemDefn */
	1, 1,
	0, /* End of event ISR */
	OUTPUT_IS_NON_INVERTING,
		
	/* Disable Signal Definition. A BasicOut_DiscreteOut Object */
	CPUCore_0, CPU, GPIO_196_AD19, GPIO,
	RES_POL_ACTIVE_HIGH,
	OUTPUT_IS_NON_INVERTING,

	/* Analog Feedback Definition */                                            
	NULL,                                        /* Diagnostics ISR   */                                            
	&GET_NAME_QADC_QUEUE_CPUISR_OBJ(ESTDiagnostics_eQADCQueue),    /* QADC Queue Object */                                            
	5);                                                       /* Where in the queue the result can be found. */
void EST6_PSPOutput_Create(void)
{
	S_PushPull_Create_PSP PushPullCreate;

	/* Configure the circuit First */
	PushPullCreate.CircuitCreate.uValidAttributesMask = PUSHPULL_USE_DEFAULTS;

	/* Configure the BasicOut PSP Object */
	PushPullCreate.CtrlCreateAttribs.CircuitCreate.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	PushPullCreate.CtrlCreateAttribs.BehaviorCreateAttribs.uValidAttributesMask = USE_PSP_DEFAULTS;
	

	/* Configure the BasicOut Discrete Object */
	PushPullCreate.DisableCreateAttributes.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	PushPullCreate.DisableCreateAttributes.Create.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	PushPullCreate.DisableCreateAttributes.DiscreteOutCreateAttribs.eInitialState = RES_OFF;

	PushPull_PSP_Create(&EST6, &PushPullCreate);
	
	/* Trigger an initial Scan */
	PushPull_PSP_Diagnostics_Data_Update(&EST6);
}
void EST6_Diagnostic_Trigger(void)
{
    PushPull_PSP_Diagnostics_Data_Update(&EST6);
}
uint16_T EST6_Diagnostic_Data_ADCValue_Get(void)
{
    S_PushPullDiagnosticsReport Report;

    PushPull_PSP_Diagnostics_Data_Get(&EST6, &Report);

    return ((uint16_T)Report.uADCValue);
}

extern S_PrimaryEncoderDefn_CPU const CNK_CPUEncoder;



INSTANTIATE_PushPullWithAnalogDiagnostics_PSP(EST7,                                                          
	/* Ctrl Signal Definition. A BasicOut_PSP Object */                                                
	CPUCore_0, CPU, ETPU_A9_K4, ETPU,
	RES_POL_ACTIVE_HIGH,
    &CNK_CPUEncoder, /* pCPUEncoderPinDefn */
    NULL, /* pEncoderSystemDefn */
	1, 1,
	0, /* End of event ISR */
	OUTPUT_IS_NON_INVERTING,
		
	/* Disable Signal Definition. A BasicOut_DiscreteOut Object */
	CPUCore_0, CPU, GPIO_195_AE19, GPIO,
	RES_POL_ACTIVE_HIGH,
	OUTPUT_IS_NON_INVERTING,

	/* Analog Feedback Definition */                                            
	NULL,                                        /* Diagnostics ISR   */                                            
	&GET_NAME_QADC_QUEUE_CPUISR_OBJ(ESTDiagnostics_eQADCQueue),    /* QADC Queue Object */                                            
	6);                                                       /* Where in the queue the result can be found. */
void EST7_PSPOutput_Create(void)
{
	S_PushPull_Create_PSP PushPullCreate;

	/* Configure the circuit First */
	PushPullCreate.CircuitCreate.uValidAttributesMask = PUSHPULL_USE_DEFAULTS;

	/* Configure the BasicOut PSP Object */
	PushPullCreate.CtrlCreateAttribs.CircuitCreate.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	PushPullCreate.CtrlCreateAttribs.BehaviorCreateAttribs.uValidAttributesMask = USE_PSP_DEFAULTS;
	

	/* Configure the BasicOut Discrete Object */
	PushPullCreate.DisableCreateAttributes.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	PushPullCreate.DisableCreateAttributes.Create.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	PushPullCreate.DisableCreateAttributes.DiscreteOutCreateAttribs.eInitialState = RES_OFF;

	PushPull_PSP_Create(&EST7, &PushPullCreate);
	
	/* Trigger an initial Scan */
	PushPull_PSP_Diagnostics_Data_Update(&EST7);
}
void EST7_Diagnostic_Trigger(void)
{
    PushPull_PSP_Diagnostics_Data_Update(&EST7);
}
uint16_T EST7_Diagnostic_Data_ADCValue_Get(void)
{
    S_PushPullDiagnosticsReport Report;

    PushPull_PSP_Diagnostics_Data_Get(&EST7, &Report);

    return ((uint16_T)Report.uADCValue);
}

extern S_PrimaryEncoderDefn_CPU const CNK_CPUEncoder;



INSTANTIATE_PushPullWithAnalogDiagnostics_PSP(EST8,                                                          
	/* Ctrl Signal Definition. A BasicOut_PSP Object */                                                
	CPUCore_0, CPU, ETPU_A10_K3, ETPU,
	RES_POL_ACTIVE_HIGH,
    &CNK_CPUEncoder, /* pCPUEncoderPinDefn */
    NULL, /* pEncoderSystemDefn */
	1, 1,
	0, /* End of event ISR */
	OUTPUT_IS_NON_INVERTING,
		
	/* Disable Signal Definition. A BasicOut_DiscreteOut Object */
	CPUCore_0, CPU, GPIO_193_AF19, GPIO,
	RES_POL_ACTIVE_HIGH,
	OUTPUT_IS_NON_INVERTING,

	/* Analog Feedback Definition */                                            
	NULL,                                        /* Diagnostics ISR   */                                            
	&GET_NAME_QADC_QUEUE_CPUISR_OBJ(ESTDiagnostics_eQADCQueue),    /* QADC Queue Object */                                            
	7);                                                       /* Where in the queue the result can be found. */
void EST8_PSPOutput_Create(void)
{
	S_PushPull_Create_PSP PushPullCreate;

	/* Configure the circuit First */
	PushPullCreate.CircuitCreate.uValidAttributesMask = PUSHPULL_USE_DEFAULTS;

	/* Configure the BasicOut PSP Object */
	PushPullCreate.CtrlCreateAttribs.CircuitCreate.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	PushPullCreate.CtrlCreateAttribs.BehaviorCreateAttribs.uValidAttributesMask = USE_PSP_DEFAULTS;
	

	/* Configure the BasicOut Discrete Object */
	PushPullCreate.DisableCreateAttributes.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	PushPullCreate.DisableCreateAttributes.Create.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	PushPullCreate.DisableCreateAttributes.DiscreteOutCreateAttribs.eInitialState = RES_OFF;

	PushPull_PSP_Create(&EST8, &PushPullCreate);
	
	/* Trigger an initial Scan */
	PushPull_PSP_Diagnostics_Data_Update(&EST8);
}
void EST8_Diagnostic_Trigger(void)
{
    PushPull_PSP_Diagnostics_Data_Update(&EST8);
}
uint16_T EST8_Diagnostic_Data_ADCValue_Get(void)
{
    S_PushPullDiagnosticsReport Report;

    PushPull_PSP_Diagnostics_Data_Get(&EST8, &Report);

    return ((uint16_T)Report.uADCValue);
}

INSTANTIATE_MC33800Output_DiscreteOut(MC33800_INJ1,
	MC33800_PWM1,
	PWM,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_3);
void MC33800_INJ1_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_INPUT;
	
	MC33800_DiscreteOut_Create(&MC33800_INJ1, &CreateObj);
}

#include <Pragma_Section_Start_CoreIndependent_data.h>

extern S_PrimaryEncoderDefn_CPU const CNK_CPUEncoder;


INSTANTIATE_BasicOut_PSP(INJ1,
	CPUCore_0, CPU, ETPU_A16_J1, ETPU,
	RES_POL_ACTIVE_HIGH,
	&CNK_CPUEncoder,
    /* pEncoderSystemDefn */
	NULL,
	2, 1,
	INJ1_PSPOutput_OnPulseEnd_Callback, /* End of event ISR */
	OUTPUT_IS_NON_INVERTING);

#include <Pragma_Section_End_data.h>
void INJ1_PSPOutput_Create(void)
{
	S_BasicOut_Create_PSP CreateObj;
	
	CreateObj.CircuitCreate.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	CreateObj.BehaviorCreateAttribs.uValidAttributesMask = USE_PSP_DEFAULTS;
	
	BasicOut_PSP_Create(&INJ1, &CreateObj);
}

INSTANTIATE_MC33800Output_DiscreteOut(MC33800_INJ2,
	MC33800_PWM2,
	PWM,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_3);
void MC33800_INJ2_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_INPUT;
	
	MC33800_DiscreteOut_Create(&MC33800_INJ2, &CreateObj);
}

#include <Pragma_Section_Start_CoreIndependent_data.h>

extern S_PrimaryEncoderDefn_CPU const CNK_CPUEncoder;


INSTANTIATE_BasicOut_PSP(INJ2,
	CPUCore_0, CPU, ETPU_A17_H4, ETPU,
	RES_POL_ACTIVE_HIGH,
	&CNK_CPUEncoder,
    /* pEncoderSystemDefn */
	NULL,
	2, 1,
	INJ2_PSPOutput_OnPulseEnd_Callback, /* End of event ISR */
	OUTPUT_IS_NON_INVERTING);

#include <Pragma_Section_End_data.h>
void INJ2_PSPOutput_Create(void)
{
	S_BasicOut_Create_PSP CreateObj;
	
	CreateObj.CircuitCreate.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	CreateObj.BehaviorCreateAttribs.uValidAttributesMask = USE_PSP_DEFAULTS;
	
	BasicOut_PSP_Create(&INJ2, &CreateObj);
}

INSTANTIATE_MC33800Output_DiscreteOut(MC33800_INJ3,
	MC33800_PWM3,
	PWM,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_3);
void MC33800_INJ3_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_INPUT;
	
	MC33800_DiscreteOut_Create(&MC33800_INJ3, &CreateObj);
}

#include <Pragma_Section_Start_CoreIndependent_data.h>

extern S_PrimaryEncoderDefn_CPU const CNK_CPUEncoder;


INSTANTIATE_BasicOut_PSP(INJ3,
	CPUCore_0, CPU, ETPU_A18_H3, ETPU,
	RES_POL_ACTIVE_HIGH,
	&CNK_CPUEncoder,
    /* pEncoderSystemDefn */
	NULL,
	2, 1,
	INJ3_PSPOutput_OnPulseEnd_Callback, /* End of event ISR */
	OUTPUT_IS_NON_INVERTING);

#include <Pragma_Section_End_data.h>
void INJ3_PSPOutput_Create(void)
{
	S_BasicOut_Create_PSP CreateObj;
	
	CreateObj.CircuitCreate.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	CreateObj.BehaviorCreateAttribs.uValidAttributesMask = USE_PSP_DEFAULTS;
	
	BasicOut_PSP_Create(&INJ3, &CreateObj);
}

INSTANTIATE_MC33800Output_DiscreteOut(MC33800_INJ4,
	MC33800_PWM4,
	PWM,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_3);
void MC33800_INJ4_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_INPUT;
	
	MC33800_DiscreteOut_Create(&MC33800_INJ4, &CreateObj);
}

#include <Pragma_Section_Start_CoreIndependent_data.h>

extern S_PrimaryEncoderDefn_CPU const CNK_CPUEncoder;


INSTANTIATE_BasicOut_PSP(INJ4,
	CPUCore_0, CPU, ETPU_A19_H2, ETPU,
	RES_POL_ACTIVE_HIGH,
	&CNK_CPUEncoder,
    /* pEncoderSystemDefn */
	NULL,
	2, 1,
	INJ4_PSPOutput_OnPulseEnd_Callback, /* End of event ISR */
	OUTPUT_IS_NON_INVERTING);

#include <Pragma_Section_End_data.h>
void INJ4_PSPOutput_Create(void)
{
	S_BasicOut_Create_PSP CreateObj;
	
	CreateObj.CircuitCreate.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	CreateObj.BehaviorCreateAttribs.uValidAttributesMask = USE_PSP_DEFAULTS;
	
	BasicOut_PSP_Create(&INJ4, &CreateObj);
}

INSTANTIATE_MC33800Output_DiscreteOut(MC33800_INJ5,
	MC33800_PWM1,
	PWM,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_4);
void MC33800_INJ5_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_INPUT;
	
	MC33800_DiscreteOut_Create(&MC33800_INJ5, &CreateObj);
}

#include <Pragma_Section_Start_CoreIndependent_data.h>

extern S_PrimaryEncoderDefn_CPU const CNK_CPUEncoder;


INSTANTIATE_BasicOut_PSP(INJ5,
	CPUCore_0, CPU, ETPU_A20_H1, ETPU,
	RES_POL_ACTIVE_HIGH,
	&CNK_CPUEncoder,
    /* pEncoderSystemDefn */
	NULL,
	2, 1,
	INJ5_PSPOutput_OnPulseEnd_Callback, /* End of event ISR */
	OUTPUT_IS_NON_INVERTING);

#include <Pragma_Section_End_data.h>
void INJ5_PSPOutput_Create(void)
{
	S_BasicOut_Create_PSP CreateObj;
	
	CreateObj.CircuitCreate.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	CreateObj.BehaviorCreateAttribs.uValidAttributesMask = USE_PSP_DEFAULTS;
	
	BasicOut_PSP_Create(&INJ5, &CreateObj);
}

INSTANTIATE_MC33800Output_DiscreteOut(MC33800_INJ6,
	MC33800_PWM2,
	PWM,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_4);
void MC33800_INJ6_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_INPUT;
	
	MC33800_DiscreteOut_Create(&MC33800_INJ6, &CreateObj);
}

#include <Pragma_Section_Start_CoreIndependent_data.h>

extern S_PrimaryEncoderDefn_CPU const CNK_CPUEncoder;


INSTANTIATE_BasicOut_PSP(INJ6,
	CPUCore_0, CPU, ETPU_A21_G4, ETPU,
	RES_POL_ACTIVE_HIGH,
	&CNK_CPUEncoder,
    /* pEncoderSystemDefn */
	NULL,
	2, 1,
	INJ6_PSPOutput_OnPulseEnd_Callback, /* End of event ISR */
	OUTPUT_IS_NON_INVERTING);

#include <Pragma_Section_End_data.h>
void INJ6_PSPOutput_Create(void)
{
	S_BasicOut_Create_PSP CreateObj;
	
	CreateObj.CircuitCreate.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	CreateObj.BehaviorCreateAttribs.uValidAttributesMask = USE_PSP_DEFAULTS;
	
	BasicOut_PSP_Create(&INJ6, &CreateObj);
}

INSTANTIATE_MC33800Output_DiscreteOut(MC33800_INJ7,
	MC33800_PWM3,
	PWM,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_4);
void MC33800_INJ7_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_INPUT;
	
	MC33800_DiscreteOut_Create(&MC33800_INJ7, &CreateObj);
}

#include <Pragma_Section_Start_CoreIndependent_data.h>

extern S_PrimaryEncoderDefn_CPU const CNK_CPUEncoder;


INSTANTIATE_BasicOut_PSP(INJ7,
	CPUCore_0, CPU, ETPU_A22_G2, ETPU,
	RES_POL_ACTIVE_HIGH,
	&CNK_CPUEncoder,
    /* pEncoderSystemDefn */
	NULL,
	2, 1,
	INJ7_PSPOutput_OnPulseEnd_Callback, /* End of event ISR */
	OUTPUT_IS_NON_INVERTING);

#include <Pragma_Section_End_data.h>
void INJ7_PSPOutput_Create(void)
{
	S_BasicOut_Create_PSP CreateObj;
	
	CreateObj.CircuitCreate.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	CreateObj.BehaviorCreateAttribs.uValidAttributesMask = USE_PSP_DEFAULTS;
	
	BasicOut_PSP_Create(&INJ7, &CreateObj);
}

INSTANTIATE_MC33800Output_DiscreteOut(MC33800_INJ8,
	MC33800_PWM4,
	PWM,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_4);
void MC33800_INJ8_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_INPUT;
	
	MC33800_DiscreteOut_Create(&MC33800_INJ8, &CreateObj);
}

#include <Pragma_Section_Start_CoreIndependent_data.h>

extern S_PrimaryEncoderDefn_CPU const CNK_CPUEncoder;


INSTANTIATE_BasicOut_PSP(INJ8,
	CPUCore_0, CPU, ETPU_A23_G1, ETPU,
	RES_POL_ACTIVE_HIGH,
	&CNK_CPUEncoder,
    /* pEncoderSystemDefn */
	NULL,
	2, 1,
	INJ8_PSPOutput_OnPulseEnd_Callback, /* End of event ISR */
	OUTPUT_IS_NON_INVERTING);

#include <Pragma_Section_End_data.h>
void INJ8_PSPOutput_Create(void)
{
	S_BasicOut_Create_PSP CreateObj;
	
	CreateObj.CircuitCreate.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	CreateObj.BehaviorCreateAttribs.uValidAttributesMask = USE_PSP_DEFAULTS;
	
	BasicOut_PSP_Create(&INJ8, &CreateObj);
}

INSTANTIATE_SPI_MODULE_DEFN(
		SPI_D,
		DSPI_D,
        1);
void SPI_D_Create(void)
{
	INSTANTIATE_SPI_MODULE_ATTRIBUTES(SPI_D_,
		DSPI_D,
		1,
		0,
		USE_SPI_CS0 | USE_SPI_CS2);

	SPI_D.pMethods->pfnCreate(&SPI_D, &SPI_D_Attrib);
}

INSTANTIATE_SerialEE(EEPROM_1,
                     M95256,
                     0xFF000000,
                     SPI_D,
                     USE_SPI_CS0,
                     NULL,
                     0,
                     2000000,
                     SERIAL_EE_INTERFACE_SYNCHONLY,
                     1,
                     0);
void EEPROM_1_Create(void)
{
	SerialEE_Create(&EEPROM_1);
}

void MotoCoder_DiscreteOutput_UpdateOnChange_Create(S_BasicOut_Defn_DiscreteOut const* const in_pDefn, E_ResourceState* const in_peState, E_ResourceState in_eInitialState)
{
	S_BasicOut_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	CreateObj.Create.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	CreateObj.DiscreteOutCreateAttribs.eInitialState = in_eInitialState;

    /* Cache state because UseUpdateOnlyOnChange was true */
    *in_peState = CreateObj.DiscreteOutCreateAttribs.eInitialState;
	BasicOut_DiscreteOut_Create(in_pDefn, &CreateObj);
}
void MotoCoder_DiscreteOutput_UpdateOnChange_Set(S_BasicOut_Defn_DiscreteOut const* const in_pDefn, 
                                                         E_ResourceState* const in_peState,
                                                         boolean_T value)
{
    E_ResourceState eState;

	eState = value ? RES_ON : RES_OFF;
    Interrupt_DisableApp();
    if ((*in_peState & 0x80) == 0)
    {   /* Object is not currently undergoing modification */
        if (*in_peState != eState)
        {
            *in_peState = eState | 0x80;
            Interrupt_EnableApp();
            BasicOut_DiscreteOut_State_Set(in_pDefn, eState);
            Interrupt_DisableApp();
            *in_peState = *in_peState & 0x7F;
        }
    }
    else
    {
        /* Another thread is already modifying this object so ignore this request */
    }
    Interrupt_EnableApp();
}
void MotoCoder_DiscreteOutput_UpdateOnChange_Stop(S_BasicOut_Defn_DiscreteOut const* const in_pDefn, E_ResourceState* const in_peState)
{
    /* IO Stop is called on shutdown. It should override the state being set by another thread.
       The expectation is that normal operation shall not resume without effectively restarting the code */
    *in_peState = RES_OFF;
	BasicOut_DiscreteOut_State_Set(in_pDefn, RES_OFF);
}

    
    

#include <Pragma_Section_Start_SDA.h>
E_ResourceState DOut11001p0004_State;
#include <Pragma_Section_End_SDA.h>
NativeError_S DOut11001p0004_DiscreteOutput_Get(boolean_T* const out_pValue)
{
    if (FALSE == RES_OFF)
    {   /* Optimized return function can be used because enum states match with boolean*/
        *out_pValue = (boolean_T)DOut11001p0004_State;
    }
    else if (DOut11001p0004_State == RES_OFF)
    {
        *out_pValue = FALSE;
    }
    else /* if (DOut11001p0004_State == RES_ON) */
    {
        *out_pValue = TRUE;
    }
    return(SUCCESS_OK);
}


INSTANTIATE_BasicOut_DiscreteOut(DOut11001p0004,
                                 CPUCore_0, 
                                 CPU, 
                                 GPIO_138_F1, 
                                 GPIO,
                                 RES_POL_ACTIVE_HIGH,
                                 OUTPUT_IS_NON_INVERTING);
void DOut11001p0004_DiscreteOutput_Create(void)
{
	MotoCoder_DiscreteOutput_UpdateOnChange_Create(&DOut11001p0004, &DOut11001p0004_State, RES_OFF);
}
void DOut11001p0004_DiscreteOutput_Set(boolean_T value)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Set(&DOut11001p0004,
                                                &DOut11001p0004_State,
                                                value);
}
void DOut11001p0004_DiscreteOutput_Stop(void)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Stop(&DOut11001p0004, &DOut11001p0004_State);
}
    
    

#include <Pragma_Section_Start_SDA.h>
E_ResourceState DOut11529p0004_State;
#include <Pragma_Section_End_SDA.h>
NativeError_S DOut11529p0004_DiscreteOutput_Get(boolean_T* const out_pValue)
{
    if (FALSE == RES_OFF)
    {   /* Optimized return function can be used because enum states match with boolean*/
        *out_pValue = (boolean_T)DOut11529p0004_State;
    }
    else if (DOut11529p0004_State == RES_OFF)
    {
        *out_pValue = FALSE;
    }
    else /* if (DOut11529p0004_State == RES_ON) */
    {
        *out_pValue = TRUE;
    }
    return(SUCCESS_OK);
}


INSTANTIATE_BasicOut_DiscreteOut(DOut11529p0004,
                                 CPUCore_0, 
                                 CPU, 
                                 GPIO_198_AE20, 
                                 GPIO,
                                 RES_POL_ACTIVE_HIGH,
                                 OUTPUT_IS_NON_INVERTING);
void DOut11529p0004_DiscreteOutput_Create(void)
{
	MotoCoder_DiscreteOutput_UpdateOnChange_Create(&DOut11529p0004, &DOut11529p0004_State, RES_OFF);
}
void DOut11529p0004_DiscreteOutput_Set(boolean_T value)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Set(&DOut11529p0004,
                                                &DOut11529p0004_State,
                                                value);
}
void DOut11529p0004_DiscreteOutput_Stop(void)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Stop(&DOut11529p0004, &DOut11529p0004_State);
}
    
    

#include <Pragma_Section_Start_SDA.h>
E_ResourceState H2_InhibitA_State;
#include <Pragma_Section_End_SDA.h>
NativeError_S H2_InhibitA_DiscreteOutput_Get(boolean_T* const out_pValue)
{
    if (FALSE == RES_OFF)
    {   /* Optimized return function can be used because enum states match with boolean*/
        *out_pValue = (boolean_T)H2_InhibitA_State;
    }
    else if (H2_InhibitA_State == RES_OFF)
    {
        *out_pValue = FALSE;
    }
    else /* if (H2_InhibitA_State == RES_ON) */
    {
        *out_pValue = TRUE;
    }
    return(SUCCESS_OK);
}


INSTANTIATE_BasicOut_DiscreteOut(H2_InhibitA,
                                 CPUCore_0, 
                                 CPU, 
                                 GPIO_153_L23, 
                                 GPIO,
                                 RES_POL_ACTIVE_HIGH,
                                 OUTPUT_IS_NON_INVERTING);
void H2_InhibitA_DiscreteOutput_Create(void)
{
	MotoCoder_DiscreteOutput_UpdateOnChange_Create(&H2_InhibitA, &H2_InhibitA_State, RES_OFF);
}
void H2_InhibitA_DiscreteOutput_Set(boolean_T value)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Set(&H2_InhibitA,
                                                &H2_InhibitA_State,
                                                value);
}
void H2_InhibitA_DiscreteOutput_Stop(void)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Stop(&H2_InhibitA, &H2_InhibitA_State);
}
    
    

#include <Pragma_Section_Start_SDA.h>
E_ResourceState H2_InhibitB_State;
#include <Pragma_Section_End_SDA.h>
NativeError_S H2_InhibitB_DiscreteOutput_Get(boolean_T* const out_pValue)
{
    if (FALSE == RES_OFF)
    {   /* Optimized return function can be used because enum states match with boolean*/
        *out_pValue = (boolean_T)H2_InhibitB_State;
    }
    else if (H2_InhibitB_State == RES_OFF)
    {
        *out_pValue = FALSE;
    }
    else /* if (H2_InhibitB_State == RES_ON) */
    {
        *out_pValue = TRUE;
    }
    return(SUCCESS_OK);
}


INSTANTIATE_BasicOut_DiscreteOut(H2_InhibitB,
                                 CPUCore_0, 
                                 CPU, 
                                 GPIO_154_K25, 
                                 GPIO,
                                 RES_POL_ACTIVE_HIGH,
                                 OUTPUT_IS_NON_INVERTING);
void H2_InhibitB_DiscreteOutput_Create(void)
{
	MotoCoder_DiscreteOutput_UpdateOnChange_Create(&H2_InhibitB, &H2_InhibitB_State, RES_OFF);
}
void H2_InhibitB_DiscreteOutput_Set(boolean_T value)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Set(&H2_InhibitB,
                                                &H2_InhibitB_State,
                                                value);
}
void H2_InhibitB_DiscreteOutput_Stop(void)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Stop(&H2_InhibitB, &H2_InhibitB_State);
}
void MotoCoder_DiscreteOutput_UpdateAlways_Create(S_BasicOut_Defn_DiscreteOut const* const in_pDefn, E_ResourceState in_eInitialState)
{
	S_BasicOut_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	CreateObj.Create.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	CreateObj.DiscreteOutCreateAttribs.eInitialState = in_eInitialState;
	BasicOut_DiscreteOut_Create(in_pDefn, &CreateObj);
}
    
    

INSTANTIATE_BasicOut_DiscreteOut(CNKPullup,
                                 VISTA_1, 
                                 VISTA, 
                                 GPO_VISTA_PWM0_GPIO0, 
                                 GPIO,
                                 RES_POL_ACTIVE_HIGH,
                                 OUTPUT_IS_INVERTING);
void CNKPullup_DiscreteOutput_Create(void)
{
	MotoCoder_DiscreteOutput_UpdateAlways_Create(&CNKPullup, RES_ON);
}
NativeError_S CNKPullup_DiscreteOutput_Get(boolean_T* const out_pValue)
{
    NativeError_S sError;
    E_ResourceState eState = RES_OFF;

    sError = BasicOut_DiscreteOut_State_Get(&CNKPullup, &eState);
    if (RES_OFF == FALSE)
    {   /* Optimized return function can be used because enum states match with boolean */
        *out_pValue = (boolean_T)eState;
    }
    else if (eState == RES_OFF)
    {
        *out_pValue = FALSE;
    }
    else
    {   /* RES_ON */
        *out_pValue = TRUE;
    }
    return(sError);
}


    
    

INSTANTIATE_BasicOut_DiscreteOut(ODRC,
                                 CPUCore_0, 
                                 CPU, 
                                 GPIO_208_AB25, 
                                 GPIO,
                                 RES_POL_ACTIVE_LOW,
                                 OUTPUT_IS_NON_INVERTING);
void ODRC_DiscreteOutput_Create(void)
{
	MotoCoder_DiscreteOutput_UpdateAlways_Create(&ODRC, RES_ON);
}
NativeError_S ODRC_DiscreteOutput_Get(boolean_T* const out_pValue)
{
    NativeError_S sError;
    E_ResourceState eState = RES_OFF;

    sError = BasicOut_DiscreteOut_State_Get(&ODRC, &eState);
    if (RES_OFF == FALSE)
    {   /* Optimized return function can be used because enum states match with boolean */
        *out_pValue = (boolean_T)eState;
    }
    else if (eState == RES_OFF)
    {
        *out_pValue = FALSE;
    }
    else
    {   /* RES_ON */
        *out_pValue = TRUE;
    }
    return(sError);
}


    
    

INSTANTIATE_BasicOut_DiscreteOut(SPD1Pullup,
                                 VISTA_1, 
                                 VISTA, 
                                 GPO_VISTA_PWM2_GPIO2, 
                                 GPIO,
                                 RES_POL_ACTIVE_HIGH,
                                 OUTPUT_IS_INVERTING);
void SPD1Pullup_DiscreteOutput_Create(void)
{
	MotoCoder_DiscreteOutput_UpdateAlways_Create(&SPD1Pullup, RES_ON);
}
NativeError_S SPD1Pullup_DiscreteOutput_Get(boolean_T* const out_pValue)
{
    NativeError_S sError;
    E_ResourceState eState = RES_OFF;

    sError = BasicOut_DiscreteOut_State_Get(&SPD1Pullup, &eState);
    if (RES_OFF == FALSE)
    {   /* Optimized return function can be used because enum states match with boolean */
        *out_pValue = (boolean_T)eState;
    }
    else if (eState == RES_OFF)
    {
        *out_pValue = FALSE;
    }
    else
    {   /* RES_ON */
        *out_pValue = TRUE;
    }
    return(sError);
}


    
    

INSTANTIATE_BasicOut_DiscreteOut(CAMPullup,
                                 VISTA_1, 
                                 VISTA, 
                                 GPO_VISTA_PWM1_GPIO1, 
                                 GPIO,
                                 RES_POL_ACTIVE_HIGH,
                                 OUTPUT_IS_INVERTING);
void CAMPullup_DiscreteOutput_Create(void)
{
	MotoCoder_DiscreteOutput_UpdateAlways_Create(&CAMPullup, RES_ON);
}
NativeError_S CAMPullup_DiscreteOutput_Get(boolean_T* const out_pValue)
{
    NativeError_S sError;
    E_ResourceState eState = RES_OFF;

    sError = BasicOut_DiscreteOut_State_Get(&CAMPullup, &eState);
    if (RES_OFF == FALSE)
    {   /* Optimized return function can be used because enum states match with boolean */
        *out_pValue = (boolean_T)eState;
    }
    else if (eState == RES_OFF)
    {
        *out_pValue = FALSE;
    }
    else
    {   /* RES_ON */
        *out_pValue = TRUE;
    }
    return(sError);
}

/* Create all I/O resources */
void IO_Create(void)
{

    {extern void eTPU_Startup(void);
        eTPU_Startup();
    }
    {extern void CAN_1_Create(void);
        CAN_1_Create();
    }
    {extern void CAN_2_Create(void);
        CAN_2_Create();
    }
    {extern void SPI_B_Create(void);
        SPI_B_Create();
    }
    {extern void VISTA_1_Create(void);
        VISTA_1_Create();
    }
    {extern void CNKPullup_DiscreteOutput_Create(void);
        CNKPullup_DiscreteOutput_Create();
    }
    {extern void CNK_Encoder_Create(void);
        CNK_Encoder_Create();
    }
    {extern void ESTOPPin_DigitalInput_Create(void);
        ESTOPPin_DigitalInput_Create();
    }
    {extern void SPI_C_Create(void);
        SPI_C_Create();
    }
    {extern void ODRC_DiscreteOutput_Create(void);
        ODRC_DiscreteOutput_Create();
    }
    {extern void S_SHRC_3_Create(void);
        S_SHRC_3_Create();
    }
    {extern void DOut10176p0004_DiscreteOutput_Create(void);
        DOut10176p0004_DiscreteOutput_Create();
    }
    {extern void MC33800_LSO2_DiscreteOutput_Create(void);
        MC33800_LSO2_DiscreteOutput_Create();
    }
    {extern void DOut11001p0004_DiscreteOutput_Create(void);
        DOut11001p0004_DiscreteOutput_Create();
    }
    {extern void MC33800_MPRD_DiscreteOutput_Create(void);
        MC33800_MPRD_DiscreteOutput_Create();
    }
    {extern void DOut11529p0004_DiscreteOutput_Create(void);
        DOut11529p0004_DiscreteOutput_Create();
    }
    {extern void RS485_SerialLink_Create(void);
        RS485_SerialLink_Create();
    }
    {extern void eQADC_A_B_eQADCModule_Create(void);
        eQADC_A_B_eQADCModule_Create();
    }
    {extern void ContinuousScan_eQADCQueue_Create(void);
        ContinuousScan_eQADCQueue_Create();
    }
    {extern void MAPSensorPin_Create(void);
        MAPSensorPin_Create();
    }
    {extern void DRVP_Create(void);
        DRVP_Create();
    }
    {extern void XDRP_Create(void);
        XDRP_Create();
    }
    {extern void AN12_Create(void);
        AN12_Create();
    }
    {extern void AN13_Create(void);
        AN13_Create();
    }
    {extern void SPD1Pullup_DiscreteOutput_Create(void);
        SPD1Pullup_DiscreteOutput_Create();
    }
    {extern void SPD1_FrequencyInput_Create(void);
        SPD1_FrequencyInput_Create();
    }
    {extern void SPD2_FrequencyInput_Create(void);
        SPD2_FrequencyInput_Create();
    }
    {extern void SPD3_FrequencyInput_Create(void);
        SPD3_FrequencyInput_Create();
    }
    {extern void S_SHRC_4_Create(void);
        S_SHRC_4_Create();
    }
    {extern void MC33800_LSO9_DiscreteOutput_Create(void);
        MC33800_LSO9_DiscreteOutput_Create();
    }
    {extern void LSO9_PWMOutput_PWMOutput_Create(void);
        LSO9_PWMOutput_PWMOutput_Create();
    }
    {extern void MC33800_LSO10_DiscreteOutput_Create(void);
        MC33800_LSO10_DiscreteOutput_Create();
    }
    {extern void LSO10_PWMOutput_PWMOutput_Create(void);
        LSO10_PWMOutput_PWMOutput_Create();
    }
    {extern void H1p_PWMOutput_Create(void);
        H1p_PWMOutput_Create();
    }
    {extern void H1m_PWMOutput_Create(void);
        H1m_PWMOutput_Create();
    }
    {extern void H1_InhibitA_PWMOutput_Create(void);
        H1_InhibitA_PWMOutput_Create();
    }
    {extern void H1_InhibitB_PWMOutput_Create(void);
        H1_InhibitB_PWMOutput_Create();
    }
    {extern void H1p_H1m_PWMOutput_Create(void);
        H1p_H1m_PWMOutput_Create();
    }
    {extern void H2p_PWMOutput_Create(void);
        H2p_PWMOutput_Create();
    }
    {extern void H2_InhibitA_DiscreteOutput_Create(void);
        H2_InhibitA_DiscreteOutput_Create();
    }
    {extern void H2m_PWMOutput_Create(void);
        H2m_PWMOutput_Create();
    }
    {extern void H2_InhibitB_DiscreteOutput_Create(void);
        H2_InhibitB_DiscreteOutput_Create();
    }
    {extern void MC33800_LSO8_DiscreteOutput_Create(void);
        MC33800_LSO8_DiscreteOutput_Create();
    }
    {extern void LSO8_PWMOutput_PWMOutput_Create(void);
        LSO8_PWMOutput_PWMOutput_Create();
    }
    {extern void CAMPullup_DiscreteOutput_Create(void);
        CAMPullup_DiscreteOutput_Create();
    }
    {extern void CAM_Encoder_Create(void);
        CAM_Encoder_Create();
    }
    {extern void ESTDiagnostics_eQADCQueue_Create(void);
        ESTDiagnostics_eQADCQueue_Create();
    }
    {extern void EST1_PSPOutput_Create(void);
        EST1_PSPOutput_Create();
    }
    {extern void EST2_PSPOutput_Create(void);
        EST2_PSPOutput_Create();
    }
    {extern void EST3_PSPOutput_Create(void);
        EST3_PSPOutput_Create();
    }
    {extern void EST4_PSPOutput_Create(void);
        EST4_PSPOutput_Create();
    }
    {extern void EST5_PSPOutput_Create(void);
        EST5_PSPOutput_Create();
    }
    {extern void EST6_PSPOutput_Create(void);
        EST6_PSPOutput_Create();
    }
    {extern void EST7_PSPOutput_Create(void);
        EST7_PSPOutput_Create();
    }
    {extern void EST8_PSPOutput_Create(void);
        EST8_PSPOutput_Create();
    }
    {extern void MC33800_INJ1_DiscreteOutput_Create(void);
        MC33800_INJ1_DiscreteOutput_Create();
    }
    {extern void INJ1_PSPOutput_Create(void);
        INJ1_PSPOutput_Create();
    }
    {extern void MC33800_INJ2_DiscreteOutput_Create(void);
        MC33800_INJ2_DiscreteOutput_Create();
    }
    {extern void INJ2_PSPOutput_Create(void);
        INJ2_PSPOutput_Create();
    }
    {extern void MC33800_INJ3_DiscreteOutput_Create(void);
        MC33800_INJ3_DiscreteOutput_Create();
    }
    {extern void INJ3_PSPOutput_Create(void);
        INJ3_PSPOutput_Create();
    }
    {extern void MC33800_INJ4_DiscreteOutput_Create(void);
        MC33800_INJ4_DiscreteOutput_Create();
    }
    {extern void INJ4_PSPOutput_Create(void);
        INJ4_PSPOutput_Create();
    }
    {extern void MC33800_INJ5_DiscreteOutput_Create(void);
        MC33800_INJ5_DiscreteOutput_Create();
    }
    {extern void INJ5_PSPOutput_Create(void);
        INJ5_PSPOutput_Create();
    }
    {extern void MC33800_INJ6_DiscreteOutput_Create(void);
        MC33800_INJ6_DiscreteOutput_Create();
    }
    {extern void INJ6_PSPOutput_Create(void);
        INJ6_PSPOutput_Create();
    }
    {extern void MC33800_INJ7_DiscreteOutput_Create(void);
        MC33800_INJ7_DiscreteOutput_Create();
    }
    {extern void INJ7_PSPOutput_Create(void);
        INJ7_PSPOutput_Create();
    }
    {extern void MC33800_INJ8_DiscreteOutput_Create(void);
        MC33800_INJ8_DiscreteOutput_Create();
    }
    {extern void INJ8_PSPOutput_Create(void);
        INJ8_PSPOutput_Create();
    }
    {extern void SPI_D_Create(void);
        SPI_D_Create();
    }
    {extern void EEPROM_1_Create(void);
        EEPROM_1_Create();
    }
}

/* Stop all I/O by putting each resource into a safe state */
void IO_Stop(void)
{
	
    {extern void DOut10176p0004_DiscreteOutput_Stop(void);
        DOut10176p0004_DiscreteOutput_Stop();
    }
    {extern void DOut11001p0004_DiscreteOutput_Stop(void);
        DOut11001p0004_DiscreteOutput_Stop();
    }
    {extern void DOut11529p0004_DiscreteOutput_Stop(void);
        DOut11529p0004_DiscreteOutput_Stop();
    }
    {extern void LSO9_PWMOutput_PWMOutput_Stop(void);
        LSO9_PWMOutput_PWMOutput_Stop();
    }
    {extern void LSO10_PWMOutput_PWMOutput_Stop(void);
        LSO10_PWMOutput_PWMOutput_Stop();
    }
    {extern void H1p_PWMOutput_Stop(void);
        H1p_PWMOutput_Stop();
    }
    {extern void H1m_PWMOutput_Stop(void);
        H1m_PWMOutput_Stop();
    }
    {extern void H1_InhibitA_PWMOutput_Stop(void);
        H1_InhibitA_PWMOutput_Stop();
    }
    {extern void H1_InhibitB_PWMOutput_Stop(void);
        H1_InhibitB_PWMOutput_Stop();
    }
    {extern void H1p_H1m_PWMOutput_Stop(void);
        H1p_H1m_PWMOutput_Stop();
    }
    {extern void H2p_PWMOutput_Stop(void);
        H2p_PWMOutput_Stop();
    }
    {extern void H2_InhibitA_DiscreteOutput_Stop(void);
        H2_InhibitA_DiscreteOutput_Stop();
    }
    {extern void H2p_PWMOutput_PWMOutput_Stop(void);
        H2p_PWMOutput_PWMOutput_Stop();
    }
    {extern void H2m_PWMOutput_Stop(void);
        H2m_PWMOutput_Stop();
    }
    {extern void H2_InhibitB_DiscreteOutput_Stop(void);
        H2_InhibitB_DiscreteOutput_Stop();
    }
    {extern void H2m_PWMOutput_PWMOutput_Stop(void);
        H2m_PWMOutput_PWMOutput_Stop();
    }
    {extern void LSO8_PWMOutput_PWMOutput_Stop(void);
        LSO8_PWMOutput_PWMOutput_Stop();
    }
    {extern void EST1_PSPOutput_Stop(void);
        EST1_PSPOutput_Stop();
    }
    {extern void EST2_PSPOutput_Stop(void);
        EST2_PSPOutput_Stop();
    }
    {extern void EST3_PSPOutput_Stop(void);
        EST3_PSPOutput_Stop();
    }
    {extern void EST4_PSPOutput_Stop(void);
        EST4_PSPOutput_Stop();
    }
    {extern void EST5_PSPOutput_Stop(void);
        EST5_PSPOutput_Stop();
    }
    {extern void EST6_PSPOutput_Stop(void);
        EST6_PSPOutput_Stop();
    }
    {extern void EST7_PSPOutput_Stop(void);
        EST7_PSPOutput_Stop();
    }
    {extern void EST8_PSPOutput_Stop(void);
        EST8_PSPOutput_Stop();
    }
    {extern void INJ1_PSPOutput_Stop(void);
        INJ1_PSPOutput_Stop();
    }
    {extern void INJ2_PSPOutput_Stop(void);
        INJ2_PSPOutput_Stop();
    }
    {extern void INJ3_PSPOutput_Stop(void);
        INJ3_PSPOutput_Stop();
    }
    {extern void INJ4_PSPOutput_Stop(void);
        INJ4_PSPOutput_Stop();
    }
    {extern void INJ5_PSPOutput_Stop(void);
        INJ5_PSPOutput_Stop();
    }
    {extern void INJ6_PSPOutput_Stop(void);
        INJ6_PSPOutput_Stop();
    }
    {extern void INJ7_PSPOutput_Stop(void);
        INJ7_PSPOutput_Stop();
    }
    {extern void INJ8_PSPOutput_Stop(void);
        INJ8_PSPOutput_Stop();
    }
}




/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Accessors for EST1
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void EST1_PSPOutput_Condition_Set(uint8_T pulse, uint8_T state)
{
    PushPull_PSP_Condition_Set(&EST1, pulse, state);
}

static boolean_T EST1_PSPOutput_PrevCondition[ 1 ] = {0};
void EST1_PSPOutput_HardStart_HardStop_Set(uint8_T pulse, uint8_T state, int16_T startAngle, int16_T stopAngle, uint32_T maxDuration)
{
    U_PSPTiming_CPU TimingObj;
    TimingObj.HardStart.sStartAngle = startAngle;
    TimingObj.HardStart.sHardStopAngle = stopAngle;
    TimingObj.HardStart.uHardDuration_uS = maxDuration;

    /* Apply the timings first so that a change in the condition does not occur before valid data has been installed into the output */
    
    
    PushPull_PSP_Timing_Set(&EST1, (NativeVar_U) pulse, PSP_HARDSTART_HARDSTOP, &TimingObj,
    PSP_TIMING_IMMEDIATE_UPDATE );

    if (state != EST1_PSPOutput_PrevCondition[pulse]) {
        PushPull_PSP_Condition_Set(&EST1, (NativeVar_U) pulse, (E_PSPResourceCond) state);
        EST1_PSPOutput_PrevCondition[pulse] = state;
    }
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: EST1_PSPOutput_MinDisplacementForPulseScheduling_Get
::
:: Returns what the minimum angular spacing between two angles of different pulses needs to be
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
int16_T EST1_PSPOutput_MinDisplacementForPulseScheduling_Get(void)
{
    return(PushPull_PSP_MinAdjacentPulseSpacing_Get(&EST1));
}

void EST1_PSPOutput_Stop(void)
{
	NativeVar_U i=0;
	for(; i < 1; i++) {
		PushPull_PSP_Condition_Set(&EST1, i,RES_DISABLED);
	}
}





/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Accessors for EST2
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void EST2_PSPOutput_Condition_Set(uint8_T pulse, uint8_T state)
{
    PushPull_PSP_Condition_Set(&EST2, pulse, state);
}

static boolean_T EST2_PSPOutput_PrevCondition[ 1 ] = {0};
void EST2_PSPOutput_HardStart_HardStop_Set(uint8_T pulse, uint8_T state, int16_T startAngle, int16_T stopAngle, uint32_T maxDuration)
{
    U_PSPTiming_CPU TimingObj;
    TimingObj.HardStart.sStartAngle = startAngle;
    TimingObj.HardStart.sHardStopAngle = stopAngle;
    TimingObj.HardStart.uHardDuration_uS = maxDuration;

    /* Apply the timings first so that a change in the condition does not occur before valid data has been installed into the output */
    
    
    PushPull_PSP_Timing_Set(&EST2, (NativeVar_U) pulse, PSP_HARDSTART_HARDSTOP, &TimingObj,
    PSP_TIMING_IMMEDIATE_UPDATE );

    if (state != EST2_PSPOutput_PrevCondition[pulse]) {
        PushPull_PSP_Condition_Set(&EST2, (NativeVar_U) pulse, (E_PSPResourceCond) state);
        EST2_PSPOutput_PrevCondition[pulse] = state;
    }
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: EST2_PSPOutput_MinDisplacementForPulseScheduling_Get
::
:: Returns what the minimum angular spacing between two angles of different pulses needs to be
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
int16_T EST2_PSPOutput_MinDisplacementForPulseScheduling_Get(void)
{
    return(PushPull_PSP_MinAdjacentPulseSpacing_Get(&EST2));
}

void EST2_PSPOutput_Stop(void)
{
	NativeVar_U i=0;
	for(; i < 1; i++) {
		PushPull_PSP_Condition_Set(&EST2, i,RES_DISABLED);
	}
}





/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Accessors for EST3
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void EST3_PSPOutput_Condition_Set(uint8_T pulse, uint8_T state)
{
    PushPull_PSP_Condition_Set(&EST3, pulse, state);
}

static boolean_T EST3_PSPOutput_PrevCondition[ 1 ] = {0};
void EST3_PSPOutput_HardStart_HardStop_Set(uint8_T pulse, uint8_T state, int16_T startAngle, int16_T stopAngle, uint32_T maxDuration)
{
    U_PSPTiming_CPU TimingObj;
    TimingObj.HardStart.sStartAngle = startAngle;
    TimingObj.HardStart.sHardStopAngle = stopAngle;
    TimingObj.HardStart.uHardDuration_uS = maxDuration;

    /* Apply the timings first so that a change in the condition does not occur before valid data has been installed into the output */
    
    
    PushPull_PSP_Timing_Set(&EST3, (NativeVar_U) pulse, PSP_HARDSTART_HARDSTOP, &TimingObj,
    PSP_TIMING_IMMEDIATE_UPDATE );

    if (state != EST3_PSPOutput_PrevCondition[pulse]) {
        PushPull_PSP_Condition_Set(&EST3, (NativeVar_U) pulse, (E_PSPResourceCond) state);
        EST3_PSPOutput_PrevCondition[pulse] = state;
    }
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: EST3_PSPOutput_MinDisplacementForPulseScheduling_Get
::
:: Returns what the minimum angular spacing between two angles of different pulses needs to be
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
int16_T EST3_PSPOutput_MinDisplacementForPulseScheduling_Get(void)
{
    return(PushPull_PSP_MinAdjacentPulseSpacing_Get(&EST3));
}

void EST3_PSPOutput_Stop(void)
{
	NativeVar_U i=0;
	for(; i < 1; i++) {
		PushPull_PSP_Condition_Set(&EST3, i,RES_DISABLED);
	}
}





/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Accessors for EST4
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void EST4_PSPOutput_Condition_Set(uint8_T pulse, uint8_T state)
{
    PushPull_PSP_Condition_Set(&EST4, pulse, state);
}

static boolean_T EST4_PSPOutput_PrevCondition[ 1 ] = {0};
void EST4_PSPOutput_HardStart_HardStop_Set(uint8_T pulse, uint8_T state, int16_T startAngle, int16_T stopAngle, uint32_T maxDuration)
{
    U_PSPTiming_CPU TimingObj;
    TimingObj.HardStart.sStartAngle = startAngle;
    TimingObj.HardStart.sHardStopAngle = stopAngle;
    TimingObj.HardStart.uHardDuration_uS = maxDuration;

    /* Apply the timings first so that a change in the condition does not occur before valid data has been installed into the output */
    
    
    PushPull_PSP_Timing_Set(&EST4, (NativeVar_U) pulse, PSP_HARDSTART_HARDSTOP, &TimingObj,
    PSP_TIMING_IMMEDIATE_UPDATE );

    if (state != EST4_PSPOutput_PrevCondition[pulse]) {
        PushPull_PSP_Condition_Set(&EST4, (NativeVar_U) pulse, (E_PSPResourceCond) state);
        EST4_PSPOutput_PrevCondition[pulse] = state;
    }
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: EST4_PSPOutput_MinDisplacementForPulseScheduling_Get
::
:: Returns what the minimum angular spacing between two angles of different pulses needs to be
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
int16_T EST4_PSPOutput_MinDisplacementForPulseScheduling_Get(void)
{
    return(PushPull_PSP_MinAdjacentPulseSpacing_Get(&EST4));
}

void EST4_PSPOutput_Stop(void)
{
	NativeVar_U i=0;
	for(; i < 1; i++) {
		PushPull_PSP_Condition_Set(&EST4, i,RES_DISABLED);
	}
}





/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Accessors for EST5
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void EST5_PSPOutput_Condition_Set(uint8_T pulse, uint8_T state)
{
    PushPull_PSP_Condition_Set(&EST5, pulse, state);
}

static boolean_T EST5_PSPOutput_PrevCondition[ 1 ] = {0};
void EST5_PSPOutput_HardStart_HardStop_Set(uint8_T pulse, uint8_T state, int16_T startAngle, int16_T stopAngle, uint32_T maxDuration)
{
    U_PSPTiming_CPU TimingObj;
    TimingObj.HardStart.sStartAngle = startAngle;
    TimingObj.HardStart.sHardStopAngle = stopAngle;
    TimingObj.HardStart.uHardDuration_uS = maxDuration;

    /* Apply the timings first so that a change in the condition does not occur before valid data has been installed into the output */
    
    
    PushPull_PSP_Timing_Set(&EST5, (NativeVar_U) pulse, PSP_HARDSTART_HARDSTOP, &TimingObj,
    PSP_TIMING_IMMEDIATE_UPDATE );

    if (state != EST5_PSPOutput_PrevCondition[pulse]) {
        PushPull_PSP_Condition_Set(&EST5, (NativeVar_U) pulse, (E_PSPResourceCond) state);
        EST5_PSPOutput_PrevCondition[pulse] = state;
    }
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: EST5_PSPOutput_MinDisplacementForPulseScheduling_Get
::
:: Returns what the minimum angular spacing between two angles of different pulses needs to be
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
int16_T EST5_PSPOutput_MinDisplacementForPulseScheduling_Get(void)
{
    return(PushPull_PSP_MinAdjacentPulseSpacing_Get(&EST5));
}

void EST5_PSPOutput_Stop(void)
{
	NativeVar_U i=0;
	for(; i < 1; i++) {
		PushPull_PSP_Condition_Set(&EST5, i,RES_DISABLED);
	}
}





/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Accessors for EST6
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void EST6_PSPOutput_Condition_Set(uint8_T pulse, uint8_T state)
{
    PushPull_PSP_Condition_Set(&EST6, pulse, state);
}

static boolean_T EST6_PSPOutput_PrevCondition[ 1 ] = {0};
void EST6_PSPOutput_HardStart_HardStop_Set(uint8_T pulse, uint8_T state, int16_T startAngle, int16_T stopAngle, uint32_T maxDuration)
{
    U_PSPTiming_CPU TimingObj;
    TimingObj.HardStart.sStartAngle = startAngle;
    TimingObj.HardStart.sHardStopAngle = stopAngle;
    TimingObj.HardStart.uHardDuration_uS = maxDuration;

    /* Apply the timings first so that a change in the condition does not occur before valid data has been installed into the output */
    
    
    PushPull_PSP_Timing_Set(&EST6, (NativeVar_U) pulse, PSP_HARDSTART_HARDSTOP, &TimingObj,
    PSP_TIMING_IMMEDIATE_UPDATE );

    if (state != EST6_PSPOutput_PrevCondition[pulse]) {
        PushPull_PSP_Condition_Set(&EST6, (NativeVar_U) pulse, (E_PSPResourceCond) state);
        EST6_PSPOutput_PrevCondition[pulse] = state;
    }
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: EST6_PSPOutput_MinDisplacementForPulseScheduling_Get
::
:: Returns what the minimum angular spacing between two angles of different pulses needs to be
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
int16_T EST6_PSPOutput_MinDisplacementForPulseScheduling_Get(void)
{
    return(PushPull_PSP_MinAdjacentPulseSpacing_Get(&EST6));
}

void EST6_PSPOutput_Stop(void)
{
	NativeVar_U i=0;
	for(; i < 1; i++) {
		PushPull_PSP_Condition_Set(&EST6, i,RES_DISABLED);
	}
}





/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Accessors for EST7
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void EST7_PSPOutput_Condition_Set(uint8_T pulse, uint8_T state)
{
    PushPull_PSP_Condition_Set(&EST7, pulse, state);
}

static boolean_T EST7_PSPOutput_PrevCondition[ 1 ] = {0};
void EST7_PSPOutput_HardStart_HardStop_Set(uint8_T pulse, uint8_T state, int16_T startAngle, int16_T stopAngle, uint32_T maxDuration)
{
    U_PSPTiming_CPU TimingObj;
    TimingObj.HardStart.sStartAngle = startAngle;
    TimingObj.HardStart.sHardStopAngle = stopAngle;
    TimingObj.HardStart.uHardDuration_uS = maxDuration;

    /* Apply the timings first so that a change in the condition does not occur before valid data has been installed into the output */
    
    
    PushPull_PSP_Timing_Set(&EST7, (NativeVar_U) pulse, PSP_HARDSTART_HARDSTOP, &TimingObj,
    PSP_TIMING_IMMEDIATE_UPDATE );

    if (state != EST7_PSPOutput_PrevCondition[pulse]) {
        PushPull_PSP_Condition_Set(&EST7, (NativeVar_U) pulse, (E_PSPResourceCond) state);
        EST7_PSPOutput_PrevCondition[pulse] = state;
    }
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: EST7_PSPOutput_MinDisplacementForPulseScheduling_Get
::
:: Returns what the minimum angular spacing between two angles of different pulses needs to be
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
int16_T EST7_PSPOutput_MinDisplacementForPulseScheduling_Get(void)
{
    return(PushPull_PSP_MinAdjacentPulseSpacing_Get(&EST7));
}

void EST7_PSPOutput_Stop(void)
{
	NativeVar_U i=0;
	for(; i < 1; i++) {
		PushPull_PSP_Condition_Set(&EST7, i,RES_DISABLED);
	}
}





/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Accessors for EST8
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void EST8_PSPOutput_Condition_Set(uint8_T pulse, uint8_T state)
{
    PushPull_PSP_Condition_Set(&EST8, pulse, state);
}

static boolean_T EST8_PSPOutput_PrevCondition[ 1 ] = {0};
void EST8_PSPOutput_HardStart_HardStop_Set(uint8_T pulse, uint8_T state, int16_T startAngle, int16_T stopAngle, uint32_T maxDuration)
{
    U_PSPTiming_CPU TimingObj;
    TimingObj.HardStart.sStartAngle = startAngle;
    TimingObj.HardStart.sHardStopAngle = stopAngle;
    TimingObj.HardStart.uHardDuration_uS = maxDuration;

    /* Apply the timings first so that a change in the condition does not occur before valid data has been installed into the output */
    
    
    PushPull_PSP_Timing_Set(&EST8, (NativeVar_U) pulse, PSP_HARDSTART_HARDSTOP, &TimingObj,
    PSP_TIMING_IMMEDIATE_UPDATE );

    if (state != EST8_PSPOutput_PrevCondition[pulse]) {
        PushPull_PSP_Condition_Set(&EST8, (NativeVar_U) pulse, (E_PSPResourceCond) state);
        EST8_PSPOutput_PrevCondition[pulse] = state;
    }
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: EST8_PSPOutput_MinDisplacementForPulseScheduling_Get
::
:: Returns what the minimum angular spacing between two angles of different pulses needs to be
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
int16_T EST8_PSPOutput_MinDisplacementForPulseScheduling_Get(void)
{
    return(PushPull_PSP_MinAdjacentPulseSpacing_Get(&EST8));
}

void EST8_PSPOutput_Stop(void)
{
	NativeVar_U i=0;
	for(; i < 1; i++) {
		PushPull_PSP_Condition_Set(&EST8, i,RES_DISABLED);
	}
}





/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Accessors for INJ1
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void INJ1_PSPOutput_Condition_Set(uint8_T pulse, uint8_T state)
{
    BasicOut_PSP_Condition_Set(&INJ1, pulse, state);
}

static boolean_T INJ1_PSPOutput_PrevCondition[ 2 ] = {0};

static boolean_T INJ1_PSPOutput_ApplyTransientCondOnEndPrim = FALSE;

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: INJ1_PSPOutput_TransientBehavior_OnEndOfPulse
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void INJ1_PSPOutput_TransientBehavior_OnEndOfPulse(uint8_T uPulse)
{
    /* If the primary pulse just ended AND the transient has been flagged to be enabled on end of pulse */
    if ( (uPulse == 0) && (INJ1_PSPOutput_ApplyTransientCondOnEndPrim != FALSE) )
    {
        INJ1_PSPOutput_ApplyTransientCondOnEndPrim = FALSE;
        BasicOut_PSP_Condition_Set(&INJ1, 1, PSP_RES_ENABLED);
    }
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: INJ1_PSPOutput_TransientBehavior_Set
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void INJ1_PSPOutput_TransientBehavior_Set(NativeVar_U statePrimary, int16_T startAnglePrimary, uint32_T durationPrimary, NativeVar_U stateTransient, int16_T stopAngleTransient, uint32_T durationTransient)
{
    NativeVar_S const sMinDisplacementForPulseScheduling = INJ1_PSPOutput_MinDisplacementForPulseScheduling_Get();
    NativeVar_S const sNumDegreeInCycle = CNK_Encoder_NumDegreesPerCycle_Get();
    E_PSPResourceCond eStatePrimary = (E_PSPResourceCond)statePrimary;

    E_PSPResourceCond eStateTransient = (E_PSPResourceCond)stateTransient;

    /* The transient pulse shall be disabled when the primary pulse is disabled, regardless of what is requested */
    if (eStatePrimary != PSP_RES_ENABLED)
    {
        eStateTransient = PSP_RES_DISABLED;
    }

    if (eStateTransient == PSP_RES_ENABLED)
    {   /* Dual Pulse operation */
        NativeVar_S eoi = stopAngleTransient;
        NativeVar_S soi = startAnglePrimary; /* cast to a native so that sign extension is not required while we interact with the signal */

        while (soi < 0)
            soi = soi + sNumDegreeInCycle;
        while (soi >= sNumDegreeInCycle)
            soi = soi - sNumDegreeInCycle;
        while (eoi < 0)
            eoi = eoi + sNumDegreeInCycle;
        while (eoi >= sNumDegreeInCycle)
            eoi = eoi - sNumDegreeInCycle;

        if (soi <= eoi)
        {   /* If eoi exceeds soi, then there must be a difference of sMinDisplacementForPulseScheduling [value is x16 units] degrees between the two */
            if ((eoi - soi) < sMinDisplacementForPulseScheduling)
            {
                eoi = soi + sMinDisplacementForPulseScheduling; /* Don't let the minimum be below uMinDisplacementForPulseScheduling */
            }
        }
        else
        { /* If soi exceeds eoi, then there must be a difference of sMinDisplacementForPulseScheduling [value is x16 units] degrees between the two after soi is wrapped around */
            if ((soi - eoi) > (sNumDegreeInCycle - sMinDisplacementForPulseScheduling))
            {
                eoi = soi + sMinDisplacementForPulseScheduling;
            }
        }

        /*::::::::::::::::::::::::::::::::::::::::
          Dual Pulse: Apply primary pulse timing
          ::::::::::::::::::::::::::::::::::::::::*/
        {
            U_PSPTiming_CPU TimingObj;
            TimingObj.HardStart.sStartAngle = soi;
            TimingObj.HardStart.sHardStopAngle = eoi + sMinDisplacementForPulseScheduling;
            TimingObj.HardStart.uHardDuration_uS = durationPrimary;
	
            BasicOut_PSP_Timing_Set(&INJ1, 0, PSP_HARDSTART_HARDDURATION, &TimingObj,
            PSP_TIMING_IMMEDIATE_UPDATE | PSP_TIMING_UPDATE_AFFECT_ASSERTED_PULSE | PSP_TIMING_WANT_END_EVENT_ISR);

            if (eStatePrimary != INJ1_PSPOutput_PrevCondition[0])
            {
                INJ1_PSPOutput_PrevCondition[0] = (boolean_T)eStatePrimary;
                BasicOut_PSP_Condition_Set(&INJ1, 0, eStatePrimary);
            }
        }

        /*::::::::::::::::::::::::::::::::::::::::
          Dual Pulse: Apply transient pulse timing
          ::::::::::::::::::::::::::::::::::::::::*/
        {
            U_PSPTiming_CPU TimingObj;
            TimingObj.SoftStopHardDur.sSoftStopAngle = eoi;
            TimingObj.SoftStopHardDur.sHardStopAngle = eoi;
            TimingObj.SoftStopHardDur.uHardDuration_uS = durationTransient;
	
            /* Apply timing before we enable to ensure that there are valid timings when the pulse is enabled */
            /* Don't employ PSP_TIMING_UPDATE_AFFECT_ASSERTED_PULSE on the transient pulse because if it is ON*/
            /*   then increasing the duration will achieve little because we will hit the end stop anyway     */
            BasicOut_PSP_Timing_Set(&INJ1, 1, PSP_SOFTSTOP_HARDDURATION, &TimingObj,
            PSP_TIMING_IMMEDIATE_UPDATE | PSP_TIMING_WANT_END_EVENT_ISR);

		
            /* We must only enable the transient pulse afer the primary pulse has completed. Otherwise we risk */
            /* enabling whilst an active primary pulse with the old timing (i.e. a pulse that was active prior */
            /* to the transient modified primary timing having been applied) that also happens to overlap with */
			/* the transient pulse timing. The transition will result in a missed pulse in such a situation.   */
			/* The code already forces the transient to disabled if the primary is not enabled and so we know  */
			/*   that a primary pulse has been scheduled.                                                      */
            if (INJ1_PSPOutput_PrevCondition[1] == PSP_RES_DISABLED )
            {
                INJ1_PSPOutput_ApplyTransientCondOnEndPrim = TRUE;
                INJ1_PSPOutput_PrevCondition[1] = TRUE;
            }
			
        }
    }
    else
 
    {
        /*::::::::::::::::::::::::::::::::::::::::
          Single Pulse: Apply primary pulse timing
          ::::::::::::::::::::::::::::::::::::::::*/
        uint32_T u32DurationAsAnAngle;
        uint16_T u16InstantRPM;
        U_PSPTiming_CPU TimingObj;

        TimingObj.HardStart.sStartAngle = startAnglePrimary;
        TimingObj.HardStart.uHardDuration_uS = durationPrimary;

        /* Need RPM to approximate the angular duration of the primary pulse */
        u16InstantRPM = CNK_Encoder_InstantRPM_Get();

        /* DurationAsAnAngle = (Duration x RPM x 360x16) / 60,000,000
           DurationAsAnAngle = (Duration x RPM x 3x16) / 500,000
           DurationAsAnAngle = (Duration x RPM x 3) / 31250 */
        u32DurationAsAnAngle = durationPrimary * u16InstantRPM;
        u32DurationAsAnAngle = u32DurationAsAnAngle * 3U;
        u32DurationAsAnAngle = u32DurationAsAnAngle / 31250U;

        if (u32DurationAsAnAngle > sNumDegreeInCycle / 2U)
        {   /* Duration is approach half a cycle so set the hard stop based upon the minimum displacement value */
            TimingObj.HardStart.sHardStopAngle = TimingObj.HardStart.sStartAngle + sMinDisplacementForPulseScheduling;
        }
        else
        {    /* Duration is not approaching even half a cycle so apply some margin on the hard stop */
             TimingObj.HardStart.sHardStopAngle = (sNumDegreeInCycle / 4U) + TimingObj.HardStart.sStartAngle;
        }

        /* Apply timing before we enable to ensure that there are valid timings when the pulse is enabled */
        BasicOut_PSP_Timing_Set(&INJ1, 0, PSP_HARDSTART_HARDDURATION, &TimingObj,    
        PSP_TIMING_IMMEDIATE_UPDATE | PSP_TIMING_UPDATE_AFFECT_ASSERTED_PULSE | PSP_TIMING_WANT_END_EVENT_ISR);

        if (eStatePrimary != INJ1_PSPOutput_PrevCondition[0])
        {
            INJ1_PSPOutput_PrevCondition[0] = (boolean_T)eStatePrimary;
            BasicOut_PSP_Condition_Set(&INJ1, 0, eStatePrimary);
        }


        /* Expectation is that the Transient State is PSP_RES_DISABLED if we are here */
        if (PSP_RES_DISABLED != INJ1_PSPOutput_PrevCondition[1])
        {
            /* Have not applied the disable yet - so apply it */
            INJ1_PSPOutput_PrevCondition[1] = PSP_RES_DISABLED;
		
            /* Cancel any pending enables */
            INJ1_PSPOutput_ApplyTransientCondOnEndPrim = FALSE;
		
            BasicOut_PSP_Condition_Set(&INJ1, 1, PSP_RES_DISABLED);
        }

        /* The transient pulse should now be disabled and so there are no applicable timings that we need to set
           Timings will be re-applied before the pulse is enabled again */
 
    }
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: INJ1_PSPOutput_MinDisplacementForPulseScheduling_Get
::
:: Returns what the minimum angular spacing between two angles of different pulses needs to be
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
int16_T INJ1_PSPOutput_MinDisplacementForPulseScheduling_Get(void)
{
    return(BasicOut_PSP_MinAdjacentPulseSpacing_Get(&INJ1));
}

static void INJ1_PSPOutput_OnPulseEnd_Callback(struct S_BasicOut_Defn_PSP const* const pThisPSP, S_PSPEndOfEventReport* const pReport)
{
    if(pReport)
    {

        INJ1_PSPOutput_TransientBehavior_OnEndOfPulse(pReport->uPulse);

        {

            extern void Trigger_Trans_INJ1(uint8_T uPulse, boolean_T bIsDurationValid, uint32_T uDeliveredDuration_uS);
Trigger_Trans_INJ1(pReport->uPulse, (boolean_T)pReport->bIsDurationValid, pReport->uDeliveredDuration_uS);

        }
    }
}
void INJ1_PSPOutput_Stop(void)
{
	NativeVar_U i=0;
	for(; i < 2; i++) {
		BasicOut_PSP_Condition_Set(&INJ1, i,RES_DISABLED);
	}
}





/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Accessors for INJ2
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void INJ2_PSPOutput_Condition_Set(uint8_T pulse, uint8_T state)
{
    BasicOut_PSP_Condition_Set(&INJ2, pulse, state);
}

static boolean_T INJ2_PSPOutput_PrevCondition[ 2 ] = {0};

static boolean_T INJ2_PSPOutput_ApplyTransientCondOnEndPrim = FALSE;

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: INJ2_PSPOutput_TransientBehavior_OnEndOfPulse
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void INJ2_PSPOutput_TransientBehavior_OnEndOfPulse(uint8_T uPulse)
{
    /* If the primary pulse just ended AND the transient has been flagged to be enabled on end of pulse */
    if ( (uPulse == 0) && (INJ2_PSPOutput_ApplyTransientCondOnEndPrim != FALSE) )
    {
        INJ2_PSPOutput_ApplyTransientCondOnEndPrim = FALSE;
        BasicOut_PSP_Condition_Set(&INJ2, 1, PSP_RES_ENABLED);
    }
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: INJ2_PSPOutput_TransientBehavior_Set
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void INJ2_PSPOutput_TransientBehavior_Set(NativeVar_U statePrimary, int16_T startAnglePrimary, uint32_T durationPrimary, NativeVar_U stateTransient, int16_T stopAngleTransient, uint32_T durationTransient)
{
    NativeVar_S const sMinDisplacementForPulseScheduling = INJ2_PSPOutput_MinDisplacementForPulseScheduling_Get();
    NativeVar_S const sNumDegreeInCycle = CNK_Encoder_NumDegreesPerCycle_Get();
    E_PSPResourceCond eStatePrimary = (E_PSPResourceCond)statePrimary;

    E_PSPResourceCond eStateTransient = (E_PSPResourceCond)stateTransient;

    /* The transient pulse shall be disabled when the primary pulse is disabled, regardless of what is requested */
    if (eStatePrimary != PSP_RES_ENABLED)
    {
        eStateTransient = PSP_RES_DISABLED;
    }

    if (eStateTransient == PSP_RES_ENABLED)
    {   /* Dual Pulse operation */
        NativeVar_S eoi = stopAngleTransient;
        NativeVar_S soi = startAnglePrimary; /* cast to a native so that sign extension is not required while we interact with the signal */

        while (soi < 0)
            soi = soi + sNumDegreeInCycle;
        while (soi >= sNumDegreeInCycle)
            soi = soi - sNumDegreeInCycle;
        while (eoi < 0)
            eoi = eoi + sNumDegreeInCycle;
        while (eoi >= sNumDegreeInCycle)
            eoi = eoi - sNumDegreeInCycle;

        if (soi <= eoi)
        {   /* If eoi exceeds soi, then there must be a difference of sMinDisplacementForPulseScheduling [value is x16 units] degrees between the two */
            if ((eoi - soi) < sMinDisplacementForPulseScheduling)
            {
                eoi = soi + sMinDisplacementForPulseScheduling; /* Don't let the minimum be below uMinDisplacementForPulseScheduling */
            }
        }
        else
        { /* If soi exceeds eoi, then there must be a difference of sMinDisplacementForPulseScheduling [value is x16 units] degrees between the two after soi is wrapped around */
            if ((soi - eoi) > (sNumDegreeInCycle - sMinDisplacementForPulseScheduling))
            {
                eoi = soi + sMinDisplacementForPulseScheduling;
            }
        }

        /*::::::::::::::::::::::::::::::::::::::::
          Dual Pulse: Apply primary pulse timing
          ::::::::::::::::::::::::::::::::::::::::*/
        {
            U_PSPTiming_CPU TimingObj;
            TimingObj.HardStart.sStartAngle = soi;
            TimingObj.HardStart.sHardStopAngle = eoi + sMinDisplacementForPulseScheduling;
            TimingObj.HardStart.uHardDuration_uS = durationPrimary;
	
            BasicOut_PSP_Timing_Set(&INJ2, 0, PSP_HARDSTART_HARDDURATION, &TimingObj,
            PSP_TIMING_IMMEDIATE_UPDATE | PSP_TIMING_UPDATE_AFFECT_ASSERTED_PULSE | PSP_TIMING_WANT_END_EVENT_ISR);

            if (eStatePrimary != INJ2_PSPOutput_PrevCondition[0])
            {
                INJ2_PSPOutput_PrevCondition[0] = (boolean_T)eStatePrimary;
                BasicOut_PSP_Condition_Set(&INJ2, 0, eStatePrimary);
            }
        }

        /*::::::::::::::::::::::::::::::::::::::::
          Dual Pulse: Apply transient pulse timing
          ::::::::::::::::::::::::::::::::::::::::*/
        {
            U_PSPTiming_CPU TimingObj;
            TimingObj.SoftStopHardDur.sSoftStopAngle = eoi;
            TimingObj.SoftStopHardDur.sHardStopAngle = eoi;
            TimingObj.SoftStopHardDur.uHardDuration_uS = durationTransient;
	
            /* Apply timing before we enable to ensure that there are valid timings when the pulse is enabled */
            /* Don't employ PSP_TIMING_UPDATE_AFFECT_ASSERTED_PULSE on the transient pulse because if it is ON*/
            /*   then increasing the duration will achieve little because we will hit the end stop anyway     */
            BasicOut_PSP_Timing_Set(&INJ2, 1, PSP_SOFTSTOP_HARDDURATION, &TimingObj,
            PSP_TIMING_IMMEDIATE_UPDATE | PSP_TIMING_WANT_END_EVENT_ISR);

		
            /* We must only enable the transient pulse afer the primary pulse has completed. Otherwise we risk */
            /* enabling whilst an active primary pulse with the old timing (i.e. a pulse that was active prior */
            /* to the transient modified primary timing having been applied) that also happens to overlap with */
			/* the transient pulse timing. The transition will result in a missed pulse in such a situation.   */
			/* The code already forces the transient to disabled if the primary is not enabled and so we know  */
			/*   that a primary pulse has been scheduled.                                                      */
            if (INJ2_PSPOutput_PrevCondition[1] == PSP_RES_DISABLED )
            {
                INJ2_PSPOutput_ApplyTransientCondOnEndPrim = TRUE;
                INJ2_PSPOutput_PrevCondition[1] = TRUE;
            }
			
        }
    }
    else
 
    {
        /*::::::::::::::::::::::::::::::::::::::::
          Single Pulse: Apply primary pulse timing
          ::::::::::::::::::::::::::::::::::::::::*/
        uint32_T u32DurationAsAnAngle;
        uint16_T u16InstantRPM;
        U_PSPTiming_CPU TimingObj;

        TimingObj.HardStart.sStartAngle = startAnglePrimary;
        TimingObj.HardStart.uHardDuration_uS = durationPrimary;

        /* Need RPM to approximate the angular duration of the primary pulse */
        u16InstantRPM = CNK_Encoder_InstantRPM_Get();

        /* DurationAsAnAngle = (Duration x RPM x 360x16) / 60,000,000
           DurationAsAnAngle = (Duration x RPM x 3x16) / 500,000
           DurationAsAnAngle = (Duration x RPM x 3) / 31250 */
        u32DurationAsAnAngle = durationPrimary * u16InstantRPM;
        u32DurationAsAnAngle = u32DurationAsAnAngle * 3U;
        u32DurationAsAnAngle = u32DurationAsAnAngle / 31250U;

        if (u32DurationAsAnAngle > sNumDegreeInCycle / 2U)
        {   /* Duration is approach half a cycle so set the hard stop based upon the minimum displacement value */
            TimingObj.HardStart.sHardStopAngle = TimingObj.HardStart.sStartAngle + sMinDisplacementForPulseScheduling;
        }
        else
        {    /* Duration is not approaching even half a cycle so apply some margin on the hard stop */
             TimingObj.HardStart.sHardStopAngle = (sNumDegreeInCycle / 4U) + TimingObj.HardStart.sStartAngle;
        }

        /* Apply timing before we enable to ensure that there are valid timings when the pulse is enabled */
        BasicOut_PSP_Timing_Set(&INJ2, 0, PSP_HARDSTART_HARDDURATION, &TimingObj,    
        PSP_TIMING_IMMEDIATE_UPDATE | PSP_TIMING_UPDATE_AFFECT_ASSERTED_PULSE | PSP_TIMING_WANT_END_EVENT_ISR);

        if (eStatePrimary != INJ2_PSPOutput_PrevCondition[0])
        {
            INJ2_PSPOutput_PrevCondition[0] = (boolean_T)eStatePrimary;
            BasicOut_PSP_Condition_Set(&INJ2, 0, eStatePrimary);
        }


        /* Expectation is that the Transient State is PSP_RES_DISABLED if we are here */
        if (PSP_RES_DISABLED != INJ2_PSPOutput_PrevCondition[1])
        {
            /* Have not applied the disable yet - so apply it */
            INJ2_PSPOutput_PrevCondition[1] = PSP_RES_DISABLED;
		
            /* Cancel any pending enables */
            INJ2_PSPOutput_ApplyTransientCondOnEndPrim = FALSE;
		
            BasicOut_PSP_Condition_Set(&INJ2, 1, PSP_RES_DISABLED);
        }

        /* The transient pulse should now be disabled and so there are no applicable timings that we need to set
           Timings will be re-applied before the pulse is enabled again */
 
    }
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: INJ2_PSPOutput_MinDisplacementForPulseScheduling_Get
::
:: Returns what the minimum angular spacing between two angles of different pulses needs to be
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
int16_T INJ2_PSPOutput_MinDisplacementForPulseScheduling_Get(void)
{
    return(BasicOut_PSP_MinAdjacentPulseSpacing_Get(&INJ2));
}

static void INJ2_PSPOutput_OnPulseEnd_Callback(struct S_BasicOut_Defn_PSP const* const pThisPSP, S_PSPEndOfEventReport* const pReport)
{
    if(pReport)
    {

        INJ2_PSPOutput_TransientBehavior_OnEndOfPulse(pReport->uPulse);

        {

            extern void Trigger_Trans_INJ2(uint8_T uPulse, boolean_T bIsDurationValid, uint32_T uDeliveredDuration_uS);
Trigger_Trans_INJ2(pReport->uPulse, (boolean_T)pReport->bIsDurationValid, pReport->uDeliveredDuration_uS);

        }
    }
}
void INJ2_PSPOutput_Stop(void)
{
	NativeVar_U i=0;
	for(; i < 2; i++) {
		BasicOut_PSP_Condition_Set(&INJ2, i,RES_DISABLED);
	}
}





/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Accessors for INJ3
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void INJ3_PSPOutput_Condition_Set(uint8_T pulse, uint8_T state)
{
    BasicOut_PSP_Condition_Set(&INJ3, pulse, state);
}

static boolean_T INJ3_PSPOutput_PrevCondition[ 2 ] = {0};

static boolean_T INJ3_PSPOutput_ApplyTransientCondOnEndPrim = FALSE;

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: INJ3_PSPOutput_TransientBehavior_OnEndOfPulse
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void INJ3_PSPOutput_TransientBehavior_OnEndOfPulse(uint8_T uPulse)
{
    /* If the primary pulse just ended AND the transient has been flagged to be enabled on end of pulse */
    if ( (uPulse == 0) && (INJ3_PSPOutput_ApplyTransientCondOnEndPrim != FALSE) )
    {
        INJ3_PSPOutput_ApplyTransientCondOnEndPrim = FALSE;
        BasicOut_PSP_Condition_Set(&INJ3, 1, PSP_RES_ENABLED);
    }
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: INJ3_PSPOutput_TransientBehavior_Set
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void INJ3_PSPOutput_TransientBehavior_Set(NativeVar_U statePrimary, int16_T startAnglePrimary, uint32_T durationPrimary, NativeVar_U stateTransient, int16_T stopAngleTransient, uint32_T durationTransient)
{
    NativeVar_S const sMinDisplacementForPulseScheduling = INJ3_PSPOutput_MinDisplacementForPulseScheduling_Get();
    NativeVar_S const sNumDegreeInCycle = CNK_Encoder_NumDegreesPerCycle_Get();
    E_PSPResourceCond eStatePrimary = (E_PSPResourceCond)statePrimary;

    E_PSPResourceCond eStateTransient = (E_PSPResourceCond)stateTransient;

    /* The transient pulse shall be disabled when the primary pulse is disabled, regardless of what is requested */
    if (eStatePrimary != PSP_RES_ENABLED)
    {
        eStateTransient = PSP_RES_DISABLED;
    }

    if (eStateTransient == PSP_RES_ENABLED)
    {   /* Dual Pulse operation */
        NativeVar_S eoi = stopAngleTransient;
        NativeVar_S soi = startAnglePrimary; /* cast to a native so that sign extension is not required while we interact with the signal */

        while (soi < 0)
            soi = soi + sNumDegreeInCycle;
        while (soi >= sNumDegreeInCycle)
            soi = soi - sNumDegreeInCycle;
        while (eoi < 0)
            eoi = eoi + sNumDegreeInCycle;
        while (eoi >= sNumDegreeInCycle)
            eoi = eoi - sNumDegreeInCycle;

        if (soi <= eoi)
        {   /* If eoi exceeds soi, then there must be a difference of sMinDisplacementForPulseScheduling [value is x16 units] degrees between the two */
            if ((eoi - soi) < sMinDisplacementForPulseScheduling)
            {
                eoi = soi + sMinDisplacementForPulseScheduling; /* Don't let the minimum be below uMinDisplacementForPulseScheduling */
            }
        }
        else
        { /* If soi exceeds eoi, then there must be a difference of sMinDisplacementForPulseScheduling [value is x16 units] degrees between the two after soi is wrapped around */
            if ((soi - eoi) > (sNumDegreeInCycle - sMinDisplacementForPulseScheduling))
            {
                eoi = soi + sMinDisplacementForPulseScheduling;
            }
        }

        /*::::::::::::::::::::::::::::::::::::::::
          Dual Pulse: Apply primary pulse timing
          ::::::::::::::::::::::::::::::::::::::::*/
        {
            U_PSPTiming_CPU TimingObj;
            TimingObj.HardStart.sStartAngle = soi;
            TimingObj.HardStart.sHardStopAngle = eoi + sMinDisplacementForPulseScheduling;
            TimingObj.HardStart.uHardDuration_uS = durationPrimary;
	
            BasicOut_PSP_Timing_Set(&INJ3, 0, PSP_HARDSTART_HARDDURATION, &TimingObj,
            PSP_TIMING_IMMEDIATE_UPDATE | PSP_TIMING_UPDATE_AFFECT_ASSERTED_PULSE | PSP_TIMING_WANT_END_EVENT_ISR);

            if (eStatePrimary != INJ3_PSPOutput_PrevCondition[0])
            {
                INJ3_PSPOutput_PrevCondition[0] = (boolean_T)eStatePrimary;
                BasicOut_PSP_Condition_Set(&INJ3, 0, eStatePrimary);
            }
        }

        /*::::::::::::::::::::::::::::::::::::::::
          Dual Pulse: Apply transient pulse timing
          ::::::::::::::::::::::::::::::::::::::::*/
        {
            U_PSPTiming_CPU TimingObj;
            TimingObj.SoftStopHardDur.sSoftStopAngle = eoi;
            TimingObj.SoftStopHardDur.sHardStopAngle = eoi;
            TimingObj.SoftStopHardDur.uHardDuration_uS = durationTransient;
	
            /* Apply timing before we enable to ensure that there are valid timings when the pulse is enabled */
            /* Don't employ PSP_TIMING_UPDATE_AFFECT_ASSERTED_PULSE on the transient pulse because if it is ON*/
            /*   then increasing the duration will achieve little because we will hit the end stop anyway     */
            BasicOut_PSP_Timing_Set(&INJ3, 1, PSP_SOFTSTOP_HARDDURATION, &TimingObj,
            PSP_TIMING_IMMEDIATE_UPDATE | PSP_TIMING_WANT_END_EVENT_ISR);

		
            /* We must only enable the transient pulse afer the primary pulse has completed. Otherwise we risk */
            /* enabling whilst an active primary pulse with the old timing (i.e. a pulse that was active prior */
            /* to the transient modified primary timing having been applied) that also happens to overlap with */
			/* the transient pulse timing. The transition will result in a missed pulse in such a situation.   */
			/* The code already forces the transient to disabled if the primary is not enabled and so we know  */
			/*   that a primary pulse has been scheduled.                                                      */
            if (INJ3_PSPOutput_PrevCondition[1] == PSP_RES_DISABLED )
            {
                INJ3_PSPOutput_ApplyTransientCondOnEndPrim = TRUE;
                INJ3_PSPOutput_PrevCondition[1] = TRUE;
            }
			
        }
    }
    else
 
    {
        /*::::::::::::::::::::::::::::::::::::::::
          Single Pulse: Apply primary pulse timing
          ::::::::::::::::::::::::::::::::::::::::*/
        uint32_T u32DurationAsAnAngle;
        uint16_T u16InstantRPM;
        U_PSPTiming_CPU TimingObj;

        TimingObj.HardStart.sStartAngle = startAnglePrimary;
        TimingObj.HardStart.uHardDuration_uS = durationPrimary;

        /* Need RPM to approximate the angular duration of the primary pulse */
        u16InstantRPM = CNK_Encoder_InstantRPM_Get();

        /* DurationAsAnAngle = (Duration x RPM x 360x16) / 60,000,000
           DurationAsAnAngle = (Duration x RPM x 3x16) / 500,000
           DurationAsAnAngle = (Duration x RPM x 3) / 31250 */
        u32DurationAsAnAngle = durationPrimary * u16InstantRPM;
        u32DurationAsAnAngle = u32DurationAsAnAngle * 3U;
        u32DurationAsAnAngle = u32DurationAsAnAngle / 31250U;

        if (u32DurationAsAnAngle > sNumDegreeInCycle / 2U)
        {   /* Duration is approach half a cycle so set the hard stop based upon the minimum displacement value */
            TimingObj.HardStart.sHardStopAngle = TimingObj.HardStart.sStartAngle + sMinDisplacementForPulseScheduling;
        }
        else
        {    /* Duration is not approaching even half a cycle so apply some margin on the hard stop */
             TimingObj.HardStart.sHardStopAngle = (sNumDegreeInCycle / 4U) + TimingObj.HardStart.sStartAngle;
        }

        /* Apply timing before we enable to ensure that there are valid timings when the pulse is enabled */
        BasicOut_PSP_Timing_Set(&INJ3, 0, PSP_HARDSTART_HARDDURATION, &TimingObj,    
        PSP_TIMING_IMMEDIATE_UPDATE | PSP_TIMING_UPDATE_AFFECT_ASSERTED_PULSE | PSP_TIMING_WANT_END_EVENT_ISR);

        if (eStatePrimary != INJ3_PSPOutput_PrevCondition[0])
        {
            INJ3_PSPOutput_PrevCondition[0] = (boolean_T)eStatePrimary;
            BasicOut_PSP_Condition_Set(&INJ3, 0, eStatePrimary);
        }


        /* Expectation is that the Transient State is PSP_RES_DISABLED if we are here */
        if (PSP_RES_DISABLED != INJ3_PSPOutput_PrevCondition[1])
        {
            /* Have not applied the disable yet - so apply it */
            INJ3_PSPOutput_PrevCondition[1] = PSP_RES_DISABLED;
		
            /* Cancel any pending enables */
            INJ3_PSPOutput_ApplyTransientCondOnEndPrim = FALSE;
		
            BasicOut_PSP_Condition_Set(&INJ3, 1, PSP_RES_DISABLED);
        }

        /* The transient pulse should now be disabled and so there are no applicable timings that we need to set
           Timings will be re-applied before the pulse is enabled again */
 
    }
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: INJ3_PSPOutput_MinDisplacementForPulseScheduling_Get
::
:: Returns what the minimum angular spacing between two angles of different pulses needs to be
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
int16_T INJ3_PSPOutput_MinDisplacementForPulseScheduling_Get(void)
{
    return(BasicOut_PSP_MinAdjacentPulseSpacing_Get(&INJ3));
}

static void INJ3_PSPOutput_OnPulseEnd_Callback(struct S_BasicOut_Defn_PSP const* const pThisPSP, S_PSPEndOfEventReport* const pReport)
{
    if(pReport)
    {

        INJ3_PSPOutput_TransientBehavior_OnEndOfPulse(pReport->uPulse);

        {

            extern void Trigger_Trans_INJ3(uint8_T uPulse, boolean_T bIsDurationValid, uint32_T uDeliveredDuration_uS);
Trigger_Trans_INJ3(pReport->uPulse, (boolean_T)pReport->bIsDurationValid, pReport->uDeliveredDuration_uS);

        }
    }
}
void INJ3_PSPOutput_Stop(void)
{
	NativeVar_U i=0;
	for(; i < 2; i++) {
		BasicOut_PSP_Condition_Set(&INJ3, i,RES_DISABLED);
	}
}





/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Accessors for INJ4
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void INJ4_PSPOutput_Condition_Set(uint8_T pulse, uint8_T state)
{
    BasicOut_PSP_Condition_Set(&INJ4, pulse, state);
}

static boolean_T INJ4_PSPOutput_PrevCondition[ 2 ] = {0};

static boolean_T INJ4_PSPOutput_ApplyTransientCondOnEndPrim = FALSE;

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: INJ4_PSPOutput_TransientBehavior_OnEndOfPulse
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void INJ4_PSPOutput_TransientBehavior_OnEndOfPulse(uint8_T uPulse)
{
    /* If the primary pulse just ended AND the transient has been flagged to be enabled on end of pulse */
    if ( (uPulse == 0) && (INJ4_PSPOutput_ApplyTransientCondOnEndPrim != FALSE) )
    {
        INJ4_PSPOutput_ApplyTransientCondOnEndPrim = FALSE;
        BasicOut_PSP_Condition_Set(&INJ4, 1, PSP_RES_ENABLED);
    }
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: INJ4_PSPOutput_TransientBehavior_Set
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void INJ4_PSPOutput_TransientBehavior_Set(NativeVar_U statePrimary, int16_T startAnglePrimary, uint32_T durationPrimary, NativeVar_U stateTransient, int16_T stopAngleTransient, uint32_T durationTransient)
{
    NativeVar_S const sMinDisplacementForPulseScheduling = INJ4_PSPOutput_MinDisplacementForPulseScheduling_Get();
    NativeVar_S const sNumDegreeInCycle = CNK_Encoder_NumDegreesPerCycle_Get();
    E_PSPResourceCond eStatePrimary = (E_PSPResourceCond)statePrimary;

    E_PSPResourceCond eStateTransient = (E_PSPResourceCond)stateTransient;

    /* The transient pulse shall be disabled when the primary pulse is disabled, regardless of what is requested */
    if (eStatePrimary != PSP_RES_ENABLED)
    {
        eStateTransient = PSP_RES_DISABLED;
    }

    if (eStateTransient == PSP_RES_ENABLED)
    {   /* Dual Pulse operation */
        NativeVar_S eoi = stopAngleTransient;
        NativeVar_S soi = startAnglePrimary; /* cast to a native so that sign extension is not required while we interact with the signal */

        while (soi < 0)
            soi = soi + sNumDegreeInCycle;
        while (soi >= sNumDegreeInCycle)
            soi = soi - sNumDegreeInCycle;
        while (eoi < 0)
            eoi = eoi + sNumDegreeInCycle;
        while (eoi >= sNumDegreeInCycle)
            eoi = eoi - sNumDegreeInCycle;

        if (soi <= eoi)
        {   /* If eoi exceeds soi, then there must be a difference of sMinDisplacementForPulseScheduling [value is x16 units] degrees between the two */
            if ((eoi - soi) < sMinDisplacementForPulseScheduling)
            {
                eoi = soi + sMinDisplacementForPulseScheduling; /* Don't let the minimum be below uMinDisplacementForPulseScheduling */
            }
        }
        else
        { /* If soi exceeds eoi, then there must be a difference of sMinDisplacementForPulseScheduling [value is x16 units] degrees between the two after soi is wrapped around */
            if ((soi - eoi) > (sNumDegreeInCycle - sMinDisplacementForPulseScheduling))
            {
                eoi = soi + sMinDisplacementForPulseScheduling;
            }
        }

        /*::::::::::::::::::::::::::::::::::::::::
          Dual Pulse: Apply primary pulse timing
          ::::::::::::::::::::::::::::::::::::::::*/
        {
            U_PSPTiming_CPU TimingObj;
            TimingObj.HardStart.sStartAngle = soi;
            TimingObj.HardStart.sHardStopAngle = eoi + sMinDisplacementForPulseScheduling;
            TimingObj.HardStart.uHardDuration_uS = durationPrimary;
	
            BasicOut_PSP_Timing_Set(&INJ4, 0, PSP_HARDSTART_HARDDURATION, &TimingObj,
            PSP_TIMING_IMMEDIATE_UPDATE | PSP_TIMING_UPDATE_AFFECT_ASSERTED_PULSE | PSP_TIMING_WANT_END_EVENT_ISR);

            if (eStatePrimary != INJ4_PSPOutput_PrevCondition[0])
            {
                INJ4_PSPOutput_PrevCondition[0] = (boolean_T)eStatePrimary;
                BasicOut_PSP_Condition_Set(&INJ4, 0, eStatePrimary);
            }
        }

        /*::::::::::::::::::::::::::::::::::::::::
          Dual Pulse: Apply transient pulse timing
          ::::::::::::::::::::::::::::::::::::::::*/
        {
            U_PSPTiming_CPU TimingObj;
            TimingObj.SoftStopHardDur.sSoftStopAngle = eoi;
            TimingObj.SoftStopHardDur.sHardStopAngle = eoi;
            TimingObj.SoftStopHardDur.uHardDuration_uS = durationTransient;
	
            /* Apply timing before we enable to ensure that there are valid timings when the pulse is enabled */
            /* Don't employ PSP_TIMING_UPDATE_AFFECT_ASSERTED_PULSE on the transient pulse because if it is ON*/
            /*   then increasing the duration will achieve little because we will hit the end stop anyway     */
            BasicOut_PSP_Timing_Set(&INJ4, 1, PSP_SOFTSTOP_HARDDURATION, &TimingObj,
            PSP_TIMING_IMMEDIATE_UPDATE | PSP_TIMING_WANT_END_EVENT_ISR);

		
            /* We must only enable the transient pulse afer the primary pulse has completed. Otherwise we risk */
            /* enabling whilst an active primary pulse with the old timing (i.e. a pulse that was active prior */
            /* to the transient modified primary timing having been applied) that also happens to overlap with */
			/* the transient pulse timing. The transition will result in a missed pulse in such a situation.   */
			/* The code already forces the transient to disabled if the primary is not enabled and so we know  */
			/*   that a primary pulse has been scheduled.                                                      */
            if (INJ4_PSPOutput_PrevCondition[1] == PSP_RES_DISABLED )
            {
                INJ4_PSPOutput_ApplyTransientCondOnEndPrim = TRUE;
                INJ4_PSPOutput_PrevCondition[1] = TRUE;
            }
			
        }
    }
    else
 
    {
        /*::::::::::::::::::::::::::::::::::::::::
          Single Pulse: Apply primary pulse timing
          ::::::::::::::::::::::::::::::::::::::::*/
        uint32_T u32DurationAsAnAngle;
        uint16_T u16InstantRPM;
        U_PSPTiming_CPU TimingObj;

        TimingObj.HardStart.sStartAngle = startAnglePrimary;
        TimingObj.HardStart.uHardDuration_uS = durationPrimary;

        /* Need RPM to approximate the angular duration of the primary pulse */
        u16InstantRPM = CNK_Encoder_InstantRPM_Get();

        /* DurationAsAnAngle = (Duration x RPM x 360x16) / 60,000,000
           DurationAsAnAngle = (Duration x RPM x 3x16) / 500,000
           DurationAsAnAngle = (Duration x RPM x 3) / 31250 */
        u32DurationAsAnAngle = durationPrimary * u16InstantRPM;
        u32DurationAsAnAngle = u32DurationAsAnAngle * 3U;
        u32DurationAsAnAngle = u32DurationAsAnAngle / 31250U;

        if (u32DurationAsAnAngle > sNumDegreeInCycle / 2U)
        {   /* Duration is approach half a cycle so set the hard stop based upon the minimum displacement value */
            TimingObj.HardStart.sHardStopAngle = TimingObj.HardStart.sStartAngle + sMinDisplacementForPulseScheduling;
        }
        else
        {    /* Duration is not approaching even half a cycle so apply some margin on the hard stop */
             TimingObj.HardStart.sHardStopAngle = (sNumDegreeInCycle / 4U) + TimingObj.HardStart.sStartAngle;
        }

        /* Apply timing before we enable to ensure that there are valid timings when the pulse is enabled */
        BasicOut_PSP_Timing_Set(&INJ4, 0, PSP_HARDSTART_HARDDURATION, &TimingObj,    
        PSP_TIMING_IMMEDIATE_UPDATE | PSP_TIMING_UPDATE_AFFECT_ASSERTED_PULSE | PSP_TIMING_WANT_END_EVENT_ISR);

        if (eStatePrimary != INJ4_PSPOutput_PrevCondition[0])
        {
            INJ4_PSPOutput_PrevCondition[0] = (boolean_T)eStatePrimary;
            BasicOut_PSP_Condition_Set(&INJ4, 0, eStatePrimary);
        }


        /* Expectation is that the Transient State is PSP_RES_DISABLED if we are here */
        if (PSP_RES_DISABLED != INJ4_PSPOutput_PrevCondition[1])
        {
            /* Have not applied the disable yet - so apply it */
            INJ4_PSPOutput_PrevCondition[1] = PSP_RES_DISABLED;
		
            /* Cancel any pending enables */
            INJ4_PSPOutput_ApplyTransientCondOnEndPrim = FALSE;
		
            BasicOut_PSP_Condition_Set(&INJ4, 1, PSP_RES_DISABLED);
        }

        /* The transient pulse should now be disabled and so there are no applicable timings that we need to set
           Timings will be re-applied before the pulse is enabled again */
 
    }
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: INJ4_PSPOutput_MinDisplacementForPulseScheduling_Get
::
:: Returns what the minimum angular spacing between two angles of different pulses needs to be
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
int16_T INJ4_PSPOutput_MinDisplacementForPulseScheduling_Get(void)
{
    return(BasicOut_PSP_MinAdjacentPulseSpacing_Get(&INJ4));
}

static void INJ4_PSPOutput_OnPulseEnd_Callback(struct S_BasicOut_Defn_PSP const* const pThisPSP, S_PSPEndOfEventReport* const pReport)
{
    if(pReport)
    {

        INJ4_PSPOutput_TransientBehavior_OnEndOfPulse(pReport->uPulse);

        {

            extern void Trigger_Trans_INJ4(uint8_T uPulse, boolean_T bIsDurationValid, uint32_T uDeliveredDuration_uS);
Trigger_Trans_INJ4(pReport->uPulse, (boolean_T)pReport->bIsDurationValid, pReport->uDeliveredDuration_uS);

        }
    }
}
void INJ4_PSPOutput_Stop(void)
{
	NativeVar_U i=0;
	for(; i < 2; i++) {
		BasicOut_PSP_Condition_Set(&INJ4, i,RES_DISABLED);
	}
}





/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Accessors for INJ5
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void INJ5_PSPOutput_Condition_Set(uint8_T pulse, uint8_T state)
{
    BasicOut_PSP_Condition_Set(&INJ5, pulse, state);
}

static boolean_T INJ5_PSPOutput_PrevCondition[ 2 ] = {0};

static boolean_T INJ5_PSPOutput_ApplyTransientCondOnEndPrim = FALSE;

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: INJ5_PSPOutput_TransientBehavior_OnEndOfPulse
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void INJ5_PSPOutput_TransientBehavior_OnEndOfPulse(uint8_T uPulse)
{
    /* If the primary pulse just ended AND the transient has been flagged to be enabled on end of pulse */
    if ( (uPulse == 0) && (INJ5_PSPOutput_ApplyTransientCondOnEndPrim != FALSE) )
    {
        INJ5_PSPOutput_ApplyTransientCondOnEndPrim = FALSE;
        BasicOut_PSP_Condition_Set(&INJ5, 1, PSP_RES_ENABLED);
    }
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: INJ5_PSPOutput_TransientBehavior_Set
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void INJ5_PSPOutput_TransientBehavior_Set(NativeVar_U statePrimary, int16_T startAnglePrimary, uint32_T durationPrimary, NativeVar_U stateTransient, int16_T stopAngleTransient, uint32_T durationTransient)
{
    NativeVar_S const sMinDisplacementForPulseScheduling = INJ5_PSPOutput_MinDisplacementForPulseScheduling_Get();
    NativeVar_S const sNumDegreeInCycle = CNK_Encoder_NumDegreesPerCycle_Get();
    E_PSPResourceCond eStatePrimary = (E_PSPResourceCond)statePrimary;

    E_PSPResourceCond eStateTransient = (E_PSPResourceCond)stateTransient;

    /* The transient pulse shall be disabled when the primary pulse is disabled, regardless of what is requested */
    if (eStatePrimary != PSP_RES_ENABLED)
    {
        eStateTransient = PSP_RES_DISABLED;
    }

    if (eStateTransient == PSP_RES_ENABLED)
    {   /* Dual Pulse operation */
        NativeVar_S eoi = stopAngleTransient;
        NativeVar_S soi = startAnglePrimary; /* cast to a native so that sign extension is not required while we interact with the signal */

        while (soi < 0)
            soi = soi + sNumDegreeInCycle;
        while (soi >= sNumDegreeInCycle)
            soi = soi - sNumDegreeInCycle;
        while (eoi < 0)
            eoi = eoi + sNumDegreeInCycle;
        while (eoi >= sNumDegreeInCycle)
            eoi = eoi - sNumDegreeInCycle;

        if (soi <= eoi)
        {   /* If eoi exceeds soi, then there must be a difference of sMinDisplacementForPulseScheduling [value is x16 units] degrees between the two */
            if ((eoi - soi) < sMinDisplacementForPulseScheduling)
            {
                eoi = soi + sMinDisplacementForPulseScheduling; /* Don't let the minimum be below uMinDisplacementForPulseScheduling */
            }
        }
        else
        { /* If soi exceeds eoi, then there must be a difference of sMinDisplacementForPulseScheduling [value is x16 units] degrees between the two after soi is wrapped around */
            if ((soi - eoi) > (sNumDegreeInCycle - sMinDisplacementForPulseScheduling))
            {
                eoi = soi + sMinDisplacementForPulseScheduling;
            }
        }

        /*::::::::::::::::::::::::::::::::::::::::
          Dual Pulse: Apply primary pulse timing
          ::::::::::::::::::::::::::::::::::::::::*/
        {
            U_PSPTiming_CPU TimingObj;
            TimingObj.HardStart.sStartAngle = soi;
            TimingObj.HardStart.sHardStopAngle = eoi + sMinDisplacementForPulseScheduling;
            TimingObj.HardStart.uHardDuration_uS = durationPrimary;
	
            BasicOut_PSP_Timing_Set(&INJ5, 0, PSP_HARDSTART_HARDDURATION, &TimingObj,
            PSP_TIMING_IMMEDIATE_UPDATE | PSP_TIMING_UPDATE_AFFECT_ASSERTED_PULSE | PSP_TIMING_WANT_END_EVENT_ISR);

            if (eStatePrimary != INJ5_PSPOutput_PrevCondition[0])
            {
                INJ5_PSPOutput_PrevCondition[0] = (boolean_T)eStatePrimary;
                BasicOut_PSP_Condition_Set(&INJ5, 0, eStatePrimary);
            }
        }

        /*::::::::::::::::::::::::::::::::::::::::
          Dual Pulse: Apply transient pulse timing
          ::::::::::::::::::::::::::::::::::::::::*/
        {
            U_PSPTiming_CPU TimingObj;
            TimingObj.SoftStopHardDur.sSoftStopAngle = eoi;
            TimingObj.SoftStopHardDur.sHardStopAngle = eoi;
            TimingObj.SoftStopHardDur.uHardDuration_uS = durationTransient;
	
            /* Apply timing before we enable to ensure that there are valid timings when the pulse is enabled */
            /* Don't employ PSP_TIMING_UPDATE_AFFECT_ASSERTED_PULSE on the transient pulse because if it is ON*/
            /*   then increasing the duration will achieve little because we will hit the end stop anyway     */
            BasicOut_PSP_Timing_Set(&INJ5, 1, PSP_SOFTSTOP_HARDDURATION, &TimingObj,
            PSP_TIMING_IMMEDIATE_UPDATE | PSP_TIMING_WANT_END_EVENT_ISR);

		
            /* We must only enable the transient pulse afer the primary pulse has completed. Otherwise we risk */
            /* enabling whilst an active primary pulse with the old timing (i.e. a pulse that was active prior */
            /* to the transient modified primary timing having been applied) that also happens to overlap with */
			/* the transient pulse timing. The transition will result in a missed pulse in such a situation.   */
			/* The code already forces the transient to disabled if the primary is not enabled and so we know  */
			/*   that a primary pulse has been scheduled.                                                      */
            if (INJ5_PSPOutput_PrevCondition[1] == PSP_RES_DISABLED )
            {
                INJ5_PSPOutput_ApplyTransientCondOnEndPrim = TRUE;
                INJ5_PSPOutput_PrevCondition[1] = TRUE;
            }
			
        }
    }
    else
 
    {
        /*::::::::::::::::::::::::::::::::::::::::
          Single Pulse: Apply primary pulse timing
          ::::::::::::::::::::::::::::::::::::::::*/
        uint32_T u32DurationAsAnAngle;
        uint16_T u16InstantRPM;
        U_PSPTiming_CPU TimingObj;

        TimingObj.HardStart.sStartAngle = startAnglePrimary;
        TimingObj.HardStart.uHardDuration_uS = durationPrimary;

        /* Need RPM to approximate the angular duration of the primary pulse */
        u16InstantRPM = CNK_Encoder_InstantRPM_Get();

        /* DurationAsAnAngle = (Duration x RPM x 360x16) / 60,000,000
           DurationAsAnAngle = (Duration x RPM x 3x16) / 500,000
           DurationAsAnAngle = (Duration x RPM x 3) / 31250 */
        u32DurationAsAnAngle = durationPrimary * u16InstantRPM;
        u32DurationAsAnAngle = u32DurationAsAnAngle * 3U;
        u32DurationAsAnAngle = u32DurationAsAnAngle / 31250U;

        if (u32DurationAsAnAngle > sNumDegreeInCycle / 2U)
        {   /* Duration is approach half a cycle so set the hard stop based upon the minimum displacement value */
            TimingObj.HardStart.sHardStopAngle = TimingObj.HardStart.sStartAngle + sMinDisplacementForPulseScheduling;
        }
        else
        {    /* Duration is not approaching even half a cycle so apply some margin on the hard stop */
             TimingObj.HardStart.sHardStopAngle = (sNumDegreeInCycle / 4U) + TimingObj.HardStart.sStartAngle;
        }

        /* Apply timing before we enable to ensure that there are valid timings when the pulse is enabled */
        BasicOut_PSP_Timing_Set(&INJ5, 0, PSP_HARDSTART_HARDDURATION, &TimingObj,    
        PSP_TIMING_IMMEDIATE_UPDATE | PSP_TIMING_UPDATE_AFFECT_ASSERTED_PULSE | PSP_TIMING_WANT_END_EVENT_ISR);

        if (eStatePrimary != INJ5_PSPOutput_PrevCondition[0])
        {
            INJ5_PSPOutput_PrevCondition[0] = (boolean_T)eStatePrimary;
            BasicOut_PSP_Condition_Set(&INJ5, 0, eStatePrimary);
        }


        /* Expectation is that the Transient State is PSP_RES_DISABLED if we are here */
        if (PSP_RES_DISABLED != INJ5_PSPOutput_PrevCondition[1])
        {
            /* Have not applied the disable yet - so apply it */
            INJ5_PSPOutput_PrevCondition[1] = PSP_RES_DISABLED;
		
            /* Cancel any pending enables */
            INJ5_PSPOutput_ApplyTransientCondOnEndPrim = FALSE;
		
            BasicOut_PSP_Condition_Set(&INJ5, 1, PSP_RES_DISABLED);
        }

        /* The transient pulse should now be disabled and so there are no applicable timings that we need to set
           Timings will be re-applied before the pulse is enabled again */
 
    }
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: INJ5_PSPOutput_MinDisplacementForPulseScheduling_Get
::
:: Returns what the minimum angular spacing between two angles of different pulses needs to be
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
int16_T INJ5_PSPOutput_MinDisplacementForPulseScheduling_Get(void)
{
    return(BasicOut_PSP_MinAdjacentPulseSpacing_Get(&INJ5));
}

static void INJ5_PSPOutput_OnPulseEnd_Callback(struct S_BasicOut_Defn_PSP const* const pThisPSP, S_PSPEndOfEventReport* const pReport)
{
    if(pReport)
    {

        INJ5_PSPOutput_TransientBehavior_OnEndOfPulse(pReport->uPulse);

        {

            extern void Trigger_Trans_INJ5(uint8_T uPulse, boolean_T bIsDurationValid, uint32_T uDeliveredDuration_uS);
Trigger_Trans_INJ5(pReport->uPulse, (boolean_T)pReport->bIsDurationValid, pReport->uDeliveredDuration_uS);

        }
    }
}
void INJ5_PSPOutput_Stop(void)
{
	NativeVar_U i=0;
	for(; i < 2; i++) {
		BasicOut_PSP_Condition_Set(&INJ5, i,RES_DISABLED);
	}
}





/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Accessors for INJ6
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void INJ6_PSPOutput_Condition_Set(uint8_T pulse, uint8_T state)
{
    BasicOut_PSP_Condition_Set(&INJ6, pulse, state);
}

static boolean_T INJ6_PSPOutput_PrevCondition[ 2 ] = {0};

static boolean_T INJ6_PSPOutput_ApplyTransientCondOnEndPrim = FALSE;

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: INJ6_PSPOutput_TransientBehavior_OnEndOfPulse
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void INJ6_PSPOutput_TransientBehavior_OnEndOfPulse(uint8_T uPulse)
{
    /* If the primary pulse just ended AND the transient has been flagged to be enabled on end of pulse */
    if ( (uPulse == 0) && (INJ6_PSPOutput_ApplyTransientCondOnEndPrim != FALSE) )
    {
        INJ6_PSPOutput_ApplyTransientCondOnEndPrim = FALSE;
        BasicOut_PSP_Condition_Set(&INJ6, 1, PSP_RES_ENABLED);
    }
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: INJ6_PSPOutput_TransientBehavior_Set
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void INJ6_PSPOutput_TransientBehavior_Set(NativeVar_U statePrimary, int16_T startAnglePrimary, uint32_T durationPrimary, NativeVar_U stateTransient, int16_T stopAngleTransient, uint32_T durationTransient)
{
    NativeVar_S const sMinDisplacementForPulseScheduling = INJ6_PSPOutput_MinDisplacementForPulseScheduling_Get();
    NativeVar_S const sNumDegreeInCycle = CNK_Encoder_NumDegreesPerCycle_Get();
    E_PSPResourceCond eStatePrimary = (E_PSPResourceCond)statePrimary;

    E_PSPResourceCond eStateTransient = (E_PSPResourceCond)stateTransient;

    /* The transient pulse shall be disabled when the primary pulse is disabled, regardless of what is requested */
    if (eStatePrimary != PSP_RES_ENABLED)
    {
        eStateTransient = PSP_RES_DISABLED;
    }

    if (eStateTransient == PSP_RES_ENABLED)
    {   /* Dual Pulse operation */
        NativeVar_S eoi = stopAngleTransient;
        NativeVar_S soi = startAnglePrimary; /* cast to a native so that sign extension is not required while we interact with the signal */

        while (soi < 0)
            soi = soi + sNumDegreeInCycle;
        while (soi >= sNumDegreeInCycle)
            soi = soi - sNumDegreeInCycle;
        while (eoi < 0)
            eoi = eoi + sNumDegreeInCycle;
        while (eoi >= sNumDegreeInCycle)
            eoi = eoi - sNumDegreeInCycle;

        if (soi <= eoi)
        {   /* If eoi exceeds soi, then there must be a difference of sMinDisplacementForPulseScheduling [value is x16 units] degrees between the two */
            if ((eoi - soi) < sMinDisplacementForPulseScheduling)
            {
                eoi = soi + sMinDisplacementForPulseScheduling; /* Don't let the minimum be below uMinDisplacementForPulseScheduling */
            }
        }
        else
        { /* If soi exceeds eoi, then there must be a difference of sMinDisplacementForPulseScheduling [value is x16 units] degrees between the two after soi is wrapped around */
            if ((soi - eoi) > (sNumDegreeInCycle - sMinDisplacementForPulseScheduling))
            {
                eoi = soi + sMinDisplacementForPulseScheduling;
            }
        }

        /*::::::::::::::::::::::::::::::::::::::::
          Dual Pulse: Apply primary pulse timing
          ::::::::::::::::::::::::::::::::::::::::*/
        {
            U_PSPTiming_CPU TimingObj;
            TimingObj.HardStart.sStartAngle = soi;
            TimingObj.HardStart.sHardStopAngle = eoi + sMinDisplacementForPulseScheduling;
            TimingObj.HardStart.uHardDuration_uS = durationPrimary;
	
            BasicOut_PSP_Timing_Set(&INJ6, 0, PSP_HARDSTART_HARDDURATION, &TimingObj,
            PSP_TIMING_IMMEDIATE_UPDATE | PSP_TIMING_UPDATE_AFFECT_ASSERTED_PULSE | PSP_TIMING_WANT_END_EVENT_ISR);

            if (eStatePrimary != INJ6_PSPOutput_PrevCondition[0])
            {
                INJ6_PSPOutput_PrevCondition[0] = (boolean_T)eStatePrimary;
                BasicOut_PSP_Condition_Set(&INJ6, 0, eStatePrimary);
            }
        }

        /*::::::::::::::::::::::::::::::::::::::::
          Dual Pulse: Apply transient pulse timing
          ::::::::::::::::::::::::::::::::::::::::*/
        {
            U_PSPTiming_CPU TimingObj;
            TimingObj.SoftStopHardDur.sSoftStopAngle = eoi;
            TimingObj.SoftStopHardDur.sHardStopAngle = eoi;
            TimingObj.SoftStopHardDur.uHardDuration_uS = durationTransient;
	
            /* Apply timing before we enable to ensure that there are valid timings when the pulse is enabled */
            /* Don't employ PSP_TIMING_UPDATE_AFFECT_ASSERTED_PULSE on the transient pulse because if it is ON*/
            /*   then increasing the duration will achieve little because we will hit the end stop anyway     */
            BasicOut_PSP_Timing_Set(&INJ6, 1, PSP_SOFTSTOP_HARDDURATION, &TimingObj,
            PSP_TIMING_IMMEDIATE_UPDATE | PSP_TIMING_WANT_END_EVENT_ISR);

		
            /* We must only enable the transient pulse afer the primary pulse has completed. Otherwise we risk */
            /* enabling whilst an active primary pulse with the old timing (i.e. a pulse that was active prior */
            /* to the transient modified primary timing having been applied) that also happens to overlap with */
			/* the transient pulse timing. The transition will result in a missed pulse in such a situation.   */
			/* The code already forces the transient to disabled if the primary is not enabled and so we know  */
			/*   that a primary pulse has been scheduled.                                                      */
            if (INJ6_PSPOutput_PrevCondition[1] == PSP_RES_DISABLED )
            {
                INJ6_PSPOutput_ApplyTransientCondOnEndPrim = TRUE;
                INJ6_PSPOutput_PrevCondition[1] = TRUE;
            }
			
        }
    }
    else
 
    {
        /*::::::::::::::::::::::::::::::::::::::::
          Single Pulse: Apply primary pulse timing
          ::::::::::::::::::::::::::::::::::::::::*/
        uint32_T u32DurationAsAnAngle;
        uint16_T u16InstantRPM;
        U_PSPTiming_CPU TimingObj;

        TimingObj.HardStart.sStartAngle = startAnglePrimary;
        TimingObj.HardStart.uHardDuration_uS = durationPrimary;

        /* Need RPM to approximate the angular duration of the primary pulse */
        u16InstantRPM = CNK_Encoder_InstantRPM_Get();

        /* DurationAsAnAngle = (Duration x RPM x 360x16) / 60,000,000
           DurationAsAnAngle = (Duration x RPM x 3x16) / 500,000
           DurationAsAnAngle = (Duration x RPM x 3) / 31250 */
        u32DurationAsAnAngle = durationPrimary * u16InstantRPM;
        u32DurationAsAnAngle = u32DurationAsAnAngle * 3U;
        u32DurationAsAnAngle = u32DurationAsAnAngle / 31250U;

        if (u32DurationAsAnAngle > sNumDegreeInCycle / 2U)
        {   /* Duration is approach half a cycle so set the hard stop based upon the minimum displacement value */
            TimingObj.HardStart.sHardStopAngle = TimingObj.HardStart.sStartAngle + sMinDisplacementForPulseScheduling;
        }
        else
        {    /* Duration is not approaching even half a cycle so apply some margin on the hard stop */
             TimingObj.HardStart.sHardStopAngle = (sNumDegreeInCycle / 4U) + TimingObj.HardStart.sStartAngle;
        }

        /* Apply timing before we enable to ensure that there are valid timings when the pulse is enabled */
        BasicOut_PSP_Timing_Set(&INJ6, 0, PSP_HARDSTART_HARDDURATION, &TimingObj,    
        PSP_TIMING_IMMEDIATE_UPDATE | PSP_TIMING_UPDATE_AFFECT_ASSERTED_PULSE | PSP_TIMING_WANT_END_EVENT_ISR);

        if (eStatePrimary != INJ6_PSPOutput_PrevCondition[0])
        {
            INJ6_PSPOutput_PrevCondition[0] = (boolean_T)eStatePrimary;
            BasicOut_PSP_Condition_Set(&INJ6, 0, eStatePrimary);
        }


        /* Expectation is that the Transient State is PSP_RES_DISABLED if we are here */
        if (PSP_RES_DISABLED != INJ6_PSPOutput_PrevCondition[1])
        {
            /* Have not applied the disable yet - so apply it */
            INJ6_PSPOutput_PrevCondition[1] = PSP_RES_DISABLED;
		
            /* Cancel any pending enables */
            INJ6_PSPOutput_ApplyTransientCondOnEndPrim = FALSE;
		
            BasicOut_PSP_Condition_Set(&INJ6, 1, PSP_RES_DISABLED);
        }

        /* The transient pulse should now be disabled and so there are no applicable timings that we need to set
           Timings will be re-applied before the pulse is enabled again */
 
    }
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: INJ6_PSPOutput_MinDisplacementForPulseScheduling_Get
::
:: Returns what the minimum angular spacing between two angles of different pulses needs to be
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
int16_T INJ6_PSPOutput_MinDisplacementForPulseScheduling_Get(void)
{
    return(BasicOut_PSP_MinAdjacentPulseSpacing_Get(&INJ6));
}

static void INJ6_PSPOutput_OnPulseEnd_Callback(struct S_BasicOut_Defn_PSP const* const pThisPSP, S_PSPEndOfEventReport* const pReport)
{
    if(pReport)
    {

        INJ6_PSPOutput_TransientBehavior_OnEndOfPulse(pReport->uPulse);

        {

            extern void Trigger_Trans_INJ6(uint8_T uPulse, boolean_T bIsDurationValid, uint32_T uDeliveredDuration_uS);
Trigger_Trans_INJ6(pReport->uPulse, (boolean_T)pReport->bIsDurationValid, pReport->uDeliveredDuration_uS);

        }
    }
}
void INJ6_PSPOutput_Stop(void)
{
	NativeVar_U i=0;
	for(; i < 2; i++) {
		BasicOut_PSP_Condition_Set(&INJ6, i,RES_DISABLED);
	}
}





/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Accessors for INJ7
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void INJ7_PSPOutput_Condition_Set(uint8_T pulse, uint8_T state)
{
    BasicOut_PSP_Condition_Set(&INJ7, pulse, state);
}

static boolean_T INJ7_PSPOutput_PrevCondition[ 2 ] = {0};

static boolean_T INJ7_PSPOutput_ApplyTransientCondOnEndPrim = FALSE;

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: INJ7_PSPOutput_TransientBehavior_OnEndOfPulse
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void INJ7_PSPOutput_TransientBehavior_OnEndOfPulse(uint8_T uPulse)
{
    /* If the primary pulse just ended AND the transient has been flagged to be enabled on end of pulse */
    if ( (uPulse == 0) && (INJ7_PSPOutput_ApplyTransientCondOnEndPrim != FALSE) )
    {
        INJ7_PSPOutput_ApplyTransientCondOnEndPrim = FALSE;
        BasicOut_PSP_Condition_Set(&INJ7, 1, PSP_RES_ENABLED);
    }
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: INJ7_PSPOutput_TransientBehavior_Set
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void INJ7_PSPOutput_TransientBehavior_Set(NativeVar_U statePrimary, int16_T startAnglePrimary, uint32_T durationPrimary, NativeVar_U stateTransient, int16_T stopAngleTransient, uint32_T durationTransient)
{
    NativeVar_S const sMinDisplacementForPulseScheduling = INJ7_PSPOutput_MinDisplacementForPulseScheduling_Get();
    NativeVar_S const sNumDegreeInCycle = CNK_Encoder_NumDegreesPerCycle_Get();
    E_PSPResourceCond eStatePrimary = (E_PSPResourceCond)statePrimary;

    E_PSPResourceCond eStateTransient = (E_PSPResourceCond)stateTransient;

    /* The transient pulse shall be disabled when the primary pulse is disabled, regardless of what is requested */
    if (eStatePrimary != PSP_RES_ENABLED)
    {
        eStateTransient = PSP_RES_DISABLED;
    }

    if (eStateTransient == PSP_RES_ENABLED)
    {   /* Dual Pulse operation */
        NativeVar_S eoi = stopAngleTransient;
        NativeVar_S soi = startAnglePrimary; /* cast to a native so that sign extension is not required while we interact with the signal */

        while (soi < 0)
            soi = soi + sNumDegreeInCycle;
        while (soi >= sNumDegreeInCycle)
            soi = soi - sNumDegreeInCycle;
        while (eoi < 0)
            eoi = eoi + sNumDegreeInCycle;
        while (eoi >= sNumDegreeInCycle)
            eoi = eoi - sNumDegreeInCycle;

        if (soi <= eoi)
        {   /* If eoi exceeds soi, then there must be a difference of sMinDisplacementForPulseScheduling [value is x16 units] degrees between the two */
            if ((eoi - soi) < sMinDisplacementForPulseScheduling)
            {
                eoi = soi + sMinDisplacementForPulseScheduling; /* Don't let the minimum be below uMinDisplacementForPulseScheduling */
            }
        }
        else
        { /* If soi exceeds eoi, then there must be a difference of sMinDisplacementForPulseScheduling [value is x16 units] degrees between the two after soi is wrapped around */
            if ((soi - eoi) > (sNumDegreeInCycle - sMinDisplacementForPulseScheduling))
            {
                eoi = soi + sMinDisplacementForPulseScheduling;
            }
        }

        /*::::::::::::::::::::::::::::::::::::::::
          Dual Pulse: Apply primary pulse timing
          ::::::::::::::::::::::::::::::::::::::::*/
        {
            U_PSPTiming_CPU TimingObj;
            TimingObj.HardStart.sStartAngle = soi;
            TimingObj.HardStart.sHardStopAngle = eoi + sMinDisplacementForPulseScheduling;
            TimingObj.HardStart.uHardDuration_uS = durationPrimary;
	
            BasicOut_PSP_Timing_Set(&INJ7, 0, PSP_HARDSTART_HARDDURATION, &TimingObj,
            PSP_TIMING_IMMEDIATE_UPDATE | PSP_TIMING_UPDATE_AFFECT_ASSERTED_PULSE | PSP_TIMING_WANT_END_EVENT_ISR);

            if (eStatePrimary != INJ7_PSPOutput_PrevCondition[0])
            {
                INJ7_PSPOutput_PrevCondition[0] = (boolean_T)eStatePrimary;
                BasicOut_PSP_Condition_Set(&INJ7, 0, eStatePrimary);
            }
        }

        /*::::::::::::::::::::::::::::::::::::::::
          Dual Pulse: Apply transient pulse timing
          ::::::::::::::::::::::::::::::::::::::::*/
        {
            U_PSPTiming_CPU TimingObj;
            TimingObj.SoftStopHardDur.sSoftStopAngle = eoi;
            TimingObj.SoftStopHardDur.sHardStopAngle = eoi;
            TimingObj.SoftStopHardDur.uHardDuration_uS = durationTransient;
	
            /* Apply timing before we enable to ensure that there are valid timings when the pulse is enabled */
            /* Don't employ PSP_TIMING_UPDATE_AFFECT_ASSERTED_PULSE on the transient pulse because if it is ON*/
            /*   then increasing the duration will achieve little because we will hit the end stop anyway     */
            BasicOut_PSP_Timing_Set(&INJ7, 1, PSP_SOFTSTOP_HARDDURATION, &TimingObj,
            PSP_TIMING_IMMEDIATE_UPDATE | PSP_TIMING_WANT_END_EVENT_ISR);

		
            /* We must only enable the transient pulse afer the primary pulse has completed. Otherwise we risk */
            /* enabling whilst an active primary pulse with the old timing (i.e. a pulse that was active prior */
            /* to the transient modified primary timing having been applied) that also happens to overlap with */
			/* the transient pulse timing. The transition will result in a missed pulse in such a situation.   */
			/* The code already forces the transient to disabled if the primary is not enabled and so we know  */
			/*   that a primary pulse has been scheduled.                                                      */
            if (INJ7_PSPOutput_PrevCondition[1] == PSP_RES_DISABLED )
            {
                INJ7_PSPOutput_ApplyTransientCondOnEndPrim = TRUE;
                INJ7_PSPOutput_PrevCondition[1] = TRUE;
            }
			
        }
    }
    else
 
    {
        /*::::::::::::::::::::::::::::::::::::::::
          Single Pulse: Apply primary pulse timing
          ::::::::::::::::::::::::::::::::::::::::*/
        uint32_T u32DurationAsAnAngle;
        uint16_T u16InstantRPM;
        U_PSPTiming_CPU TimingObj;

        TimingObj.HardStart.sStartAngle = startAnglePrimary;
        TimingObj.HardStart.uHardDuration_uS = durationPrimary;

        /* Need RPM to approximate the angular duration of the primary pulse */
        u16InstantRPM = CNK_Encoder_InstantRPM_Get();

        /* DurationAsAnAngle = (Duration x RPM x 360x16) / 60,000,000
           DurationAsAnAngle = (Duration x RPM x 3x16) / 500,000
           DurationAsAnAngle = (Duration x RPM x 3) / 31250 */
        u32DurationAsAnAngle = durationPrimary * u16InstantRPM;
        u32DurationAsAnAngle = u32DurationAsAnAngle * 3U;
        u32DurationAsAnAngle = u32DurationAsAnAngle / 31250U;

        if (u32DurationAsAnAngle > sNumDegreeInCycle / 2U)
        {   /* Duration is approach half a cycle so set the hard stop based upon the minimum displacement value */
            TimingObj.HardStart.sHardStopAngle = TimingObj.HardStart.sStartAngle + sMinDisplacementForPulseScheduling;
        }
        else
        {    /* Duration is not approaching even half a cycle so apply some margin on the hard stop */
             TimingObj.HardStart.sHardStopAngle = (sNumDegreeInCycle / 4U) + TimingObj.HardStart.sStartAngle;
        }

        /* Apply timing before we enable to ensure that there are valid timings when the pulse is enabled */
        BasicOut_PSP_Timing_Set(&INJ7, 0, PSP_HARDSTART_HARDDURATION, &TimingObj,    
        PSP_TIMING_IMMEDIATE_UPDATE | PSP_TIMING_UPDATE_AFFECT_ASSERTED_PULSE | PSP_TIMING_WANT_END_EVENT_ISR);

        if (eStatePrimary != INJ7_PSPOutput_PrevCondition[0])
        {
            INJ7_PSPOutput_PrevCondition[0] = (boolean_T)eStatePrimary;
            BasicOut_PSP_Condition_Set(&INJ7, 0, eStatePrimary);
        }


        /* Expectation is that the Transient State is PSP_RES_DISABLED if we are here */
        if (PSP_RES_DISABLED != INJ7_PSPOutput_PrevCondition[1])
        {
            /* Have not applied the disable yet - so apply it */
            INJ7_PSPOutput_PrevCondition[1] = PSP_RES_DISABLED;
		
            /* Cancel any pending enables */
            INJ7_PSPOutput_ApplyTransientCondOnEndPrim = FALSE;
		
            BasicOut_PSP_Condition_Set(&INJ7, 1, PSP_RES_DISABLED);
        }

        /* The transient pulse should now be disabled and so there are no applicable timings that we need to set
           Timings will be re-applied before the pulse is enabled again */
 
    }
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: INJ7_PSPOutput_MinDisplacementForPulseScheduling_Get
::
:: Returns what the minimum angular spacing between two angles of different pulses needs to be
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
int16_T INJ7_PSPOutput_MinDisplacementForPulseScheduling_Get(void)
{
    return(BasicOut_PSP_MinAdjacentPulseSpacing_Get(&INJ7));
}

static void INJ7_PSPOutput_OnPulseEnd_Callback(struct S_BasicOut_Defn_PSP const* const pThisPSP, S_PSPEndOfEventReport* const pReport)
{
    if(pReport)
    {

        INJ7_PSPOutput_TransientBehavior_OnEndOfPulse(pReport->uPulse);

        {

            extern void Trigger_Trans_INJ7(uint8_T uPulse, boolean_T bIsDurationValid, uint32_T uDeliveredDuration_uS);
Trigger_Trans_INJ7(pReport->uPulse, (boolean_T)pReport->bIsDurationValid, pReport->uDeliveredDuration_uS);

        }
    }
}
void INJ7_PSPOutput_Stop(void)
{
	NativeVar_U i=0;
	for(; i < 2; i++) {
		BasicOut_PSP_Condition_Set(&INJ7, i,RES_DISABLED);
	}
}





/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Accessors for INJ8
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void INJ8_PSPOutput_Condition_Set(uint8_T pulse, uint8_T state)
{
    BasicOut_PSP_Condition_Set(&INJ8, pulse, state);
}

static boolean_T INJ8_PSPOutput_PrevCondition[ 2 ] = {0};

static boolean_T INJ8_PSPOutput_ApplyTransientCondOnEndPrim = FALSE;

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: INJ8_PSPOutput_TransientBehavior_OnEndOfPulse
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void INJ8_PSPOutput_TransientBehavior_OnEndOfPulse(uint8_T uPulse)
{
    /* If the primary pulse just ended AND the transient has been flagged to be enabled on end of pulse */
    if ( (uPulse == 0) && (INJ8_PSPOutput_ApplyTransientCondOnEndPrim != FALSE) )
    {
        INJ8_PSPOutput_ApplyTransientCondOnEndPrim = FALSE;
        BasicOut_PSP_Condition_Set(&INJ8, 1, PSP_RES_ENABLED);
    }
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: INJ8_PSPOutput_TransientBehavior_Set
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void INJ8_PSPOutput_TransientBehavior_Set(NativeVar_U statePrimary, int16_T startAnglePrimary, uint32_T durationPrimary, NativeVar_U stateTransient, int16_T stopAngleTransient, uint32_T durationTransient)
{
    NativeVar_S const sMinDisplacementForPulseScheduling = INJ8_PSPOutput_MinDisplacementForPulseScheduling_Get();
    NativeVar_S const sNumDegreeInCycle = CNK_Encoder_NumDegreesPerCycle_Get();
    E_PSPResourceCond eStatePrimary = (E_PSPResourceCond)statePrimary;

    E_PSPResourceCond eStateTransient = (E_PSPResourceCond)stateTransient;

    /* The transient pulse shall be disabled when the primary pulse is disabled, regardless of what is requested */
    if (eStatePrimary != PSP_RES_ENABLED)
    {
        eStateTransient = PSP_RES_DISABLED;
    }

    if (eStateTransient == PSP_RES_ENABLED)
    {   /* Dual Pulse operation */
        NativeVar_S eoi = stopAngleTransient;
        NativeVar_S soi = startAnglePrimary; /* cast to a native so that sign extension is not required while we interact with the signal */

        while (soi < 0)
            soi = soi + sNumDegreeInCycle;
        while (soi >= sNumDegreeInCycle)
            soi = soi - sNumDegreeInCycle;
        while (eoi < 0)
            eoi = eoi + sNumDegreeInCycle;
        while (eoi >= sNumDegreeInCycle)
            eoi = eoi - sNumDegreeInCycle;

        if (soi <= eoi)
        {   /* If eoi exceeds soi, then there must be a difference of sMinDisplacementForPulseScheduling [value is x16 units] degrees between the two */
            if ((eoi - soi) < sMinDisplacementForPulseScheduling)
            {
                eoi = soi + sMinDisplacementForPulseScheduling; /* Don't let the minimum be below uMinDisplacementForPulseScheduling */
            }
        }
        else
        { /* If soi exceeds eoi, then there must be a difference of sMinDisplacementForPulseScheduling [value is x16 units] degrees between the two after soi is wrapped around */
            if ((soi - eoi) > (sNumDegreeInCycle - sMinDisplacementForPulseScheduling))
            {
                eoi = soi + sMinDisplacementForPulseScheduling;
            }
        }

        /*::::::::::::::::::::::::::::::::::::::::
          Dual Pulse: Apply primary pulse timing
          ::::::::::::::::::::::::::::::::::::::::*/
        {
            U_PSPTiming_CPU TimingObj;
            TimingObj.HardStart.sStartAngle = soi;
            TimingObj.HardStart.sHardStopAngle = eoi + sMinDisplacementForPulseScheduling;
            TimingObj.HardStart.uHardDuration_uS = durationPrimary;
	
            BasicOut_PSP_Timing_Set(&INJ8, 0, PSP_HARDSTART_HARDDURATION, &TimingObj,
            PSP_TIMING_IMMEDIATE_UPDATE | PSP_TIMING_UPDATE_AFFECT_ASSERTED_PULSE | PSP_TIMING_WANT_END_EVENT_ISR);

            if (eStatePrimary != INJ8_PSPOutput_PrevCondition[0])
            {
                INJ8_PSPOutput_PrevCondition[0] = (boolean_T)eStatePrimary;
                BasicOut_PSP_Condition_Set(&INJ8, 0, eStatePrimary);
            }
        }

        /*::::::::::::::::::::::::::::::::::::::::
          Dual Pulse: Apply transient pulse timing
          ::::::::::::::::::::::::::::::::::::::::*/
        {
            U_PSPTiming_CPU TimingObj;
            TimingObj.SoftStopHardDur.sSoftStopAngle = eoi;
            TimingObj.SoftStopHardDur.sHardStopAngle = eoi;
            TimingObj.SoftStopHardDur.uHardDuration_uS = durationTransient;
	
            /* Apply timing before we enable to ensure that there are valid timings when the pulse is enabled */
            /* Don't employ PSP_TIMING_UPDATE_AFFECT_ASSERTED_PULSE on the transient pulse because if it is ON*/
            /*   then increasing the duration will achieve little because we will hit the end stop anyway     */
            BasicOut_PSP_Timing_Set(&INJ8, 1, PSP_SOFTSTOP_HARDDURATION, &TimingObj,
            PSP_TIMING_IMMEDIATE_UPDATE | PSP_TIMING_WANT_END_EVENT_ISR);

		
            /* We must only enable the transient pulse afer the primary pulse has completed. Otherwise we risk */
            /* enabling whilst an active primary pulse with the old timing (i.e. a pulse that was active prior */
            /* to the transient modified primary timing having been applied) that also happens to overlap with */
			/* the transient pulse timing. The transition will result in a missed pulse in such a situation.   */
			/* The code already forces the transient to disabled if the primary is not enabled and so we know  */
			/*   that a primary pulse has been scheduled.                                                      */
            if (INJ8_PSPOutput_PrevCondition[1] == PSP_RES_DISABLED )
            {
                INJ8_PSPOutput_ApplyTransientCondOnEndPrim = TRUE;
                INJ8_PSPOutput_PrevCondition[1] = TRUE;
            }
			
        }
    }
    else
 
    {
        /*::::::::::::::::::::::::::::::::::::::::
          Single Pulse: Apply primary pulse timing
          ::::::::::::::::::::::::::::::::::::::::*/
        uint32_T u32DurationAsAnAngle;
        uint16_T u16InstantRPM;
        U_PSPTiming_CPU TimingObj;

        TimingObj.HardStart.sStartAngle = startAnglePrimary;
        TimingObj.HardStart.uHardDuration_uS = durationPrimary;

        /* Need RPM to approximate the angular duration of the primary pulse */
        u16InstantRPM = CNK_Encoder_InstantRPM_Get();

        /* DurationAsAnAngle = (Duration x RPM x 360x16) / 60,000,000
           DurationAsAnAngle = (Duration x RPM x 3x16) / 500,000
           DurationAsAnAngle = (Duration x RPM x 3) / 31250 */
        u32DurationAsAnAngle = durationPrimary * u16InstantRPM;
        u32DurationAsAnAngle = u32DurationAsAnAngle * 3U;
        u32DurationAsAnAngle = u32DurationAsAnAngle / 31250U;

        if (u32DurationAsAnAngle > sNumDegreeInCycle / 2U)
        {   /* Duration is approach half a cycle so set the hard stop based upon the minimum displacement value */
            TimingObj.HardStart.sHardStopAngle = TimingObj.HardStart.sStartAngle + sMinDisplacementForPulseScheduling;
        }
        else
        {    /* Duration is not approaching even half a cycle so apply some margin on the hard stop */
             TimingObj.HardStart.sHardStopAngle = (sNumDegreeInCycle / 4U) + TimingObj.HardStart.sStartAngle;
        }

        /* Apply timing before we enable to ensure that there are valid timings when the pulse is enabled */
        BasicOut_PSP_Timing_Set(&INJ8, 0, PSP_HARDSTART_HARDDURATION, &TimingObj,    
        PSP_TIMING_IMMEDIATE_UPDATE | PSP_TIMING_UPDATE_AFFECT_ASSERTED_PULSE | PSP_TIMING_WANT_END_EVENT_ISR);

        if (eStatePrimary != INJ8_PSPOutput_PrevCondition[0])
        {
            INJ8_PSPOutput_PrevCondition[0] = (boolean_T)eStatePrimary;
            BasicOut_PSP_Condition_Set(&INJ8, 0, eStatePrimary);
        }


        /* Expectation is that the Transient State is PSP_RES_DISABLED if we are here */
        if (PSP_RES_DISABLED != INJ8_PSPOutput_PrevCondition[1])
        {
            /* Have not applied the disable yet - so apply it */
            INJ8_PSPOutput_PrevCondition[1] = PSP_RES_DISABLED;
		
            /* Cancel any pending enables */
            INJ8_PSPOutput_ApplyTransientCondOnEndPrim = FALSE;
		
            BasicOut_PSP_Condition_Set(&INJ8, 1, PSP_RES_DISABLED);
        }

        /* The transient pulse should now be disabled and so there are no applicable timings that we need to set
           Timings will be re-applied before the pulse is enabled again */
 
    }
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: INJ8_PSPOutput_MinDisplacementForPulseScheduling_Get
::
:: Returns what the minimum angular spacing between two angles of different pulses needs to be
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
int16_T INJ8_PSPOutput_MinDisplacementForPulseScheduling_Get(void)
{
    return(BasicOut_PSP_MinAdjacentPulseSpacing_Get(&INJ8));
}

static void INJ8_PSPOutput_OnPulseEnd_Callback(struct S_BasicOut_Defn_PSP const* const pThisPSP, S_PSPEndOfEventReport* const pReport)
{
    if(pReport)
    {

        INJ8_PSPOutput_TransientBehavior_OnEndOfPulse(pReport->uPulse);

        {

            extern void Trigger_Trans_INJ8(uint8_T uPulse, boolean_T bIsDurationValid, uint32_T uDeliveredDuration_uS);
Trigger_Trans_INJ8(pReport->uPulse, (boolean_T)pReport->bIsDurationValid, pReport->uDeliveredDuration_uS);

        }
    }
}
void INJ8_PSPOutput_Stop(void)
{
	NativeVar_U i=0;
	for(; i < 2; i++) {
		BasicOut_PSP_Condition_Set(&INJ8, i,RES_DISABLED);
	}
}


