
/* MotoCoder.c */
/* Generated by MotoCoder */
/* Version: 0.12.4 */
/* At: 2022-11-22 13:57:05 */
/* Copyright: 2022 Woodward. */


#include <MotoCoder.h>
#include <AtomicTypes.h>
#include <Processor.h>
#include <Processor_Generic.h>
#include <Module_Generic.h>
#include <DeviceDrivers_Generic.h>
#include <TaskKernel_GenAPI.h>
#include <stdio.h>
#include <MPC55xxFlash_API.h>
#include <FMPLL_Reg.h>
#include <BootInterface.h>
#include <string.h>

extern const S_AnalogQueueDefn ContinuousScan_eQADCQueue;
	

extern const S_AnalogQueueDefn ESTDiagnostics_eQADCQueue;
	

/* Main Application */
const boolean_T g_bEnableControlledShutdown = 1;
const boolean_T g_bEnableWatchdog = 1;
    
/* Name: MotoCoderVersionTxt ClassID:TEXT StorageID:CODE Access:RO4+RO3+RO2+RO1 UpdateID:ONCE TextLen:7
Group:"System | Version" Help:"MotoCoder version used to build the application." */
const uint8_T MotoCoderVersionTxt[7] = "0.12.4";

    
/* Name: PeakHeapBytesUsed ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT4 CType:uint32_T Struct:g_u32PeakHeapBytesUsed
Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0.000000 Max:4294967295.000000 Format:9.0 UpdateID:BACKGND
Group:"System | Memory" Help:"Maximum number of bytes used on the heap since startup" Unit:bytes */
void Module_Shutdown(boolean_T shutdownPower)
{
    {
        extern boolean_T g_bAppOpen;
        g_bAppOpen = 0;
    }
    
    
    {extern void CloseApplication(void);
        CloseApplication();
    }
    {extern void IO_Stop(void);
        IO_Stop();
    }
    {extern void SaveCalibration(void);
        SaveCalibration();
    }
    {extern void NonVolatile_CloseDataStore(void);
        NonVolatile_CloseDataStore();
    }

    /* When requested, shutdown power-supply on modules with an internal power-supply device.
       When reprogramming, for example, the power-supply should not be turned off,
       but the remaining shutdown procedure should still occur.
    */
    if (shutdownPower) {
		
        ModuleSupport_PowerSupply_Shutdown();
		

        Task_Sleep(5000);
			
        ModuleSupport_Reset();
		
    }
}

uint64_T g_Timer_FreeRunningCounter_TimeAtReset;
void Timer_FreeRunningCounter_ResetTime(void)
{
    Timer_FreeRunningCounter_Get64Bits(&g_Timer_FreeRunningCounter_TimeAtReset);
}
void Timer_FreeRunningCounter_GetTime(uint32_T *lower32Bits_us, uint32_T *upper32Bits_us)
{
	/* Timer_CurrentTime is static, so that it will be aligned */
	static uint64_T Timer_CurrentTime;

	Interrupt_Disable();

	/* Get the free running counter */
    Timer_FreeRunningCounter_Get64Bits(&Timer_CurrentTime);
	
    /* Update the current time since reset */
    Timer_CurrentTime = Timer_CurrentTime - g_Timer_FreeRunningCounter_TimeAtReset;
	
    /* Convert the current time since reset in ticks to uSec */
    Timer_CurrentTime = Timer_FreeRunningCounter_Get64BitTimeFromTicks(Timer_CurrentTime);
	
    
    if (upper32Bits_us) {
		*upper32Bits_us = (Timer_CurrentTime >> 32);
	}
	if (lower32Bits_us) {
		*lower32Bits_us = Timer_CurrentTime & 0x00000000FFFFFFFF;
	}
        
    
    Interrupt_Enable();
}
uint32_T Timer_FreeRunningCounter_GetRawTicksFromTime(uint32_T u32Time_us)
{
	return Timer_FreeRunningCounter_GetTicksFromTime(u32Time_us);
}
uint32_T Timer_FreeRunningCounter_GetDeltaUpdateReference_us(uint32_T * pReference_lower32Bits, uint32_T *pReference_upper32Bits)
{
    
		if (!pReference_upper32Bits)
		{
			return Timer_FreeRunningCounter_GetDiffAndUpdate_us(pReference_lower32Bits);
		}
		else if(pReference_upper32Bits && pReference_lower32Bits)
		{
			uint64_T u64Reference = (uint64_T)(((uint64_T)(*pReference_upper32Bits) << 32) | *pReference_lower32Bits);
			uint32_T u32Result = (uint32_T)Timer_FreeRunningCounter_Get64BitDiffAndUpdate_us(&u64Reference);
			*pReference_upper32Bits = (u64Reference >> 32);
			*pReference_lower32Bits = u64Reference & 0x00000000FFFFFFFF;
			return u32Result;
		}
		else
		{
			return 0;
		}
        
}

uint32_T u4LastRandomNumber = 0;
void RandomNumber_Get(uint32_T* out_pNumber)
{
 uint32_T FreeRunningCount;
 Timer_FreeRunningCounter_GetTime(&FreeRunningCount, NULL);
 u4LastRandomNumber = u4LastRandomNumber * 1103515245 + FreeRunningCount;
 
 *out_pNumber = u4LastRandomNumber;
}

/* Main Application */
/*---- RESET CONFIG HALFWORD ------------------------------------------------------------------------------*/
#include <Pragma_Section_Start_RCHW_rodata.h>

/* The Reset Configuration Halfword needs to be set to zero to flag that this block is invalidated against
being a valid boot block. Set to a special value in HardBoot to flag that the block is bootable */
uint32_T const RCHW __SECTION_RHCW_RODATA__ = 0x00000000;

#include <Pragma_Section_End_rodata.h>

/*---- FLASH MEMORY HANDLING ------------------------------------------------------------------------------*/

/* Flash and Calibration Memory */
#define FLASH_START_ADDRESS             (0x00000000UL)

#define FLASH_CALIBRATION_START_ADDRESS (0x001E0000UL)


#define FLASH_CALIBRATION_END_ADDRESS   (0x1FFFBFUL)


#define RAM_CALIBRATION_START_ADDRESS   (0x3ffe0000UL)
#define CALIBRATION_MEMORY_SIZE         (0x1FFC0UL)
    
S_MemoryDeviceDefn const Flash_Memory = S_MemoryDeviceDefn_CONSTRUCTOR(
    /* uFirstValidAddress */      FLASH_START_ADDRESS,
    /* uLastValidAddress  */      FLASH_CALIBRATION_END_ADDRESS,
    /* uFirstValidWriteAddress */ FLASH_CALIBRATION_START_ADDRESS,
    /* uLastValidWriteAddress  */ FLASH_CALIBRATION_END_ADDRESS,
                                  InternalFlash_Registered_ReadSynch,
                                  InternalFlash_Registered_WriteSynch,
                                  NULL,
                                  NULL,
                                  &Flash_Memory);

            

void LoadCalibration(void)
{

    NativeError_S readError = SUCCESS_OK; 
	
    /* Copy calibration section from from FLASH to RAM */
    readError = Memory_ReadSynch(
        (void *) RAM_CALIBRATION_START_ADDRESS, 
        (void *) FLASH_CALIBRATION_START_ADDRESS,
        CALIBRATION_MEMORY_SIZE);
	{
        extern uint16_T Debug_LoadCalibrationError;
        Debug_LoadCalibrationError = (uint16_T) (readError & ERROR_CODE_MASK);
    }
}

void SaveCalibration(void)
{

    NativeError_S writeError = SUCCESS_OK;
	

    /* Only attempt to save the calibration if it is different to what already exists */
    if (memcmp((void *)FLASH_CALIBRATION_START_ADDRESS, (void *)RAM_CALIBRATION_START_ADDRESS, CALIBRATION_MEMORY_SIZE) != 0)
    {
        /* Disable cache and pipelining, and open flash memory for write */
        MPC55xxFlash_Open();
        
        /* Setup region of writable space */
        MPC55xxFlash_Protection_Set(
            (void*)FLASH_CALIBRATION_START_ADDRESS,
            CALIBRATION_MEMORY_SIZE,
            FLASH_MEM_UNPROTECTED);
            
        /* Copy calibration section from from RAM to FLASH */
        writeError = Memory_WriteSynch((void *) FLASH_CALIBRATION_START_ADDRESS, (void *) RAM_CALIBRATION_START_ADDRESS, CALIBRATION_MEMORY_SIZE);
            
        /* Re-enable flash cache and pipelining */
        MPC55xxFlash_Close();
    }
    {
        extern uint16_T Debug_SaveCalibrationError;
        Debug_SaveCalibrationError = (uint16_T) (writeError & ERROR_CODE_MASK);
    }
}

void OpenMemory(void)
{
    /* Register the Flash Memory for Read/Write operations */
    ModuleSupReg_Memory_Register(&Flash_Memory);
       
    LoadCalibration();
}


/*:::: eQADC IRQs :::::::::::::::::::*/

/* eQADC setup */
S_eQADC_ISR_Defn const g_eQADC_ISRArr[NUM_EQADC_ISRS] =
{

/*             { CPU Behavior ISR, Device Specific Context} */
/* eQADC_ISR_FISR        */ {NULL, NULL },
/* eQADC_ISR_FIFO_0_NCF  */	{NULL, NULL },
/* eQADC_ISR_FIFO_0_PF   */	{NULL, NULL },
/* eQADC_ISR_FIFO_0_EOQF */ {NULL, NULL },
/* eQADC_ISR_FIFO_0_CFFF */	{NULL, NULL },
/* eQADC_ISR_FIFO_0_RFDF */	{NULL, NULL },
/* eQADC_ISR_FIFO_1_NCF  */	{NULL, NULL },
/* eQADC_ISR_FIFO_1_PF   */	{NULL, NULL },
/* eQADC_ISR_FIFO_1_EOQF */	{NULL, NULL },
/* eQADC_ISR_FIFO_1_CFFF */	{NULL, NULL },
/* eQADC_ISR_FIFO_1_RFDF */	{NULL, NULL },
/* eQADC_ISR_FIFO_2_NCF  */	{NULL, NULL },
/* eQADC_ISR_FIFO_2_PF   */	{NULL, NULL },
/* eQADC_ISR_FIFO_2_EOQF */	{NULL, NULL },
/* eQADC_ISR_FIFO_2_CFFF */	{NULL, NULL },
/* eQADC_ISR_FIFO_2_RFDF */	{NULL, NULL },
/* eQADC_ISR_FIFO_3_NCF  */	{NULL, NULL },
/* eQADC_ISR_FIFO_3_PF   */	{NULL, NULL },
/* eQADC_ISR_FIFO_3_EOQF */	{NULL, NULL },
/* eQADC_ISR_FIFO_3_CFFF */	{NULL, NULL },
/* eQADC_ISR_FIFO_3_RFDF */	{NULL, NULL },
/* eQADC_ISR_FIFO_4_NCF  */	{NULL, NULL },
/* eQADC_ISR_FIFO_4_PF   */	{NULL, NULL },
/* eQADC_ISR_FIFO_4_EOQF */	{NULL, NULL },
/* eQADC_ISR_FIFO_4_CFFF */	{NULL, NULL },
/* eQADC_ISR_FIFO_4_RFDF */	{NULL, NULL },
/* eQADC_ISR_FIFO_5_NCF  */	{NULL, NULL },
/* eQADC_ISR_FIFO_5_PF   */	{NULL, NULL },
/* eQADC_ISR_FIFO_5_EOQF */	{NULL, NULL },
/* eQADC_ISR_FIFO_5_CFFF */	{NULL, NULL },
/* eQADC_ISR_FIFO_5_RFDF */	{NULL, NULL },
};

S_eQADC_eDMAISR_Defn const g_eQADC_eDMAISRArr[NUM_EQADC_EDMA_ISRS] =
{
/*   { CPU eDMA Behavior ISR, Device Specific Context } */

/* eQADC_ISR_CFIF_0 */ {NULL, NULL},
/* eQADC_ISR_RFIF_0 */ {NULL, NULL},
		
/* eQADC_ISR_CFIF_1 */ {NULL, NULL},
/* eQADC_ISR_RFIF_1 */ {eQADC_Queue_Sw_Trig_Single_Scan_OnComplete_ISR, &ESTDiagnostics_eQADCQueue},
				
/* eQADC_ISR_CFIF_2 */ {NULL, NULL},
/* eQADC_ISR_RFIF_2 */ {NULL, NULL},
		
/* eQADC_ISR_CFIF_3 */ {NULL, NULL},
/* eQADC_ISR_RFIF_3 */ {NULL, NULL},
		
/* eQADC_ISR_CFIF_4 */ {NULL, NULL},
/* eQADC_ISR_RFIF_4 */ {NULL, NULL},
		
/* eQADC_ISR_CFIF_5 */ {NULL, NULL},
/* eQADC_ISR_RFIF_5 */ {NULL, NULL},
		
};

S_eQADC_ISRObj const g_eQADC_ISRObj =
{
g_eQADC_ISRArr,
g_eQADC_eDMAISRArr,
};



/*---- TASKS AND TRIGGERS --------------------------------------------------------------------------------*/

#define NUM_TASKS (5)	
#define INTERRUPT_STACK_SIZE_IN_BYTES (1280)

InstantiateGlobalTaskingInfo(NUM_TASKS,INTERRUPT_STACK_SIZE_IN_BYTES);

/* Periodic Timer Setup */
uint16_T const g_uRTIPeriodInMicroSecs = 5000;

/* Allowed execution starvation time, before watchdog reset will occur */
uint32_T const g_u32ExecutionStarvationTime_us = 500000;

/* Required main task, which always uses the lowest priority 0, and always uses the variable g_AppTask */
NativeVar_S MainAppTask(void*);
InstantiateTask(g_AppTask, 0, MainAppTask, "MainAppTask", NULL, 1024);

/* Name: IdleStackMinBytesFree ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT2 CType:S_TaskCtrlBlock Struct:g_AppTaskTCB.uBytesFreeOnStackMin
Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0.000000 Max:65535.000000 Format:5.0 UpdateID:BACKGND
Group:"System | Memory" Help:"Remaining bytes available on the Idle stack" Unit:bytes */

/* Name: KernelStackMinBytesFree ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT2 CType:S_TaskCtrlBlock Struct:g_IdleTaskTCB.uBytesFreeOnStackMin
Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0 Max:65535 Format:5.0 UpdateID:BACKGND
Group:"System | Memory" Help:"Remaining bytes available on the Kernel stack" Unit:bytes */

/* Name: InterruptStackMinBytesFree ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT2 CType:uint2 Struct:g_u16InterruptStackMinBytesFree
Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0 Max:65535 Format:5.0 UpdateID:BACKGND
Group:"System | Memory" Help:"Remaining bytes available on the interrupt stack" Unit:bytes */



/* Name: E_PowerUpStatus ClassID:ENUMDEC EnumDflt:"Undefined" */
typedef enum E_PowerUpStatus
{
    COLD_POWERUP = 0, /* EnumTxt:"Cold Powerup" */
    WARM_POWERUP = 1, /* EnumTxt:"Warm Powerup" */
} E_PowerUpStatus;

/* Name: PowerUpStatus CType:uint8_T ClassID:ENUMVAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT1 Gain:1 
   Min:0 Max:1 Format:1.0 UpdateID:SECOND Struct:g_bWasPowerUpStatusWarm EnumDec:E_PowerUpStatus
   Group:"System | Status" Help:"This indicates the power-up state of the system." */
uint8_T g_bWasPowerUpStatusWarm;

/* Instantiate User Tasks */
NativeVar_S MotoCoder_TaskEventQueue_Execute(void *mailBox);

InstantiateMailBox_SingleSemaphore(g_BGNDTask_MailBox);
InstantiateTask(g_BGNDTask, 1, MotoCoder_TaskEventQueue_Execute, "BGNDTask", &g_BGNDTask_MailBox, 1024);
	
/* Name: BGNDTaskStackMinBytesFree ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT2 CType:S_TaskCtrlBlock Struct:g_BGNDTaskTCB.uBytesFreeOnStackMin
Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0.000000 Max:65535.000000 Format:8.0 UpdateID:BACKGND
Group:"System | Memory" Help:"Remaining bytes available on the BGNDTask stack" Unit:bytes */

/* Name: BGNDTaskCPU ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT2 CType:S_TaskCtrlBlock Struct:g_BGNDTaskTCB.u16TimerValue
Mask:FFFFFFFF Gain:0.0015259 Offset:0.0 Exp:1.0 Min:0.000000 Max:100.000000 Format:4.2 UpdateID:BACKGND
Group:"System | Performance" Help:"Percentage of CPU spent on BGNDTask task" Unit:% */
	
InstantiateMailBox_SingleSemaphore(g_FGNDTask_MailBox);
InstantiateTask(g_FGNDTask, 2, MotoCoder_TaskEventQueue_Execute, "FGNDTask", &g_FGNDTask_MailBox, 4096);
	
/* Name: FGNDTaskStackMinBytesFree ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT2 CType:S_TaskCtrlBlock Struct:g_FGNDTaskTCB.uBytesFreeOnStackMin
Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0.000000 Max:65535.000000 Format:8.0 UpdateID:BACKGND
Group:"System | Memory" Help:"Remaining bytes available on the FGNDTask stack" Unit:bytes */

/* Name: FGNDTaskCPU ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT2 CType:S_TaskCtrlBlock Struct:g_FGNDTaskTCB.u16TimerValue
Mask:FFFFFFFF Gain:0.0015259 Offset:0.0 Exp:1.0 Min:0.000000 Max:100.000000 Format:4.2 UpdateID:BACKGND
Group:"System | Performance" Help:"Percentage of CPU spent on FGNDTask task" Unit:% */
	
InstantiateMailBox_SingleSemaphore(g_SHUTDOWNTask_MailBox);
InstantiateTask(g_SHUTDOWNTask, 3, MotoCoder_TaskEventQueue_Execute, "SHUTDOWNTask", &g_SHUTDOWNTask_MailBox, 1024);
	
/* Name: SHUTDOWNTaskStackMinBytesFree ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT2 CType:S_TaskCtrlBlock Struct:g_SHUTDOWNTaskTCB.uBytesFreeOnStackMin
Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0.000000 Max:65535.000000 Format:8.0 UpdateID:BACKGND
Group:"System | Memory" Help:"Remaining bytes available on the SHUTDOWNTask stack" Unit:bytes */

/* Name: SHUTDOWNTaskCPU ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT2 CType:S_TaskCtrlBlock Struct:g_SHUTDOWNTaskTCB.u16TimerValue
Mask:FFFFFFFF Gain:0.0015259 Offset:0.0 Exp:1.0 Min:0.000000 Max:100.000000 Format:4.2 UpdateID:BACKGND
Group:"System | Performance" Help:"Percentage of CPU spent on SHUTDOWNTask task" Unit:% */
	
InstantiateMailBox_SingleSemaphore(g_ApplicationInterruptTask_MailBox);
InstantiateTask(g_ApplicationInterruptTask, 4, MotoCoder_TaskEventQueue_Execute, "ApplicationInterruptTask", &g_ApplicationInterruptTask_MailBox, 1024);
	
/* Name: ApplicationInterruptTaskStackMinBytesFree ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT2 CType:S_TaskCtrlBlock Struct:g_ApplicationInterruptTaskTCB.uBytesFreeOnStackMin
Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0.000000 Max:65535.000000 Format:8.0 UpdateID:BACKGND
Group:"System | Memory" Help:"Remaining bytes available on the ApplicationInterruptTask stack" Unit:bytes */

/* Name: ApplicationInterruptTaskCPU ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT2 CType:S_TaskCtrlBlock Struct:g_ApplicationInterruptTaskTCB.u16TimerValue
Mask:FFFFFFFF Gain:0.0015259 Offset:0.0 Exp:1.0 Min:0.000000 Max:100.000000 Format:4.2 UpdateID:BACKGND
Group:"System | Performance" Help:"Percentage of CPU spent on ApplicationInterruptTask task" Unit:% */
	

/* Variables used by scheduler */
uint8_T g_bAppOpen;
static uint32_T RTICounter_1000000 = 0;
static uint32_T RTICounter_100000 = 0;
static uint32_T RTICounter_25000 = 0;
static uint32_T RTICounter_50000 = 0;
static uint32_T RTICounter_500000 = 0;


/*---- FUNCTION CODE --------------------------------------------------------------------------------------*/

        
        
        
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: CheckApplicationStatus
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void CheckApplicationStatus(void)
{
        extern S_TaskCtrlBlock g_ApplicationInterruptTaskTCB;
    extern S_TaskCtrlBlock g_BGNDTaskTCB;
    extern S_TaskCtrlBlock g_SHUTDOWNTaskTCB;
    extern S_TaskCtrlBlock g_FGNDTaskTCB;

    extern uint2 g_u16InterruptStackMinBytesFree;
    extern uint32_T g_u32PeakHeapBytesUsed;
    extern uint32_T Timer_Watchdog_Starvation_Get(void);
    
    boolean_T stopApplication = 0;
    
    /* Handle re-entrancy */
    boolean_T inCheckApplicationStatus_Now;
    Interrupt_Disable();
    inCheckApplicationStatus_Now = inCheckApplicationStatus_DataStore();
    inCheckApplicationStatus_DataStore() = 1;
    Interrupt_Enable();
    
    if (inCheckApplicationStatus_Now) return;
    
    if ((ApplicationStatus_DataStore() != APPLICATION_STOP) &&  (ApplicationStatus_DataStore() != APPLICATION_RESET))
    {
        if (ApplicationMonitorEnable_DataStore() == APP_MONITOR_ENABLED)
        {
            /* Check stack, heap, and CPU time and stop the application on critical errors */
    
            
        if ((500000UL - Timer_Watchdog_Starvation_Get() ) < StarvationTimerMargin_DataStore() )
            {
                stopApplication = 1;
                ApplicationStopReason_DataStore() = STARVATION_MARGIN_STOP;
            }
            
            else if ((2048U - g_u32PeakHeapBytesUsed) < HeapMargin_DataStore())
            {
                stopApplication = 1;
                ApplicationStopReason_DataStore() = HEAP_MARGIN_STOP;
            }
            
            else if (g_AppTaskTCB.uBytesFreeOnStackMin < MainAppTaskStackMargin_DataStore())
            {
                stopApplication = 1;
                ApplicationStopReason_DataStore() = IDLE_MARGIN_STOP;
            }
            
            else if (g_u16InterruptStackMinBytesFree < InterruptTaskStackMargin_DataStore())
            {
                stopApplication = 1;
                ApplicationStopReason_DataStore() = INTERRUPT_MARGIN_STOP;
            }
        
            else if (g_ApplicationInterruptTaskTCB.uBytesFreeOnStackMin < ApplicationInterruptTaskStackMargin_DataStore())
            {
                stopApplication = 1;
                ApplicationStopReason_DataStore() = ApplicationInterruptTask_STOP;
            }
        
            else if (g_BGNDTaskTCB.uBytesFreeOnStackMin < BGNDTaskStackMargin_DataStore())
            {
                stopApplication = 1;
                ApplicationStopReason_DataStore() = BGNDTask_STOP;
            }
        
            else if (g_SHUTDOWNTaskTCB.uBytesFreeOnStackMin < SHUTDOWNTaskStackMargin_DataStore())
            {
                stopApplication = 1;
                ApplicationStopReason_DataStore() = SHUTDOWNTask_STOP;
            }
        
            else if (g_FGNDTaskTCB.uBytesFreeOnStackMin < FGNDTaskStackMargin_DataStore())
            {
                stopApplication = 1;
                ApplicationStopReason_DataStore() = FGNDTask_STOP;
            }
        
            else if ((ApplicationStopReason_DataStore() != APPLICATION_NO_STOP) && (ApplicationStatus_DataStore() == APPLICATION_RUN) && (prevApplicationStatus_DataStore() == APPLICATION_RUN))
            {
                /* Check if ApplicationStopReason was set by a line in the Application Code */
                stopApplication = 1;
            }
        }
    }
    else if (prevApplicationStatus_DataStore() != APPLICATION_STOP)
    {
        /* Check if the user has moved the ApplicationStatus to stop from MotoTune */
        stopApplication = 1;
        ApplicationStopReason_DataStore() = USER_STOP;
    }
    
    /* If the application should be stopped, execute stop code for each block, in priority order */
    if (stopApplication)
    {
        ApplicationStatus_DataStore() = APPLICATION_STOP;
        
        
            {extern void IO_Stop(void);
            IO_Stop();
            }
        
    }
    
    if (ApplicationStatus_DataStore() != APPLICATION_STOP)
    {
        ApplicationStopReason_DataStore() = APPLICATION_NO_STOP;
        ApplicationStopReasonAppLink_DataStore() = APP_MONITOR_NO_APP_LINK;
    }
    
    /* Upon request, execute an application reset */
    if (ApplicationStatus_DataStore() == APPLICATION_RESET)  
    {

        if ((ApplicationMonitorEnable_DataStore() == APP_MONITOR_ENABLED) && (prevApplicationStatus_DataStore() == APPLICATION_STOP))
        {
            /* Now that the application was already stopped and the app monitor is enabled */
            Module_Shutdown(0);
            ModuleSupport_Reset();
        }
        else 
        {
            ApplicationStatus_DataStore() = prevApplicationStatus_DataStore(); /* If the criteria is not satisfied, reset the app status to the previous */
        }
    }
    prevApplicationStatus_DataStore() = ApplicationStatus_DataStore();
    
    /* Handle re-entrancy */
    inCheckApplicationStatus_DataStore() = 0;
}

#define AppMonitor_IsAppRunning()  (ApplicationStatus_DataStore() == APPLICATION_RUN)

    

void ApplicationInit(void)
{
    
    /* Handle re-entrancy */
    boolean_T inStepApplicationStartup_Now;
    extern void Interrupt_Enable(void);
    extern void Interrupt_Disable(void);
    
    Interrupt_Disable();
    inStepApplicationStartup_Now = inStepApplicationStartup_DataStore();
    inStepApplicationStartup_DataStore() = 1;
    Interrupt_Enable();
    
    if (inStepApplicationStartup_Now) return;
    
    ApplicationStatus_DataStore() = APPLICATION_INIT;
    
    ApplicationInitStatus_DataStore() = (ApplicationPausePoint_DataStore() > APP_INIT_BEFORE_APP) ? APP_STATUS_NEXT : APP_STATUS_BEFORE_APP;
        
    if (ApplicationInitStatus_DataStore() == APP_STATUS_NEXT)
    {
    
            if ((ApplicationInitStatus_DataStore() == APP_STATUS_NEXT) && (ApplicationPausePoint_DataStore() > APP_INIT_OpenApplication))
            {
        
    
        /* Application Startup */
    {extern void OpenApplication(void);
        OpenApplication();
    }
                }
                else {
                    ApplicationInitStatus_DataStore() = APP_STATUS_OpenApplication;
                }
            
            if ((ApplicationInitStatus_DataStore() == APP_STATUS_NEXT) && (ApplicationPausePoint_DataStore() > APP_INIT_Trigger_STARTUP_EVENT_11965p0004))
            {
        
    
        /* Application Startup */
    {extern void Trigger_STARTUP_EVENT_11965p0004(void);
        Trigger_STARTUP_EVENT_11965p0004();
    }
                }
                else {
                    ApplicationInitStatus_DataStore() = APP_STATUS_Trigger_STARTUP_EVENT_11965p0004;
                }
            
            if ((ApplicationInitStatus_DataStore() == APP_STATUS_NEXT) && (ApplicationPausePoint_DataStore() > APP_INIT_Trigger_STARTUP_EVENT_9720p0004))
            {
        
    
        /* Application Startup */
    {extern void Trigger_STARTUP_EVENT_9720p0004(void);
        Trigger_STARTUP_EVENT_9720p0004();
    }
                }
                else {
                    ApplicationInitStatus_DataStore() = APP_STATUS_Trigger_STARTUP_EVENT_9720p0004;
                }
            
    }
    
    if (ApplicationInitStatus_DataStore() == APP_STATUS_NEXT) 
    {
        if (ApplicationPausePoint_DataStore() > APP_INIT_AFTER_APP) {
            ApplicationInitStatus_DataStore() =  APP_STATUS_NEXT;
        }
        else
        {
            ApplicationInitStatus_DataStore() =  APP_STATUS_AFTER_APP;
        }
    }
    
    if ((ApplicationInitStatus_DataStore() == APP_STATUS_NEXT) && (ApplicationPausePoint_DataStore() > APP_INIT_AFTER_APP))
    {
        ApplicationInitStatus_DataStore() = APP_STATUS_RUN;
        ApplicationStatus_DataStore() = APPLICATION_RUN;
    }

    /* Handle re-entrancy */
    inStepApplicationStartup_DataStore() = 0;
    
}

/* Application Startup */
void ApplicationOpen(void)
{

    /* Boot Status */
    g_bWasPowerUpStatusWarm = (uint8_T)ControlCore_PowerUpStatus_Query_WasWarm();
    
    
    /* Create Other User Tasks */
    MailBox_CreateStatic(&g_ApplicationInterruptTask_MailBox, 0);
    Task_CreateStatic(&g_ApplicationInterruptTask, TASK_CREATE_STATE_SUSPENDED);
    
    MailBox_CreateStatic(&g_SHUTDOWNTask_MailBox, 0);
    Task_CreateStatic(&g_SHUTDOWNTask, TASK_CREATE_STATE_SUSPENDED);
    
    MailBox_CreateStatic(&g_FGNDTask_MailBox, 0);
    Task_CreateStatic(&g_FGNDTask, TASK_CREATE_STATE_SUSPENDED);
    
    MailBox_CreateStatic(&g_BGNDTask_MailBox, 0);
    Task_CreateStatic(&g_BGNDTask, TASK_CREATE_STATE_SUSPENDED);
    
    
    /* Application Startup */
    {extern void ReadModuleConfig(void);
        ReadModuleConfig();
    }
    {extern void OpenMemory(void);
        OpenMemory();
    }
    {extern void Timer_FreeRunningCounter_ResetTime(void);
        Timer_FreeRunningCounter_ResetTime();
    }
    {extern void IO_Create(void);
        IO_Create();
    }
    {extern void NonVolatile_OpenDataStore(void);
        NonVolatile_OpenDataStore();
    }
    {extern void ApplicationInit(void);
        ApplicationInit();
    }
    {extern void KeySuite_Create(void);
        KeySuite_Create();
    }
    /* Start Other User Tasks */
    Task_Activate(&g_ApplicationInterruptTask);
    
    Task_Activate(&g_SHUTDOWNTask);
    
    Task_Activate(&g_FGNDTask);
    
    Task_Activate(&g_BGNDTask);
    
}

/* Main entry point at reset */
NativeVar_S MainAppTask(void* in_pAppTaskInfo)
{
	ApplicationOpen();
	g_bAppOpen = 1;

    /* Application's idle loop. This loop will execute with more priority than TRUE idle while ensuring that
       it does yield to ControlCore idle. Yielding to ControlCore idle ensures that operating properly metrics
       like starvation are handled. Unless otherwise configured, ControlCore assumes that 100% CPU utilization
       does not occur for extended periods of time. This premise would be broken if the application never yielded
       its Idle loop */
    {
        S_AppTaskParamInfo* const pAppTaskInfo = in_pAppTaskInfo;
        do
        {
            /* Application's Idle Loop Work */
			
    {extern void Trigger_IDLE_EVENT_11990p0004(void);
        Trigger_IDLE_EVENT_11990p0004();
    }
    {extern void Trigger_IDLE_EVENT_9p001(void);
        Trigger_IDLE_EVENT_9p001();
    }
    {extern void KeySuite_MessageHandler(void);
        KeySuite_MessageHandler();
    }
    {extern void KeySuite_RefreshPeriodicTimer(void);
        KeySuite_RefreshPeriodicTimer();
    }
          /* Waiting on IdleLoopCompleteEvent allows Control Core to perform idle tasks
		      such as calculation of stack metrics and management of the task starvation timer */
        } while(SUCCESS(SyncObj_WaitOn(pAppTaskInfo->hIdleLoopCompleteEvent, WAIT_INDEFINITELY)));
    }
	
	return 0;
}


/* Periodic Tasks */

void FGNDTask_100000(void)
{

        if (AppMonitor_IsAppRunning())
        {
        
    {extern void Trigger_FGND_20XRTI_PERIODIC_9951p0004(void);
        Trigger_FGND_20XRTI_PERIODIC_9951p0004();
    }
        }
        
        if (AppMonitor_IsAppRunning())
        {
        
    {extern void Trigger_FGND_20XRTI_PERIODIC_10085p0004(void);
        Trigger_FGND_20XRTI_PERIODIC_10085p0004();
    }
        }
        
        if (AppMonitor_IsAppRunning())
        {
        
    {extern void Trigger_FGND_20XRTI_PERIODIC_12067p0004(void);
        Trigger_FGND_20XRTI_PERIODIC_12067p0004();
    }
        }
        
}

void FGNDTask_5000(void)
{

        if (AppMonitor_IsAppRunning())
        {
        
    {extern void Trigger_FGND_RTI_PERIODIC_11578p0004(void);
        Trigger_FGND_RTI_PERIODIC_11578p0004();
    }
        }
        
        if (AppMonitor_IsAppRunning())
        {
        
    {extern void Trigger_FGND_RTI_PERIODIC_12065p0004(void);
        Trigger_FGND_RTI_PERIODIC_12065p0004();
    }
        }
        
}

void FGNDTask_25000(void)
{

        if (AppMonitor_IsAppRunning())
        {
        
    {extern void Trigger_FGND_5XRTI_PERIODIC_1093p0005(void);
        Trigger_FGND_5XRTI_PERIODIC_1093p0005();
    }
        }
        
        if (AppMonitor_IsAppRunning())
        {
        
    {extern void Trigger_FGND_5XRTI_PERIODIC_1094p0005(void);
        Trigger_FGND_5XRTI_PERIODIC_1094p0005();
    }
        }
        
        if (AppMonitor_IsAppRunning())
        {
        
    {extern void Trigger_FGND_5XRTI_PERIODIC_5057p0001(void);
        Trigger_FGND_5XRTI_PERIODIC_5057p0001();
    }
        }
        
        if (AppMonitor_IsAppRunning())
        {
        
    {extern void Trigger_FGND_5XRTI_PERIODIC_9815p0006(void);
        Trigger_FGND_5XRTI_PERIODIC_9815p0006();
    }
        }
        
        if (AppMonitor_IsAppRunning())
        {
        
    {extern void Trigger_FGND_5XRTI_PERIODIC_9816p0004(void);
        Trigger_FGND_5XRTI_PERIODIC_9816p0004();
    }
        }
        
        if (AppMonitor_IsAppRunning())
        {
        
    {extern void Trigger_FGND_5XRTI_PERIODIC_11294p0006(void);
        Trigger_FGND_5XRTI_PERIODIC_11294p0006();
    }
        }
        
        if (AppMonitor_IsAppRunning())
        {
        
    {extern void Trigger_FGND_5XRTI_PERIODIC_12064p0004(void);
        Trigger_FGND_5XRTI_PERIODIC_12064p0004();
    }
        }
        
}

void BGNDTask_1000000(void)
{

    {extern void FaultManagerPeriodicTick(void);
        FaultManagerPeriodicTick();
    }
        if (AppMonitor_IsAppRunning())
        {
        
    {extern void Trigger_ONE_SECOND_EVENT_12071p0004(void);
        Trigger_ONE_SECOND_EVENT_12071p0004();
    }
        }
        
        if (AppMonitor_IsAppRunning())
        {
        
    {extern void MotoHawkModelSecondsInUseTick(void);
        MotoHawkModelSecondsInUseTick();
    }
        }
        
}

void BGNDTask_50000(void)
{

        if (AppMonitor_IsAppRunning())
        {
        
    {extern void Trigger_BGND_BASE_PERIODIC_12068p0004(void);
        Trigger_BGND_BASE_PERIODIC_12068p0004();
    }
        }
        
        if (AppMonitor_IsAppRunning())
        {
        
    {extern void Trigger_BGND_BASE_PERIODIC_11570p0004(void);
        Trigger_BGND_BASE_PERIODIC_11570p0004();
    }
        }
        
}

void BGNDTask_100000(void)
{

        if (AppMonitor_IsAppRunning())
        {
        
    {extern void Trigger_BGND_BASEx2_PERIODIC_12069p0004(void);
        Trigger_BGND_BASEx2_PERIODIC_12069p0004();
    }
        }
        
}

void BGNDTask_500000(void)
{

        if (AppMonitor_IsAppRunning())
        {
        
    {extern void Trigger_BGND_BASEx10_PERIODIC_12070p0004(void);
        Trigger_BGND_BASEx10_PERIODIC_12070p0004();
    }
        }
        
}

/* SHUTDOWN  triggers */
void SHUTDOWNTask_SendEvent(void)
{
    
}

/* SHUTDOWN Task */
void SHUTDOWNTask_PostEvent(void)
{
{
    extern void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void));
	extern void SHUTDOWNTask_SendEvent(void);
	extern const S_MessageBoxDefn g_SHUTDOWNTask_MailBox;
	MotoCoder_TaskEvent_Post(&g_SHUTDOWNTask_MailBox, SHUTDOWNTask_SendEvent);
}
}

/* Name: CPUIdlePcnt ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT2 CType:uint16_T Struct:g_u16CPUIdlePcnt
Mask:FFFFFFFF Gain:0.0015259 Offset:0.0 Exp:1.0 Min:0.000000 Max:100.000000 Format:4.2 UpdateID:BACKGND
Group:"System | Performance" Help:"Percentage of CPU spent executing idle activity" Unit:% */
uint16_T g_u16CPUIdlePcnt;
void App_RTITimer_OnTick(void)
{
    /* Calculate CPUIdlePcnt */
    {
         /* CPUIdlePcnt for the ComponentControlCore Tasking system can be determined by summing the time spent executing
           the ComponentControlCore Kernel's Idle task with the Application Task. As the Application Task is also used for
           the execution of open activities, its data will be slightly skewed during start-up. */
        extern S_TaskCtrlBlock g_IdleTaskTCB;
        g_u16CPUIdlePcnt = g_IdleTaskTCB.u16TimerValue + g_AppTaskTCB.u16TimerValue;
    }
	if (g_bAppOpen)
	{
                        {
                        if (ApplicationInitStatus_DataStore() < APP_STATUS_RUN)
                        ApplicationStatus_DataStore() = APPLICATION_INIT;
                        
                        CheckApplicationStatus();
                        }
                    {
    extern void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void));
	extern void FGNDTask_5000(void);
	extern const S_MessageBoxDefn g_FGNDTask_MailBox;
	MotoCoder_TaskEvent_Post(&g_FGNDTask_MailBox, FGNDTask_5000);
}
		RTICounter_25000++;
		if (RTICounter_25000 >= 5)
		{
			RTICounter_25000 = 0;
		 {
    extern void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void));
	extern void FGNDTask_25000(void);
	extern const S_MessageBoxDefn g_FGNDTask_MailBox;
	MotoCoder_TaskEvent_Post(&g_FGNDTask_MailBox, FGNDTask_25000);
}
		}
		RTICounter_50000++;
		if (RTICounter_50000 >= 10)
		{
			RTICounter_50000 = 0;
		 {
    extern void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void));
	extern void BGNDTask_50000(void);
	extern const S_MessageBoxDefn g_BGNDTask_MailBox;
	MotoCoder_TaskEvent_Post(&g_BGNDTask_MailBox, BGNDTask_50000);
}
		}
		RTICounter_100000++;
		if (RTICounter_100000 >= 20)
		{
			RTICounter_100000 = 0;
		 {
    extern void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void));
	extern void FGNDTask_100000(void);
	extern const S_MessageBoxDefn g_FGNDTask_MailBox;
	MotoCoder_TaskEvent_Post(&g_FGNDTask_MailBox, FGNDTask_100000);
}{
    extern void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void));
	extern void BGNDTask_100000(void);
	extern const S_MessageBoxDefn g_BGNDTask_MailBox;
	MotoCoder_TaskEvent_Post(&g_BGNDTask_MailBox, BGNDTask_100000);
}
		}
		RTICounter_500000++;
		if (RTICounter_500000 >= 100)
		{
			RTICounter_500000 = 0;
		 {
    extern void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void));
	extern void BGNDTask_500000(void);
	extern const S_MessageBoxDefn g_BGNDTask_MailBox;
	MotoCoder_TaskEvent_Post(&g_BGNDTask_MailBox, BGNDTask_500000);
}
		}
		RTICounter_1000000++;
		if (RTICounter_1000000 >= 200)
		{
			RTICounter_1000000 = 0;
		 {
    extern void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void));
	extern void BGNDTask_1000000(void);
	extern const S_MessageBoxDefn g_BGNDTask_MailBox;
	MotoCoder_TaskEvent_Post(&g_BGNDTask_MailBox, BGNDTask_1000000);
}
		}
                    /* Re-run the application initialization */
                    if ((ApplicationStatus_DataStore() == APPLICATION_INIT))
                    {
                        ApplicationInit();
                    }
                    
	}
}

NativeVar_S MotoCoder_TaskEventQueue_Execute(void *mailBox)
{
	void (*fcnPtr)(void);
	MailBoxHandle hHandle;
	NativeError_S sError;
	
	hHandle = (MailBoxHandle) mailBox;
	if (hHandle)
	{
		do
		{
			sError = MailBox_FetchFrom(hHandle, (void**)&fcnPtr, WAIT_INDEFINITELY);
			if (SUCCESS(sError))
			{
				if( (fcnPtr) && (g_bAppOpen != 0) )
				{
					(*fcnPtr)();
				}
			}
		} while(SUCCESS(sError));
    }

	return (0);
}

void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void))
{
    extern boolean_T g_bAppOpen;
    
    if(g_bAppOpen != 0)
    {
        MailBox_PostTo(in_pMailBox, FuncPtr, 0);
    }
}




/*---- eTPU SETUP --------------------------------------------------------------------------------*/

/* eTPU setup */

E_FPSCK const g_eTPUFilterPreScale = FPSCK_SYS_CLK_DIV_2;
E_CDFC const g_eTPUDigitalFilterCtrl = CDFC_CONTINUOUS_SAMPLE_MODE;
E_TCRCF const g_eTPUTCRCLKFilter = TCRCF_2SAMPLE_SYSCLK_DIV2;
	
		
/* Set to TRUE when eTPU_Open() is called */
bool1 const g_bIsAppUsingETPU = TRUE;

void eTPU_Startup(void)
{
	eTPU_Open(ETPU_0, &g_TPUMaskDefn_EngineBasic);
}

extern void const* GET_NAME_CPUISR_OBJ(CNK,Encoder);
	extern void const* GET_NAME_CPUISR_OBJ(SPD1,FreqIn);
	extern void const* GET_NAME_CPUISR_OBJ(SPD2,FreqIn);
	extern void const* GET_NAME_CPUISR_OBJ(SPD3,FreqIn);
	extern void const* GET_NAME_CPUISR_OBJ(CAM,CamEncoder);
	extern void const* GET_NAME_CPUISR_OBJ(EST1,PSP);
	extern void const* GET_NAME_CPUISR_OBJ(EST2,PSP);
	extern void const* GET_NAME_CPUISR_OBJ(EST3,PSP);
	extern void const* GET_NAME_CPUISR_OBJ(EST4,PSP);
	extern void const* GET_NAME_CPUISR_OBJ(EST5,PSP);
	extern void const* GET_NAME_CPUISR_OBJ(EST6,PSP);
	extern void const* GET_NAME_CPUISR_OBJ(EST7,PSP);
	extern void const* GET_NAME_CPUISR_OBJ(EST8,PSP);
	extern void const* GET_NAME_CPUISR_OBJ(INJ1,PSP);
	extern void const* GET_NAME_CPUISR_OBJ(INJ2,PSP);
	extern void const* GET_NAME_CPUISR_OBJ(INJ3,PSP);
	extern void const* GET_NAME_CPUISR_OBJ(INJ4,PSP);
	extern void const* GET_NAME_CPUISR_OBJ(INJ5,PSP);
	extern void const* GET_NAME_CPUISR_OBJ(INJ6,PSP);
	extern void const* GET_NAME_CPUISR_OBJ(INJ7,PSP);
	extern void const* GET_NAME_CPUISR_OBJ(INJ8,PSP);
	

S_eTPU_ISR_Defn const g_eTPU_ISRArr[NUM_ETPU_CHANNELS] = 
{
/* { CPU Behavior ISR, Device Specific Context} */
	/* ETPU_A0 */ {eTPU_Encoder_ISR, &GET_NAME_CPUISR_OBJ(CNK,Encoder) },
	/* ETPU_A1 */ {eTPU_FreqIn_ISR, &GET_NAME_CPUISR_OBJ(SPD2,FreqIn) },
	/* ETPU_A2 */ {NULL, NULL },
	/* ETPU_A3 */ {NULL, NULL },
	/* ETPU_A4 */ {eTPU_PSP_ISR, &GET_NAME_CPUISR_OBJ(EST2,PSP) },
	/* ETPU_A5 */ {eTPU_PSP_ISR, &GET_NAME_CPUISR_OBJ(EST3,PSP) },
	/* ETPU_A6 */ {eTPU_PSP_ISR, &GET_NAME_CPUISR_OBJ(EST4,PSP) },
	/* ETPU_A7 */ {eTPU_PSP_ISR, &GET_NAME_CPUISR_OBJ(EST5,PSP) },
	/* ETPU_A8 */ {eTPU_PSP_ISR, &GET_NAME_CPUISR_OBJ(EST6,PSP) },
	/* ETPU_A9 */ {eTPU_PSP_ISR, &GET_NAME_CPUISR_OBJ(EST7,PSP) },
	/* ETPU_A10 */ {eTPU_PSP_ISR, &GET_NAME_CPUISR_OBJ(EST8,PSP) },
	/* ETPU_A11 */ {eTPU_PSP_ISR, &GET_NAME_CPUISR_OBJ(EST1,PSP) },
	/* ETPU_A12 */ {NULL, NULL },
	/* ETPU_A13 */ {eTPU_FreqIn_ISR, &GET_NAME_CPUISR_OBJ(SPD3,FreqIn) },
	/* ETPU_A14 */ {eTPU_FreqIn_ISR, &GET_NAME_CPUISR_OBJ(SPD1,FreqIn) },
	/* ETPU_A15 */ {eTPU_CamEncoder_ISR, &GET_NAME_CPUISR_OBJ(CAM,CamEncoder) },
	/* ETPU_A16 */ {eTPU_PSP_ISR, &GET_NAME_CPUISR_OBJ(INJ1,PSP) },
	/* ETPU_A17 */ {eTPU_PSP_ISR, &GET_NAME_CPUISR_OBJ(INJ2,PSP) },
	/* ETPU_A18 */ {eTPU_PSP_ISR, &GET_NAME_CPUISR_OBJ(INJ3,PSP) },
	/* ETPU_A19 */ {eTPU_PSP_ISR, &GET_NAME_CPUISR_OBJ(INJ4,PSP) },
	/* ETPU_A20 */ {eTPU_PSP_ISR, &GET_NAME_CPUISR_OBJ(INJ5,PSP) },
	/* ETPU_A21 */ {eTPU_PSP_ISR, &GET_NAME_CPUISR_OBJ(INJ6,PSP) },
	/* ETPU_A22 */ {eTPU_PSP_ISR, &GET_NAME_CPUISR_OBJ(INJ7,PSP) },
	/* ETPU_A23 */ {eTPU_PSP_ISR, &GET_NAME_CPUISR_OBJ(INJ8,PSP) },
	/* ETPU_A24 */ {NULL, NULL },
	/* ETPU_A25 */ {NULL, NULL },
	/* ETPU_A26 */ {NULL, NULL },
	/* ETPU_A27 */ {NULL, NULL },
	/* ETPU_A28 */ {NULL, NULL },
	/* ETPU_A29 */ {NULL, NULL },
	/* ETPU_A30 */ {NULL, NULL },
	/* ETPU_A31 */ {NULL, NULL },
	/* ETPU_B0 */ {NULL, NULL },
	/* ETPU_B1 */ {NULL, NULL },
	/* ETPU_B2 */ {NULL, NULL },
	/* ETPU_B3 */ {NULL, NULL },
	/* ETPU_B4 */ {NULL, NULL },
	/* ETPU_B5 */ {NULL, NULL },
	/* ETPU_B6 */ {NULL, NULL },
	/* ETPU_B7 */ {NULL, NULL },
	/* ETPU_B8 */ {NULL, NULL },
	/* ETPU_B9 */ {NULL, NULL },
	/* ETPU_B10 */ {NULL, NULL },
	/* ETPU_B11 */ {NULL, NULL },
	/* ETPU_B12 */ {NULL, NULL },
	/* ETPU_B13 */ {NULL, NULL },
	/* ETPU_B14 */ {NULL, NULL },
	/* ETPU_B15 */ {NULL, NULL },
	/* ETPU_B16 */ {NULL, NULL },
	/* ETPU_B17 */ {NULL, NULL },
	/* ETPU_B18 */ {NULL, NULL },
	/* ETPU_B19 */ {NULL, NULL },
	/* ETPU_B20 */ {NULL, NULL },
	/* ETPU_B21 */ {NULL, NULL },
	/* ETPU_B22 */ {NULL, NULL },
	/* ETPU_B23 */ {NULL, NULL },
	/* ETPU_B24 */ {NULL, NULL },
	/* ETPU_B25 */ {NULL, NULL },
	/* ETPU_B26 */ {NULL, NULL },
	/* ETPU_B27 */ {NULL, NULL },
	/* ETPU_B28 */ {NULL, NULL },
	/* ETPU_B29 */ {NULL, NULL },
	/* ETPU_B30 */ {NULL, NULL },
	/* ETPU_B31 */ {NULL, NULL },

};

S_eTPU_ISRObj const g_eTPU_ISRObj =
{
	g_eTPU_ISRArr,
};





/*---- eSCI SETUP -----------------------------------------------------------------------------------------*/
extern S_SCIModuleDefn const RS485;

S_SCIModuleDefn const* const g_SCIModuleDefnArr[NUM_ESCI_MODULES] = 
{
    /* ESCI_A */   &RS485,
    /* ESCI_B */   NULL,

};




/*---- eMIOS SETUP --------------------------------------------------------------------------------*/


/* Request that the TickTimer employ eMIOS_1 as its timer resource */
E_eMIOSUnifiedChannel const g_eMIOSTickTimerChannel = eMIOS_1;

/* Request that the TickTimer, when implemented using the eMIOS subsystem, employ a INTCPRIORITY_5. */
E_INTCPriority const g_eMIOSTickTimerISRPriority = INTCPRIORITY_5;

/* Specify that the TickTimer mode shall be implemented using the eMIOS method */
E_TickTimerMode const g_eTickTimerMode = TICK_TIMER_MODE_EMIOS;
    

S_eMIOS_ISR_Defn const g_eMIOS_ISRArr[NUM_EMIOS_CHANNELS] = 
{
	/* EMIOS_0 */ {NULL, NULL },
	/* EMIOS_1 */ {eMIOS_TickTimer_ISR, NULL },
	/* EMIOS_2 */ {NULL, NULL },
	/* EMIOS_3 */ {NULL, NULL },
	/* EMIOS_4 */ {NULL, NULL },
	/* EMIOS_5 */ {NULL, NULL },
	/* EMIOS_6 */ {NULL, NULL },
	/* EMIOS_7 */ {NULL, NULL },
	/* EMIOS_8 */ {NULL, NULL },
	/* EMIOS_9 */ {NULL, NULL },
	/* EMIOS_10 */ {NULL, NULL },
	/* EMIOS_11 */ {NULL, NULL },
	/* EMIOS_12 */ {NULL, NULL },
	/* EMIOS_13 */ {NULL, NULL },
	/* EMIOS_14 */ {NULL, NULL },
	/* EMIOS_15 */ {NULL, NULL },
	/* EMIOS_16 */ {NULL, NULL },
	/* EMIOS_17 */ {NULL, NULL },
	/* EMIOS_18 */ {NULL, NULL },
	/* EMIOS_19 */ {NULL, NULL },
	/* EMIOS_20 */ {NULL, NULL },
	/* EMIOS_21 */ {NULL, NULL },
	/* EMIOS_22 */ {NULL, NULL },
	/* EMIOS_23 */ {NULL, NULL },

};


